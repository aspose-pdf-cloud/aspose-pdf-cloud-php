<?php
/**
 * PdfApi
 * PHP version 5
 *
 * @category Class
 * @package  Aspose\PDF
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 *
 *   Copyright (c) 2018 Aspose.PDF Cloud
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Aspose\PDF\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Aspose\PDF\ApiException;
use Aspose\PDF\Configuration;
use Aspose\PDF\HeaderSelector;
use Aspose\PDF\ObjectSerializer;

/**
 * PdfApi Class Doc Comment
 *
 * @category Class
 * @package  Aspose\PDF
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PdfApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteField
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function deleteField($name, $field_name, $storage = null, $folder = null)
    {
        list($response) = $this->deleteFieldWithHttpInfo($name, $field_name, $storage, $folder);
        return $response;
    }

    /**
     * Operation deleteFieldWithHttpInfo
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFieldWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deleteFieldRequest($name, $field_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFieldAsync
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsync($name, $field_name, $storage = null, $folder = null)
    {
        return $this->deleteFieldAsyncWithHttpInfo($name, $field_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFieldAsyncWithHttpInfo
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsyncWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deleteFieldRequest($name, $field_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFieldRequest($name, $field_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling deleteField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePage
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function deletePage($name, $page_number, $storage = null, $folder = null)
    {
        list($response) = $this->deletePageWithHttpInfo($name, $page_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation deletePageWithHttpInfo
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePageRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageAsync
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageAsyncWithHttpInfo
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePageRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProperties
     *
     * Delete custom document properties.
     *
     * @param  string $name name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function deleteProperties($name, $storage = null, $folder = null)
    {
        list($response) = $this->deletePropertiesWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation deletePropertiesWithHttpInfo
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePropertiesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePropertiesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePropertiesAsync
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertiesAsync($name, $storage = null, $folder = null)
    {
        return $this->deletePropertiesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePropertiesAsyncWithHttpInfo
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertiesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePropertiesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProperties'
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePropertiesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteProperties'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProperty
     *
     * Delete document property.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function deleteProperty($name, $property_name, $storage = null, $folder = null)
    {
        list($response) = $this->deletePropertyWithHttpInfo($name, $property_name, $storage, $folder);
        return $response;
    }

    /**
     * Operation deletePropertyWithHttpInfo
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePropertyWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePropertyRequest($name, $property_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePropertyAsync
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertyAsync($name, $property_name, $storage = null, $folder = null)
    {
        return $this->deletePropertyAsyncWithHttpInfo($name, $property_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePropertyAsyncWithHttpInfo
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertyAsyncWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePropertyRequest($name, $property_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePropertyRequest($name, $property_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling deleteProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocument
     *
     * Read common document info or convert to some format if the format specified.
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocument($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        list($response) = $this->getDocumentWithHttpInfo($name, $format, $storage, $folder, $out_path);
        return $response;
    }

    /**
     * Operation getDocumentWithHttpInfo
     *
     * Read common document info or convert to some format if the format specified.
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentWithHttpInfo($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentRequest($name, $format, $storage, $folder, $out_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAsync
     *
     * Read common document info or convert to some format if the format specified.
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsync($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        return $this->getDocumentAsyncWithHttpInfo($name, $format, $storage, $folder, $out_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAsyncWithHttpInfo
     *
     * Read common document info or convert to some format if the format specified.
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsyncWithHttpInfo($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentRequest($name, $format, $storage, $folder, $out_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocument'
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentRequest($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocument'
            );
        }

        $resourcePath = '/pdf/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAttachmentByIndex
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AttachmentResponse
     */
    public function getDocumentAttachmentByIndex($name, $attachment_index, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentAttachmentByIndexWithHttpInfo
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AttachmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentResponse';
        $request = $this->getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AttachmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAttachmentByIndexAsync
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentByIndexAsync($name, $attachment_index, $storage = null, $folder = null)
    {
        return $this->getDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAttachmentByIndexAsyncWithHttpInfo
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentResponse';
        $request = $this->getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAttachmentByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAttachmentByIndex'
            );
        }
        // verify the required parameter 'attachment_index' is set
        if ($attachment_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_index when calling getDocumentAttachmentByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/attachments/{attachmentIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($attachment_index !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentIndex' . '}',
                ObjectSerializer::toPathValue($attachment_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAttachments
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AttachmentsResponse
     */
    public function getDocumentAttachments($name, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentAttachmentsWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentAttachmentsWithHttpInfo
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AttachmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAttachmentsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentsResponse';
        $request = $this->getDocumentAttachmentsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AttachmentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAttachmentsAsync
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentAttachmentsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAttachmentsAsyncWithHttpInfo
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentsResponse';
        $request = $this->getDocumentAttachmentsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAttachments'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAttachmentsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAttachments'
            );
        }

        $resourcePath = '/pdf/{name}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentBookmarks
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentBookmarks($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentBookmarksWithHttpInfo($name, $bookmark_path, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentBookmarksWithHttpInfo
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentBookmarksWithHttpInfo($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentBookmarksRequest($name, $bookmark_path, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentBookmarksAsync
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentBookmarksAsync($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        return $this->getDocumentBookmarksAsyncWithHttpInfo($name, $bookmark_path, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentBookmarksAsyncWithHttpInfo
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentBookmarksAsyncWithHttpInfo($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentBookmarksRequest($name, $bookmark_path, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentBookmarks'
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentBookmarksRequest($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentBookmarks'
            );
        }

        $resourcePath = '/pdf/{name}/bookmarks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($bookmark_path !== null) {
            $queryParams['bookmarkPath'] = ObjectSerializer::toQueryValue($bookmark_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentProperties
     *
     * Read document properties.
     *
     * @param  string $name name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertiesResponse
     */
    public function getDocumentProperties($name, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentPropertiesWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentPropertiesWithHttpInfo
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertiesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPropertiesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertiesResponse';
        $request = $this->getDocumentPropertiesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertiesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPropertiesAsync
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPropertiesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPropertiesAsyncWithHttpInfo
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertiesResponse';
        $request = $this->getDocumentPropertiesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentProperties'
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPropertiesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentProperties'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentProperty
     *
     * Read document property by name.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertyResponse
     */
    public function getDocumentProperty($name, $property_name, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentPropertyWithHttpInfo($name, $property_name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentPropertyWithHttpInfo
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPropertyWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->getDocumentPropertyRequest($name, $property_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPropertyAsync
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyAsync($name, $property_name, $storage = null, $folder = null)
    {
        return $this->getDocumentPropertyAsyncWithHttpInfo($name, $property_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPropertyAsyncWithHttpInfo
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyAsyncWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->getDocumentPropertyRequest($name, $property_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPropertyRequest($name, $property_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling getDocumentProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownload
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDownload($path, $version_id = null, $storage = null)
    {
        list($response) = $this->getDownloadWithHttpInfo($path, $version_id, $storage);
        return $response;
    }

    /**
     * Operation getDownloadWithHttpInfo
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadRequest($path, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadAsync
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadAsync($path, $version_id = null, $storage = null)
    {
        return $this->getDownloadAsyncWithHttpInfo($path, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadAsyncWithHttpInfo
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadAsyncWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadRequest($path, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownload'
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadRequest($path, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getDownload'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndex
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDownloadDocumentAttachmentByIndex($name, $attachment_index, $storage = null, $folder = null)
    {
        list($response) = $this->getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexWithHttpInfo
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexAsync
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadDocumentAttachmentByIndexAsync($name, $attachment_index, $storage = null, $folder = null)
    {
        return $this->getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadDocumentAttachmentByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDownloadDocumentAttachmentByIndex'
            );
        }
        // verify the required parameter 'attachment_index' is set
        if ($attachment_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_index when calling getDownloadDocumentAttachmentByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/attachments/{attachmentIndex}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($attachment_index !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentIndex' . '}',
                ObjectSerializer::toPathValue($attachment_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpubInStorageToPdf
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getEpubInStorageToPdf($src_path)
    {
        list($response) = $this->getEpubInStorageToPdfWithHttpInfo($src_path);
        return $response;
    }

    /**
     * Operation getEpubInStorageToPdfWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEpubInStorageToPdfWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getEpubInStorageToPdfRequest($src_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEpubInStorageToPdfAsync
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpubInStorageToPdfAsync($src_path)
    {
        return $this->getEpubInStorageToPdfAsyncWithHttpInfo($src_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpubInStorageToPdfAsyncWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpubInStorageToPdfAsyncWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getEpubInStorageToPdfRequest($src_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEpubInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEpubInStorageToPdfRequest($src_path)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getEpubInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getField
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldResponse
     */
    public function getField($name, $field_name, $storage = null, $folder = null)
    {
        list($response) = $this->getFieldWithHttpInfo($name, $field_name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFieldWithHttpInfo
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->getFieldRequest($name, $field_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldAsync
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsync($name, $field_name, $storage = null, $folder = null)
    {
        return $this->getFieldAsyncWithHttpInfo($name, $field_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldAsyncWithHttpInfo
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsyncWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->getFieldRequest($name, $field_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFieldRequest($name, $field_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFields
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldsResponse
     */
    public function getFields($name, $storage = null, $folder = null)
    {
        list($response) = $this->getFieldsWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFieldsWithHttpInfo
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->getFieldsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldsAsync
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsync($name, $storage = null, $folder = null)
    {
        return $this->getFieldsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldsAsyncWithHttpInfo
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->getFieldsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFields'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFieldsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFields'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFragment
     *
     * Read page fragment.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getFragment($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getFragmentWithHttpInfo($name, $page_number, $fragment_number, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFragmentWithHttpInfo
     *
     * Read page fragment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFragmentWithHttpInfo($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getFragmentRequest($name, $page_number, $fragment_number, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFragmentAsync
     *
     * Read page fragment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentAsync($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getFragmentAsyncWithHttpInfo($name, $page_number, $fragment_number, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFragmentAsyncWithHttpInfo
     *
     * Read page fragment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentAsyncWithHttpInfo($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getFragmentRequest($name, $page_number, $fragment_number, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFragment'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFragmentRequest($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFragment'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getFragment'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getFragment'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFragmentTextFormat
     *
     * Read page fragment text format.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextFormatResponse
     */
    public function getFragmentTextFormat($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        list($response) = $this->getFragmentTextFormatWithHttpInfo($name, $page_number, $fragment_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFragmentTextFormatWithHttpInfo
     *
     * Read page fragment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFragmentTextFormatWithHttpInfo($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextFormatResponse';
        $request = $this->getFragmentTextFormatRequest($name, $page_number, $fragment_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextFormatResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFragmentTextFormatAsync
     *
     * Read page fragment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentTextFormatAsync($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        return $this->getFragmentTextFormatAsyncWithHttpInfo($name, $page_number, $fragment_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFragmentTextFormatAsyncWithHttpInfo
     *
     * Read page fragment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentTextFormatAsyncWithHttpInfo($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextFormatResponse';
        $request = $this->getFragmentTextFormatRequest($name, $page_number, $fragment_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFragmentTextFormat'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFragmentTextFormatRequest($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFragmentTextFormat'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getFragmentTextFormat'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getFragmentTextFormat'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/textFormat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFragments
     *
     * Read page fragments.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getFragments($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getFragmentsWithHttpInfo($name, $page_number, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFragmentsWithHttpInfo
     *
     * Read page fragments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFragmentsWithHttpInfo($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getFragmentsRequest($name, $page_number, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFragmentsAsync
     *
     * Read page fragments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentsAsync($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getFragmentsAsyncWithHttpInfo($name, $page_number, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFragmentsAsyncWithHttpInfo
     *
     * Read page fragments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentsAsyncWithHttpInfo($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getFragmentsRequest($name, $page_number, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFragments'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFragmentsRequest($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFragments'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getFragments'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHtmlInStorageToPdf
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getHtmlInStorageToPdf($src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        list($response) = $this->getHtmlInStorageToPdfWithHttpInfo($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top);
        return $response;
    }

    /**
     * Operation getHtmlInStorageToPdfWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHtmlInStorageToPdfWithHttpInfo($src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getHtmlInStorageToPdfRequest($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHtmlInStorageToPdfAsync
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHtmlInStorageToPdfAsync($src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        return $this->getHtmlInStorageToPdfAsyncWithHttpInfo($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHtmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHtmlInStorageToPdfAsyncWithHttpInfo($src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getHtmlInStorageToPdfRequest($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHtmlInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHtmlInStorageToPdfRequest($src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getHtmlInStorageToPdf'
            );
        }
        // verify the required parameter 'html_file_name' is set
        if ($html_file_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $html_file_name when calling getHtmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($html_file_name !== null) {
            $queryParams['htmlFileName'] = ObjectSerializer::toQueryValue($html_file_name);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImage
     *
     * Extract document image in format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImage($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        list($response) = $this->getImageWithHttpInfo($name, $page_number, $image_number, $format, $width, $height, $storage, $folder);
        return $response;
    }

    /**
     * Operation getImageWithHttpInfo
     *
     * Extract document image in format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageWithHttpInfo($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageRequest($name, $page_number, $image_number, $format, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageAsync
     *
     * Extract document image in format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageAsync($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        return $this->getImageAsyncWithHttpInfo($name, $page_number, $image_number, $format, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageAsyncWithHttpInfo
     *
     * Extract document image in format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageAsyncWithHttpInfo($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageRequest($name, $page_number, $image_number, $format, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageRequest($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getImage'
            );
        }
        // verify the required parameter 'image_number' is set
        if ($image_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_number when calling getImage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/{imageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($image_number !== null) {
            $resourcePath = str_replace(
                '{' . 'imageNumber' . '}',
                ObjectSerializer::toPathValue($image_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImages
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImagesResponse
     */
    public function getImages($name, $page_number, $storage = null, $folder = null)
    {
        list($response) = $this->getImagesWithHttpInfo($name, $page_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getImagesWithHttpInfo
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImagesWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImagesResponse';
        $request = $this->getImagesRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImagesAsync
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getImagesAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImagesAsyncWithHttpInfo
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImagesResponse';
        $request = $this->getImagesRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImages'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImagesRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImages'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getImages'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLaTeXInStorageToPdf
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getLaTeXInStorageToPdf($src_path)
    {
        list($response) = $this->getLaTeXInStorageToPdfWithHttpInfo($src_path);
        return $response;
    }

    /**
     * Operation getLaTeXInStorageToPdfWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLaTeXInStorageToPdfWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getLaTeXInStorageToPdfRequest($src_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLaTeXInStorageToPdfAsync
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLaTeXInStorageToPdfAsync($src_path)
    {
        return $this->getLaTeXInStorageToPdfAsyncWithHttpInfo($src_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLaTeXInStorageToPdfAsyncWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLaTeXInStorageToPdfAsyncWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getLaTeXInStorageToPdfRequest($src_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLaTeXInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLaTeXInStorageToPdfRequest($src_path)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getLaTeXInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMhtInStorageToPdf
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getMhtInStorageToPdf($src_path)
    {
        list($response) = $this->getMhtInStorageToPdfWithHttpInfo($src_path);
        return $response;
    }

    /**
     * Operation getMhtInStorageToPdfWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMhtInStorageToPdfWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getMhtInStorageToPdfRequest($src_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMhtInStorageToPdfAsync
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMhtInStorageToPdfAsync($src_path)
    {
        return $this->getMhtInStorageToPdfAsyncWithHttpInfo($src_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMhtInStorageToPdfAsyncWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMhtInStorageToPdfAsyncWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getMhtInStorageToPdfRequest($src_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMhtInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMhtInStorageToPdfRequest($src_path)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getMhtInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/mht';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPage
     *
     * Convert document page to format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPage($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        list($response) = $this->getPageWithHttpInfo($name, $page_number, $format, $width, $height, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageWithHttpInfo
     *
     * Convert document page to format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageWithHttpInfo($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageRequest($name, $page_number, $format, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAsync
     *
     * Convert document page to format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAsync($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        return $this->getPageAsyncWithHttpInfo($name, $page_number, $format, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAsyncWithHttpInfo
     *
     * Convert document page to format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAsyncWithHttpInfo($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageRequest($name, $page_number, $format, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageRequest($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageAnnotation
     *
     * Read document page annotation by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AnnotationResponse
     */
    public function getPageAnnotation($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        list($response) = $this->getPageAnnotationWithHttpInfo($name, $page_number, $annotation_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageAnnotationWithHttpInfo
     *
     * Read document page annotation by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageAnnotationWithHttpInfo($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationResponse';
        $request = $this->getPageAnnotationRequest($name, $page_number, $annotation_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAnnotationAsync
     *
     * Read document page annotation by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationAsync($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        return $this->getPageAnnotationAsyncWithHttpInfo($name, $page_number, $annotation_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAnnotationAsyncWithHttpInfo
     *
     * Read document page annotation by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationAsyncWithHttpInfo($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationResponse';
        $request = $this->getPageAnnotationRequest($name, $page_number, $annotation_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageAnnotationRequest($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageAnnotation'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageAnnotation'
            );
        }
        // verify the required parameter 'annotation_number' is set
        if ($annotation_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_number when calling getPageAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/{annotationNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($annotation_number !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationNumber' . '}',
                ObjectSerializer::toPathValue($annotation_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageAnnotations
     *
     * Read documant page annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AnnotationsResponse
     */
    public function getPageAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        list($response) = $this->getPageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageAnnotationsWithHttpInfo
     *
     * Read documant page annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsResponse';
        $request = $this->getPageAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAnnotationsAsync
     *
     * Read documant page annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAnnotationsAsyncWithHttpInfo
     *
     * Read documant page annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsResponse';
        $request = $this->getPageAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToBmp
     *
     * Convert document page to Bmp image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToBmp($name, $page_number, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->getPageConvertToBmpWithHttpInfo($name, $page_number, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation getPageConvertToBmpWithHttpInfo
     *
     * Convert document page to Bmp image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToBmpWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToBmpRequest($name, $page_number, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToBmpAsync
     *
     * Convert document page to Bmp image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToBmpAsync($name, $page_number, $width = null, $height = null, $folder = null)
    {
        return $this->getPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToBmpAsyncWithHttpInfo
     *
     * Convert document page to Bmp image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToBmpRequest($name, $page_number, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToBmp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToBmpRequest($name, $page_number, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToBmp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToBmp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/bmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToEmf
     *
     * Convert document page to Emf image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToEmf($name, $page_number, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->getPageConvertToEmfWithHttpInfo($name, $page_number, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation getPageConvertToEmfWithHttpInfo
     *
     * Convert document page to Emf image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToEmfWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToEmfRequest($name, $page_number, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToEmfAsync
     *
     * Convert document page to Emf image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToEmfAsync($name, $page_number, $width = null, $height = null, $folder = null)
    {
        return $this->getPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToEmfAsyncWithHttpInfo
     *
     * Convert document page to Emf image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToEmfRequest($name, $page_number, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToEmf'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToEmfRequest($name, $page_number, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToEmf'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToEmf'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/emf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToGif
     *
     * Convert document page to Gif image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToGif($name, $page_number, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->getPageConvertToGifWithHttpInfo($name, $page_number, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation getPageConvertToGifWithHttpInfo
     *
     * Convert document page to Gif image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToGifWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToGifRequest($name, $page_number, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToGifAsync
     *
     * Convert document page to Gif image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToGifAsync($name, $page_number, $width = null, $height = null, $folder = null)
    {
        return $this->getPageConvertToGifAsyncWithHttpInfo($name, $page_number, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToGifAsyncWithHttpInfo
     *
     * Convert document page to Gif image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToGifAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToGifRequest($name, $page_number, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToGif'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToGifRequest($name, $page_number, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToGif'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToGif'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToJpeg
     *
     * Convert document page to Jpeg image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToJpeg($name, $page_number, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->getPageConvertToJpegWithHttpInfo($name, $page_number, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation getPageConvertToJpegWithHttpInfo
     *
     * Convert document page to Jpeg image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToJpegWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToJpegRequest($name, $page_number, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToJpegAsync
     *
     * Convert document page to Jpeg image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToJpegAsync($name, $page_number, $width = null, $height = null, $folder = null)
    {
        return $this->getPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToJpegAsyncWithHttpInfo
     *
     * Convert document page to Jpeg image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToJpegRequest($name, $page_number, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToJpegRequest($name, $page_number, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToJpeg'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToPng
     *
     * Convert document page to Png image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToPng($name, $page_number, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->getPageConvertToPngWithHttpInfo($name, $page_number, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation getPageConvertToPngWithHttpInfo
     *
     * Convert document page to Png image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToPngWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToPngRequest($name, $page_number, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToPngAsync
     *
     * Convert document page to Png image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToPngAsync($name, $page_number, $width = null, $height = null, $folder = null)
    {
        return $this->getPageConvertToPngAsyncWithHttpInfo($name, $page_number, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToPngAsyncWithHttpInfo
     *
     * Convert document page to Png image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToPngAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToPngRequest($name, $page_number, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToPng'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToPngRequest($name, $page_number, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToPng'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToPng'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToTiff
     *
     * Convert document page to Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToTiff($name, $page_number, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->getPageConvertToTiffWithHttpInfo($name, $page_number, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation getPageConvertToTiffWithHttpInfo
     *
     * Convert document page to Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToTiffWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToTiffRequest($name, $page_number, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToTiffAsync
     *
     * Convert document page to Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToTiffAsync($name, $page_number, $width = null, $height = null, $folder = null)
    {
        return $this->getPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToTiffAsyncWithHttpInfo
     *
     * Convert document page to Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToTiffRequest($name, $page_number, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToTiffRequest($name, $page_number, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToTiff'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLinkAnnotationByIndex
     *
     * Read document page link annotation by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationResponse
     */
    public function getPageLinkAnnotationByIndex($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        list($response) = $this->getPageLinkAnnotationByIndexWithHttpInfo($name, $page_number, $link_index, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageLinkAnnotationByIndexWithHttpInfo
     *
     * Read document page link annotation by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLinkAnnotationByIndexWithHttpInfo($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getPageLinkAnnotationByIndexRequest($name, $page_number, $link_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLinkAnnotationByIndexAsync
     *
     * Read document page link annotation by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationByIndexAsync($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        return $this->getPageLinkAnnotationByIndexAsyncWithHttpInfo($name, $page_number, $link_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLinkAnnotationByIndexAsyncWithHttpInfo
     *
     * Read document page link annotation by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationByIndexAsyncWithHttpInfo($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getPageLinkAnnotationByIndexRequest($name, $page_number, $link_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLinkAnnotationByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLinkAnnotationByIndexRequest($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLinkAnnotationByIndex'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLinkAnnotationByIndex'
            );
        }
        // verify the required parameter 'link_index' is set
        if ($link_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_index when calling getPageLinkAnnotationByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links/{linkIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($link_index !== null) {
            $resourcePath = str_replace(
                '{' . 'linkIndex' . '}',
                ObjectSerializer::toPathValue($link_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLinkAnnotations
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationsResponse
     */
    public function getPageLinkAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        list($response) = $this->getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageLinkAnnotationsWithHttpInfo
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationsResponse';
        $request = $this->getPageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLinkAnnotationsAsync
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLinkAnnotationsAsyncWithHttpInfo
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationsResponse';
        $request = $this->getPageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLinkAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLinkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageText
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x x (required)
     * @param  int $y y (required)
     * @param  int $width width (required)
     * @param  int $height height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextRectsResponse
     */
    public function getPageText($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        list($response) = $this->getPageTextWithHttpInfo($name, $page_number, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);
        return $response;
    }

    /**
     * Operation getPageTextWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextRectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageTextWithHttpInfo($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getPageTextRequest($name, $page_number, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextRectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageTextAsync
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAsync($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        return $this->getPageTextAsyncWithHttpInfo($name, $page_number, $x, $y, $width, $height, $format, $regex, $split_rects, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageTextAsyncWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAsyncWithHttpInfo($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getPageTextRequest($name, $page_number, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageText'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageTextRequest($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageText'
            );
        }
        // verify the required parameter 'x' is set
        if ($x === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x when calling getPageText'
            );
        }
        // verify the required parameter 'y' is set
        if ($y === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $y when calling getPageText'
            );
        }
        // verify the required parameter 'width' is set
        if ($width === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $width when calling getPageText'
            );
        }
        // verify the required parameter 'height' is set
        if ($height === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $height when calling getPageText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($format)) {
            $format = ObjectSerializer::serializeCollection($format, 'multi', true);
        }
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($regex !== null) {
            $queryParams['regex'] = ObjectSerializer::toQueryValue($regex);
        }
        // query params
        if ($x !== null) {
            $queryParams['X'] = ObjectSerializer::toQueryValue($x);
        }
        // query params
        if ($y !== null) {
            $queryParams['Y'] = ObjectSerializer::toQueryValue($y);
        }
        // query params
        if ($width !== null) {
            $queryParams['Width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['Height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($split_rects !== null) {
            $queryParams['splitRects'] = ObjectSerializer::toQueryValue($split_rects);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageTextItems
     *
     * Read page text items.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getPageTextItems($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getPageTextItemsWithHttpInfo($name, $page_number, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageTextItemsWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageTextItemsWithHttpInfo($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getPageTextItemsRequest($name, $page_number, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageTextItemsAsync
     *
     * Read page text items.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextItemsAsync($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getPageTextItemsAsyncWithHttpInfo($name, $page_number, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageTextItemsAsyncWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextItemsAsyncWithHttpInfo($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getPageTextItemsRequest($name, $page_number, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageTextItems'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageTextItemsRequest($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageTextItems'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageTextItems'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/textItems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPages
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPagesResponse
     */
    public function getPages($name, $storage = null, $folder = null)
    {
        list($response) = $this->getPagesWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPagesWithHttpInfo
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->getPagesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagesAsync
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesAsync($name, $storage = null, $folder = null)
    {
        return $this->getPagesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagesAsyncWithHttpInfo
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->getPagesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPages'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPages'
            );
        }

        $resourcePath = '/pdf/{name}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPclInStorageToPdf
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPclInStorageToPdf($src_path)
    {
        list($response) = $this->getPclInStorageToPdfWithHttpInfo($src_path);
        return $response;
    }

    /**
     * Operation getPclInStorageToPdfWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPclInStorageToPdfWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPclInStorageToPdfRequest($src_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPclInStorageToPdfAsync
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPclInStorageToPdfAsync($src_path)
    {
        return $this->getPclInStorageToPdfAsyncWithHttpInfo($src_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPclInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPclInStorageToPdfAsyncWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPclInStorageToPdfRequest($src_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPclInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPclInStorageToPdfRequest($src_path)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getPclInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/pcl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToDoc
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToDoc($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToDocWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToDocRequest($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToDocAsync
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToDocAsync($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        return $this->getPdfInStorageToDocAsyncWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToDocAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToDocAsyncWithHttpInfo($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToDocRequest($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToDoc'
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToDocRequest($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToDoc'
            );
        }

        $resourcePath = '/pdf/{name}/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToEpub
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToEpub($name, $content_recognition_mode = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToEpubWithHttpInfo($name, $content_recognition_mode, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToEpubWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToEpubWithHttpInfo($name, $content_recognition_mode = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToEpubRequest($name, $content_recognition_mode, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToEpubAsync
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToEpubAsync($name, $content_recognition_mode = null, $folder = null)
    {
        return $this->getPdfInStorageToEpubAsyncWithHttpInfo($name, $content_recognition_mode, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToEpubAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToEpubAsyncWithHttpInfo($name, $content_recognition_mode = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToEpubRequest($name, $content_recognition_mode, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToEpub'
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToEpubRequest($name, $content_recognition_mode = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToEpub'
            );
        }

        $resourcePath = '/pdf/{name}/convert/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($content_recognition_mode !== null) {
            $queryParams['contentRecognitionMode'] = ObjectSerializer::toQueryValue($content_recognition_mode);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToHtml
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToHtml($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToHtmlWithHttpInfo($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToHtmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToHtmlWithHttpInfo($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToHtmlRequest($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToHtmlAsync
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToHtmlAsync($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        return $this->getPdfInStorageToHtmlAsyncWithHttpInfo($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToHtmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToHtmlAsyncWithHttpInfo($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToHtmlRequest($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToHtml'
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToHtmlRequest($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToHtml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($additional_margin_width_in_points !== null) {
            $queryParams['additionalMarginWidthInPoints'] = ObjectSerializer::toQueryValue($additional_margin_width_in_points);
        }
        // query params
        if ($compress_svg_graphics_if_any !== null) {
            $queryParams['compressSvgGraphicsIfAny'] = ObjectSerializer::toQueryValue($compress_svg_graphics_if_any);
        }
        // query params
        if ($convert_marked_content_to_layers !== null) {
            $queryParams['convertMarkedContentToLayers'] = ObjectSerializer::toQueryValue($convert_marked_content_to_layers);
        }
        // query params
        if ($default_font_name !== null) {
            $queryParams['defaultFontName'] = ObjectSerializer::toQueryValue($default_font_name);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($fixed_layout !== null) {
            $queryParams['fixedLayout'] = ObjectSerializer::toQueryValue($fixed_layout);
        }
        // query params
        if ($image_resolution !== null) {
            $queryParams['imageResolution'] = ObjectSerializer::toQueryValue($image_resolution);
        }
        // query params
        if ($minimal_line_width !== null) {
            $queryParams['minimalLineWidth'] = ObjectSerializer::toQueryValue($minimal_line_width);
        }
        // query params
        if ($prevent_glyphs_grouping !== null) {
            $queryParams['preventGlyphsGrouping'] = ObjectSerializer::toQueryValue($prevent_glyphs_grouping);
        }
        // query params
        if ($split_css_into_pages !== null) {
            $queryParams['splitCssIntoPages'] = ObjectSerializer::toQueryValue($split_css_into_pages);
        }
        // query params
        if ($split_into_pages !== null) {
            $queryParams['splitIntoPages'] = ObjectSerializer::toQueryValue($split_into_pages);
        }
        // query params
        if ($use_z_order !== null) {
            $queryParams['useZOrder'] = ObjectSerializer::toQueryValue($use_z_order);
        }
        // query params
        if ($antialiasing_processing !== null) {
            $queryParams['antialiasingProcessing'] = ObjectSerializer::toQueryValue($antialiasing_processing);
        }
        // query params
        if ($css_class_names_prefix !== null) {
            $queryParams['cssClassNamesPrefix'] = ObjectSerializer::toQueryValue($css_class_names_prefix);
        }
        // query params
        if (is_array($explicit_list_of_saved_pages)) {
            $explicit_list_of_saved_pages = ObjectSerializer::serializeCollection($explicit_list_of_saved_pages, 'multi', true);
        }
        if ($explicit_list_of_saved_pages !== null) {
            $queryParams['explicitListOfSavedPages'] = ObjectSerializer::toQueryValue($explicit_list_of_saved_pages);
        }
        // query params
        if ($font_encoding_strategy !== null) {
            $queryParams['fontEncodingStrategy'] = ObjectSerializer::toQueryValue($font_encoding_strategy);
        }
        // query params
        if ($font_saving_mode !== null) {
            $queryParams['fontSavingMode'] = ObjectSerializer::toQueryValue($font_saving_mode);
        }
        // query params
        if ($html_markup_generation_mode !== null) {
            $queryParams['htmlMarkupGenerationMode'] = ObjectSerializer::toQueryValue($html_markup_generation_mode);
        }
        // query params
        if ($letters_positioning_method !== null) {
            $queryParams['lettersPositioningMethod'] = ObjectSerializer::toQueryValue($letters_positioning_method);
        }
        // query params
        if ($pages_flow_type_depends_on_viewers_screen_size !== null) {
            $queryParams['pagesFlowTypeDependsOnViewersScreenSize'] = ObjectSerializer::toQueryValue($pages_flow_type_depends_on_viewers_screen_size);
        }
        // query params
        if ($parts_embedding_mode !== null) {
            $queryParams['partsEmbeddingMode'] = ObjectSerializer::toQueryValue($parts_embedding_mode);
        }
        // query params
        if ($raster_images_saving_mode !== null) {
            $queryParams['rasterImagesSavingMode'] = ObjectSerializer::toQueryValue($raster_images_saving_mode);
        }
        // query params
        if ($remove_empty_areas_on_top_and_bottom !== null) {
            $queryParams['removeEmptyAreasOnTopAndBottom'] = ObjectSerializer::toQueryValue($remove_empty_areas_on_top_and_bottom);
        }
        // query params
        if ($save_shadowed_texts_as_transparent_texts !== null) {
            $queryParams['saveShadowedTextsAsTransparentTexts'] = ObjectSerializer::toQueryValue($save_shadowed_texts_as_transparent_texts);
        }
        // query params
        if ($save_transparent_texts !== null) {
            $queryParams['saveTransparentTexts'] = ObjectSerializer::toQueryValue($save_transparent_texts);
        }
        // query params
        if ($special_folder_for_all_images !== null) {
            $queryParams['specialFolderForAllImages'] = ObjectSerializer::toQueryValue($special_folder_for_all_images);
        }
        // query params
        if ($special_folder_for_svg_images !== null) {
            $queryParams['specialFolderForSvgImages'] = ObjectSerializer::toQueryValue($special_folder_for_svg_images);
        }
        // query params
        if ($try_save_text_underlining_and_strikeouting_in_css !== null) {
            $queryParams['trySaveTextUnderliningAndStrikeoutingInCss'] = ObjectSerializer::toQueryValue($try_save_text_underlining_and_strikeouting_in_css);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToLaTeX
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToLaTeX($name, $pages_count = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToLaTeXWithHttpInfo($name, $pages_count, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToLaTeXWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToLaTeXWithHttpInfo($name, $pages_count = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToLaTeXRequest($name, $pages_count, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToLaTeXAsync
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToLaTeXAsync($name, $pages_count = null, $folder = null)
    {
        return $this->getPdfInStorageToLaTeXAsyncWithHttpInfo($name, $pages_count, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToLaTeXAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToLaTeXAsyncWithHttpInfo($name, $pages_count = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToLaTeXRequest($name, $pages_count, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToLaTeX'
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToLaTeXRequest($name, $pages_count = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToLaTeX'
            );
        }

        $resourcePath = '/pdf/{name}/convert/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pages_count !== null) {
            $queryParams['pagesCount'] = ObjectSerializer::toQueryValue($pages_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToMobiXml
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToMobiXml($name, $folder = null)
    {
        list($response) = $this->getPdfInStorageToMobiXmlWithHttpInfo($name, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToMobiXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToMobiXmlWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToMobiXmlRequest($name, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToMobiXmlAsync
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToMobiXmlAsync($name, $folder = null)
    {
        return $this->getPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToMobiXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToMobiXmlRequest($name, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToMobiXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToMobiXmlRequest($name, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToMobiXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/mobixml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToPdfA
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToPdfA($name, $type, $folder = null)
    {
        list($response) = $this->getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToPdfAWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPdfARequest($name, $type, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToPdfAAsync
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPdfAAsync($name, $type, $folder = null)
    {
        return $this->getPdfInStorageToPdfAAsyncWithHttpInfo($name, $type, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPdfAAsyncWithHttpInfo($name, $type, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPdfARequest($name, $type, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToPdfA'
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToPdfARequest($name, $type, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getPdfInStorageToPdfA'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToPptx
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToPptx($name, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToPptxWithHttpInfo($name, $separate_images, $slides_as_images, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToPptxWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToPptxWithHttpInfo($name, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPptxRequest($name, $separate_images, $slides_as_images, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToPptxAsync
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPptxAsync($name, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        return $this->getPdfInStorageToPptxAsyncWithHttpInfo($name, $separate_images, $slides_as_images, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToPptxAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPptxAsyncWithHttpInfo($name, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPptxRequest($name, $separate_images, $slides_as_images, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToPptx'
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToPptxRequest($name, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToPptx'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pptx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($separate_images !== null) {
            $queryParams['separateImages'] = ObjectSerializer::toQueryValue($separate_images);
        }
        // query params
        if ($slides_as_images !== null) {
            $queryParams['slidesAsImages'] = ObjectSerializer::toQueryValue($slides_as_images);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToSvg
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToSvg($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToSvgWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToSvgAsync
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToSvgAsync($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        return $this->getPdfInStorageToSvgAsyncWithHttpInfo($name, $compress_output_to_zip_archive, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToSvgAsyncWithHttpInfo($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToSvg'
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToSvg'
            );
        }

        $resourcePath = '/pdf/{name}/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($compress_output_to_zip_archive !== null) {
            $queryParams['compressOutputToZipArchive'] = ObjectSerializer::toQueryValue($compress_output_to_zip_archive);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToTiff
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToTiff($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToTiffWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToTiffWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToTiffWithHttpInfo($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToTiffRequest($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToTiffAsync
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToTiffAsync($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        return $this->getPdfInStorageToTiffAsyncWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToTiffAsyncWithHttpInfo($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToTiffRequest($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToTiffRequest($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXls
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXls($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToXlsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXlsAsync
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsAsync($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        return $this->getPdfInStorageToXlsAsyncWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsAsyncWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXls'
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXls'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXml
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXml($name, $folder = null)
    {
        list($response) = $this->getPdfInStorageToXmlWithHttpInfo($name, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXmlWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXmlRequest($name, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXmlAsync
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXmlAsync($name, $folder = null)
    {
        return $this->getPdfInStorageToXmlAsyncWithHttpInfo($name, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXmlAsyncWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXmlRequest($name, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXmlRequest($name, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXps
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXps($name, $folder = null)
    {
        list($response) = $this->getPdfInStorageToXpsWithHttpInfo($name, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToXpsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXpsWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXpsRequest($name, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXpsAsync
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXpsAsync($name, $folder = null)
    {
        return $this->getPdfInStorageToXpsAsyncWithHttpInfo($name, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXpsAsyncWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXpsRequest($name, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXps'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXpsRequest($name, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXps'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPsInStorageToPdf
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPsInStorageToPdf($src_path)
    {
        list($response) = $this->getPsInStorageToPdfWithHttpInfo($src_path);
        return $response;
    }

    /**
     * Operation getPsInStorageToPdfWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPsInStorageToPdfWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPsInStorageToPdfRequest($src_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPsInStorageToPdfAsync
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPsInStorageToPdfAsync($src_path)
    {
        return $this->getPsInStorageToPdfAsyncWithHttpInfo($src_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPsInStorageToPdfAsyncWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPsInStorageToPdfRequest($src_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPsInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPsInStorageToPdfRequest($src_path)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getPsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/ps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSegment
     *
     * Read segment.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  int $segment_number segment_number (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemResponse
     */
    public function getSegment($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        list($response) = $this->getSegmentWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getSegmentWithHttpInfo
     *
     * Read segment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSegmentWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemResponse';
        $request = $this->getSegmentRequest($name, $page_number, $fragment_number, $segment_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSegmentAsync
     *
     * Read segment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentAsync($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        return $this->getSegmentAsyncWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSegmentAsyncWithHttpInfo
     *
     * Read segment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentAsyncWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemResponse';
        $request = $this->getSegmentRequest($name, $page_number, $fragment_number, $segment_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSegment'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSegmentRequest($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSegment'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getSegment'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getSegment'
            );
        }
        // verify the required parameter 'segment_number' is set
        if ($segment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_number when calling getSegment'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/segments/{segmentNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }
        // path params
        if ($segment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentNumber' . '}',
                ObjectSerializer::toPathValue($segment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSegmentTextFormat
     *
     * Read segment text format.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  int $segment_number segment_number (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextFormatResponse
     */
    public function getSegmentTextFormat($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        list($response) = $this->getSegmentTextFormatWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getSegmentTextFormatWithHttpInfo
     *
     * Read segment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSegmentTextFormatWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextFormatResponse';
        $request = $this->getSegmentTextFormatRequest($name, $page_number, $fragment_number, $segment_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextFormatResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSegmentTextFormatAsync
     *
     * Read segment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentTextFormatAsync($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        return $this->getSegmentTextFormatAsyncWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSegmentTextFormatAsyncWithHttpInfo
     *
     * Read segment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentTextFormatAsyncWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextFormatResponse';
        $request = $this->getSegmentTextFormatRequest($name, $page_number, $fragment_number, $segment_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSegmentTextFormat'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSegmentTextFormatRequest($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSegmentTextFormat'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getSegmentTextFormat'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getSegmentTextFormat'
            );
        }
        // verify the required parameter 'segment_number' is set
        if ($segment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_number when calling getSegmentTextFormat'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/segments/{segmentNumber}/textformat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }
        // path params
        if ($segment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentNumber' . '}',
                ObjectSerializer::toPathValue($segment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSegments
     *
     * Read fragment segments.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getSegments($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getSegmentsWithHttpInfo($name, $page_number, $fragment_number, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getSegmentsWithHttpInfo
     *
     * Read fragment segments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSegmentsWithHttpInfo($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getSegmentsRequest($name, $page_number, $fragment_number, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSegmentsAsync
     *
     * Read fragment segments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentsAsync($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getSegmentsAsyncWithHttpInfo($name, $page_number, $fragment_number, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSegmentsAsyncWithHttpInfo
     *
     * Read fragment segments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentsAsyncWithHttpInfo($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getSegmentsRequest($name, $page_number, $fragment_number, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSegments'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSegmentsRequest($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSegments'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getSegments'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getSegments'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/segments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSvgInStorageToPdf
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getSvgInStorageToPdf($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        list($response) = $this->getSvgInStorageToPdfWithHttpInfo($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top);
        return $response;
    }

    /**
     * Operation getSvgInStorageToPdfWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSvgInStorageToPdfWithHttpInfo($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getSvgInStorageToPdfRequest($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSvgInStorageToPdfAsync
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSvgInStorageToPdfAsync($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        return $this->getSvgInStorageToPdfAsyncWithHttpInfo($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSvgInStorageToPdfAsyncWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSvgInStorageToPdfAsyncWithHttpInfo($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getSvgInStorageToPdfRequest($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSvgInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSvgInStorageToPdfRequest($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getSvgInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($adjust_page_size !== null) {
            $queryParams['adjustPageSize'] = ObjectSerializer::toQueryValue($adjust_page_size);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getText
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  int $x x (required)
     * @param  int $y y (required)
     * @param  int $width width (required)
     * @param  int $height height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextRectsResponse
     */
    public function getText($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        list($response) = $this->getTextWithHttpInfo($name, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);
        return $response;
    }

    /**
     * Operation getTextWithHttpInfo
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextRectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTextWithHttpInfo($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getTextRequest($name, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextRectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTextAsync
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAsync($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        return $this->getTextAsyncWithHttpInfo($name, $x, $y, $width, $height, $format, $regex, $split_rects, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTextAsyncWithHttpInfo
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAsyncWithHttpInfo($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getTextRequest($name, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getText'
     *
     * @param  string $name The document name. (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTextRequest($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getText'
            );
        }
        // verify the required parameter 'x' is set
        if ($x === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x when calling getText'
            );
        }
        // verify the required parameter 'y' is set
        if ($y === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $y when calling getText'
            );
        }
        // verify the required parameter 'width' is set
        if ($width === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $width when calling getText'
            );
        }
        // verify the required parameter 'height' is set
        if ($height === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $height when calling getText'
            );
        }

        $resourcePath = '/pdf/{name}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($format)) {
            $format = ObjectSerializer::serializeCollection($format, 'multi', true);
        }
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($regex !== null) {
            $queryParams['regex'] = ObjectSerializer::toQueryValue($regex);
        }
        // query params
        if ($x !== null) {
            $queryParams['X'] = ObjectSerializer::toQueryValue($x);
        }
        // query params
        if ($y !== null) {
            $queryParams['Y'] = ObjectSerializer::toQueryValue($y);
        }
        // query params
        if ($width !== null) {
            $queryParams['Width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['Height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($split_rects !== null) {
            $queryParams['splitRects'] = ObjectSerializer::toQueryValue($split_rects);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTextItems
     *
     * Read document text items.
     *
     * @param  string $name name (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getTextItems($name, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getTextItemsWithHttpInfo($name, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getTextItemsWithHttpInfo
     *
     * Read document text items.
     *
     * @param  string $name (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTextItemsWithHttpInfo($name, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getTextItemsRequest($name, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTextItemsAsync
     *
     * Read document text items.
     *
     * @param  string $name (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextItemsAsync($name, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getTextItemsAsyncWithHttpInfo($name, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTextItemsAsyncWithHttpInfo
     *
     * Read document text items.
     *
     * @param  string $name (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextItemsAsyncWithHttpInfo($name, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getTextItemsRequest($name, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTextItems'
     *
     * @param  string $name (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTextItemsRequest($name, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getTextItems'
            );
        }

        $resourcePath = '/pdf/{name}/textItems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVerifySignature
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SignatureVerifyResponse
     */
    public function getVerifySignature($name, $sign_name, $folder = null)
    {
        list($response) = $this->getVerifySignatureWithHttpInfo($name, $sign_name, $folder);
        return $response;
    }

    /**
     * Operation getVerifySignatureWithHttpInfo
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SignatureVerifyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVerifySignatureWithHttpInfo($name, $sign_name, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SignatureVerifyResponse';
        $request = $this->getVerifySignatureRequest($name, $sign_name, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SignatureVerifyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVerifySignatureAsync
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVerifySignatureAsync($name, $sign_name, $folder = null)
    {
        return $this->getVerifySignatureAsyncWithHttpInfo($name, $sign_name, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVerifySignatureAsyncWithHttpInfo
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVerifySignatureAsyncWithHttpInfo($name, $sign_name, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SignatureVerifyResponse';
        $request = $this->getVerifySignatureRequest($name, $sign_name, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVerifySignature'
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVerifySignatureRequest($name, $sign_name, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getVerifySignature'
            );
        }
        // verify the required parameter 'sign_name' is set
        if ($sign_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sign_name when calling getVerifySignature'
            );
        }

        $resourcePath = '/pdf/{name}/verifySignature';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sign_name !== null) {
            $queryParams['signName'] = ObjectSerializer::toQueryValue($sign_name);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebInStorageToPdf
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getWebInStorageToPdf($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        list($response) = $this->getWebInStorageToPdfWithHttpInfo($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top);
        return $response;
    }

    /**
     * Operation getWebInStorageToPdfWithHttpInfo
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebInStorageToPdfWithHttpInfo($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getWebInStorageToPdfRequest($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebInStorageToPdfAsync
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebInStorageToPdfAsync($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        return $this->getWebInStorageToPdfAsyncWithHttpInfo($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebInStorageToPdfAsyncWithHttpInfo
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebInStorageToPdfAsyncWithHttpInfo($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getWebInStorageToPdfRequest($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebInStorageToPdf'
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebInStorageToPdfRequest($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null)
    {
        // verify the required parameter 'url' is set
        if ($url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling getWebInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/web';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWordsPerPage
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\WordCountResponse
     */
    public function getWordsPerPage($name, $storage = null, $folder = null)
    {
        list($response) = $this->getWordsPerPageWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getWordsPerPageWithHttpInfo
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\WordCountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWordsPerPageWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\WordCountResponse';
        $request = $this->getWordsPerPageRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\WordCountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWordsPerPageAsync
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWordsPerPageAsync($name, $storage = null, $folder = null)
    {
        return $this->getWordsPerPageAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWordsPerPageAsyncWithHttpInfo
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWordsPerPageAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\WordCountResponse';
        $request = $this->getWordsPerPageRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWordsPerPage'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWordsPerPageRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getWordsPerPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/wordCount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXfaPdfInStorageToAcroForm
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXfaPdfInStorageToAcroForm($name, $folder = null)
    {
        list($response) = $this->getXfaPdfInStorageToAcroFormWithHttpInfo($name, $folder);
        return $response;
    }

    /**
     * Operation getXfaPdfInStorageToAcroFormWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXfaPdfInStorageToAcroFormWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXfaPdfInStorageToAcroFormRequest($name, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXfaPdfInStorageToAcroFormAsync
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXfaPdfInStorageToAcroFormAsync($name, $folder = null)
    {
        return $this->getXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXfaPdfInStorageToAcroFormAsyncWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXfaPdfInStorageToAcroFormRequest($name, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXfaPdfInStorageToAcroForm'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXfaPdfInStorageToAcroFormRequest($name, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getXfaPdfInStorageToAcroForm'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xfatoacroform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXmlInStorageToPdf
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXmlInStorageToPdf($src_path, $xsl_file_path = null)
    {
        list($response) = $this->getXmlInStorageToPdfWithHttpInfo($src_path, $xsl_file_path);
        return $response;
    }

    /**
     * Operation getXmlInStorageToPdfWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXmlInStorageToPdfWithHttpInfo($src_path, $xsl_file_path = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXmlInStorageToPdfRequest($src_path, $xsl_file_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXmlInStorageToPdfAsync
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXmlInStorageToPdfAsync($src_path, $xsl_file_path = null)
    {
        return $this->getXmlInStorageToPdfAsyncWithHttpInfo($src_path, $xsl_file_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXmlInStorageToPdfAsyncWithHttpInfo($src_path, $xsl_file_path = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXmlInStorageToPdfRequest($src_path, $xsl_file_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXmlInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXmlInStorageToPdfRequest($src_path, $xsl_file_path = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getXmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($xsl_file_path !== null) {
            $queryParams['xslFilePath'] = ObjectSerializer::toQueryValue($xsl_file_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXpsInStorageToPdf
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXpsInStorageToPdf($src_path)
    {
        list($response) = $this->getXpsInStorageToPdfWithHttpInfo($src_path);
        return $response;
    }

    /**
     * Operation getXpsInStorageToPdfWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXpsInStorageToPdfWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXpsInStorageToPdfRequest($src_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXpsInStorageToPdfAsync
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXpsInStorageToPdfAsync($src_path)
    {
        return $this->getXpsInStorageToPdfAsyncWithHttpInfo($src_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXpsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXpsInStorageToPdfAsyncWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXpsInStorageToPdfRequest($src_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXpsInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXpsInStorageToPdfRequest($src_path)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getXpsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXslFoInStorageToPdf
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXslFoInStorageToPdf($src_path)
    {
        list($response) = $this->getXslFoInStorageToPdfWithHttpInfo($src_path);
        return $response;
    }

    /**
     * Operation getXslFoInStorageToPdfWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXslFoInStorageToPdfWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXslFoInStorageToPdfRequest($src_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXslFoInStorageToPdfAsync
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXslFoInStorageToPdfAsync($src_path)
    {
        return $this->getXslFoInStorageToPdfAsyncWithHttpInfo($src_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXslFoInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXslFoInStorageToPdfAsyncWithHttpInfo($src_path)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXslFoInStorageToPdfRequest($src_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXslFoInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXslFoInStorageToPdfRequest($src_path)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getXslFoInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/xslfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAppendDocument
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function postAppendDocument($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        list($response) = $this->postAppendDocumentWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);
        return $response;
    }

    /**
     * Operation postAppendDocumentWithHttpInfo
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAppendDocumentWithHttpInfo($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->postAppendDocumentRequest($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAppendDocumentAsync
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAppendDocumentAsync($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        return $this->postAppendDocumentAsyncWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAppendDocumentAsyncWithHttpInfo
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAppendDocumentAsyncWithHttpInfo($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->postAppendDocumentRequest($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAppendDocument'
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAppendDocumentRequest($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postAppendDocument'
            );
        }

        $resourcePath = '/pdf/{name}/appendDocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($append_file !== null) {
            $queryParams['appendFile'] = ObjectSerializer::toQueryValue($append_file);
        }
        // query params
        if ($start_page !== null) {
            $queryParams['startPage'] = ObjectSerializer::toQueryValue($start_page);
        }
        // query params
        if ($end_page !== null) {
            $queryParams['endPage'] = ObjectSerializer::toQueryValue($end_page);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($append_document)) {
            $_tempBody = $append_document;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCreateField
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postCreateField($name, $page, $field = null, $storage = null, $folder = null)
    {
        list($response) = $this->postCreateFieldWithHttpInfo($name, $page, $field, $storage, $folder);
        return $response;
    }

    /**
     * Operation postCreateFieldWithHttpInfo
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCreateFieldWithHttpInfo($name, $page, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postCreateFieldRequest($name, $page, $field, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCreateFieldAsync
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCreateFieldAsync($name, $page, $field = null, $storage = null, $folder = null)
    {
        return $this->postCreateFieldAsyncWithHttpInfo($name, $page, $field, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCreateFieldAsyncWithHttpInfo
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCreateFieldAsyncWithHttpInfo($name, $page, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postCreateFieldRequest($name, $page, $field, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCreateField'
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postCreateFieldRequest($name, $page, $field = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postCreateField'
            );
        }
        // verify the required parameter 'page' is set
        if ($page === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling postCreateField'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($field)) {
            $_tempBody = $field;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentReplaceText
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace text_replace (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentTextReplaceResponse
     */
    public function postDocumentReplaceText($name, $text_replace, $storage = null, $folder = null)
    {
        list($response) = $this->postDocumentReplaceTextWithHttpInfo($name, $text_replace, $storage, $folder);
        return $response;
    }

    /**
     * Operation postDocumentReplaceTextWithHttpInfo
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentTextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentReplaceTextWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentTextReplaceResponse';
        $request = $this->postDocumentReplaceTextRequest($name, $text_replace, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentTextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentReplaceTextAsync
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentReplaceTextAsync($name, $text_replace, $storage = null, $folder = null)
    {
        return $this->postDocumentReplaceTextAsyncWithHttpInfo($name, $text_replace, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentReplaceTextAsyncWithHttpInfo
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentReplaceTextAsyncWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentTextReplaceResponse';
        $request = $this->postDocumentReplaceTextRequest($name, $text_replace, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentReplaceText'
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentReplaceTextRequest($name, $text_replace, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentReplaceText'
            );
        }
        // verify the required parameter 'text_replace' is set
        if ($text_replace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace when calling postDocumentReplaceText'
            );
        }

        $resourcePath = '/pdf/{name}/replaceText';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace)) {
            $_tempBody = $text_replace;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentReplaceTextList
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request text_replace_list_request (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentTextReplaceResponse
     */
    public function postDocumentReplaceTextList($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        list($response) = $this->postDocumentReplaceTextListWithHttpInfo($name, $text_replace_list_request, $storage, $folder);
        return $response;
    }

    /**
     * Operation postDocumentReplaceTextListWithHttpInfo
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentTextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentReplaceTextListWithHttpInfo($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentTextReplaceResponse';
        $request = $this->postDocumentReplaceTextListRequest($name, $text_replace_list_request, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentTextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentReplaceTextListAsync
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentReplaceTextListAsync($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        return $this->postDocumentReplaceTextListAsyncWithHttpInfo($name, $text_replace_list_request, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentReplaceTextListAsyncWithHttpInfo
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentReplaceTextListAsyncWithHttpInfo($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentTextReplaceResponse';
        $request = $this->postDocumentReplaceTextListRequest($name, $text_replace_list_request, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentReplaceTextList'
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentReplaceTextListRequest($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentReplaceTextList'
            );
        }
        // verify the required parameter 'text_replace_list_request' is set
        if ($text_replace_list_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace_list_request when calling postDocumentReplaceTextList'
            );
        }

        $resourcePath = '/pdf/{name}/replaceTextList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace_list_request)) {
            $_tempBody = $text_replace_list_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentTextReplace
     *
     * Document's replace text method.
     *
     * @param  string $name name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace text_replace (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextReplaceResponse
     */
    public function postDocumentTextReplace($name, $text_replace, $storage = null, $folder = null)
    {
        list($response) = $this->postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage, $folder);
        return $response;
    }

    /**
     * Operation postDocumentTextReplaceWithHttpInfo
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postDocumentTextReplaceRequest($name, $text_replace, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentTextReplaceAsync
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextReplaceAsync($name, $text_replace, $storage = null, $folder = null)
    {
        return $this->postDocumentTextReplaceAsyncWithHttpInfo($name, $text_replace, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentTextReplaceAsyncWithHttpInfo
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextReplaceAsyncWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postDocumentTextReplaceRequest($name, $text_replace, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentTextReplace'
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentTextReplaceRequest($name, $text_replace, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentTextReplace'
            );
        }
        // verify the required parameter 'text_replace' is set
        if ($text_replace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace when calling postDocumentTextReplace'
            );
        }

        $resourcePath = '/pdf/{name}/text/replace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace)) {
            $_tempBody = $text_replace;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postMovePage
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postMovePage($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        list($response) = $this->postMovePageWithHttpInfo($name, $page_number, $new_index, $storage, $folder);
        return $response;
    }

    /**
     * Operation postMovePageWithHttpInfo
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMovePageWithHttpInfo($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postMovePageRequest($name, $page_number, $new_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postMovePageAsync
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMovePageAsync($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        return $this->postMovePageAsyncWithHttpInfo($name, $page_number, $new_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postMovePageAsyncWithHttpInfo
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMovePageAsyncWithHttpInfo($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postMovePageRequest($name, $page_number, $new_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postMovePage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postMovePageRequest($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postMovePage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postMovePage'
            );
        }
        // verify the required parameter 'new_index' is set
        if ($new_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_index when calling postMovePage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/movePage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_index !== null) {
            $queryParams['newIndex'] = ObjectSerializer::toQueryValue($new_index);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postOptimizeDocument
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postOptimizeDocument($name, $options = null, $storage = null, $folder = null)
    {
        list($response) = $this->postOptimizeDocumentWithHttpInfo($name, $options, $storage, $folder);
        return $response;
    }

    /**
     * Operation postOptimizeDocumentWithHttpInfo
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postOptimizeDocumentWithHttpInfo($name, $options = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postOptimizeDocumentRequest($name, $options, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postOptimizeDocumentAsync
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOptimizeDocumentAsync($name, $options = null, $storage = null, $folder = null)
    {
        return $this->postOptimizeDocumentAsyncWithHttpInfo($name, $options, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postOptimizeDocumentAsyncWithHttpInfo
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOptimizeDocumentAsyncWithHttpInfo($name, $options = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postOptimizeDocumentRequest($name, $options, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postOptimizeDocument'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postOptimizeDocumentRequest($name, $options = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postOptimizeDocument'
            );
        }

        $resourcePath = '/pdf/{name}/optimize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($options)) {
            $_tempBody = $options;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageReplaceText
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace text_replace (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PageTextReplaceResponse
     */
    public function postPageReplaceText($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        list($response) = $this->postPageReplaceTextWithHttpInfo($name, $page_number, $text_replace, $storage, $folder);
        return $response;
    }

    /**
     * Operation postPageReplaceTextWithHttpInfo
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PageTextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageReplaceTextWithHttpInfo($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PageTextReplaceResponse';
        $request = $this->postPageReplaceTextRequest($name, $page_number, $text_replace, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PageTextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageReplaceTextAsync
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageReplaceTextAsync($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        return $this->postPageReplaceTextAsyncWithHttpInfo($name, $page_number, $text_replace, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageReplaceTextAsyncWithHttpInfo
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageReplaceTextAsyncWithHttpInfo($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PageTextReplaceResponse';
        $request = $this->postPageReplaceTextRequest($name, $page_number, $text_replace, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageReplaceText'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageReplaceTextRequest($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageReplaceText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageReplaceText'
            );
        }
        // verify the required parameter 'text_replace' is set
        if ($text_replace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace when calling postPageReplaceText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/replaceText';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace)) {
            $_tempBody = $text_replace;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageReplaceTextList
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request text_replace_list_request (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PageTextReplaceResponse
     */
    public function postPageReplaceTextList($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        list($response) = $this->postPageReplaceTextListWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder);
        return $response;
    }

    /**
     * Operation postPageReplaceTextListWithHttpInfo
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PageTextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageReplaceTextListWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PageTextReplaceResponse';
        $request = $this->postPageReplaceTextListRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PageTextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageReplaceTextListAsync
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageReplaceTextListAsync($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        return $this->postPageReplaceTextListAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageReplaceTextListAsyncWithHttpInfo
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageReplaceTextListAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PageTextReplaceResponse';
        $request = $this->postPageReplaceTextListRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageReplaceTextList'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageReplaceTextListRequest($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageReplaceTextList'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageReplaceTextList'
            );
        }
        // verify the required parameter 'text_replace_list_request' is set
        if ($text_replace_list_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace_list_request when calling postPageReplaceTextList'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/replaceTextList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace_list_request)) {
            $_tempBody = $text_replace_list_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageTextReplace
     *
     * Page's replace text method.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request text_replace_list_request (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextReplaceResponse
     */
    public function postPageTextReplace($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        list($response) = $this->postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder);
        return $response;
    }

    /**
     * Operation postPageTextReplaceWithHttpInfo
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageTextReplaceAsync
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextReplaceAsync($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        return $this->postPageTextReplaceAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageTextReplaceAsyncWithHttpInfo
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextReplaceAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageTextReplace'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageTextReplace'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageTextReplace'
            );
        }
        // verify the required parameter 'text_replace_list_request' is set
        if ($text_replace_list_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace_list_request when calling postPageTextReplace'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text/replace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace_list_request)) {
            $_tempBody = $text_replace_list_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postReplaceImage
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImageResponse
     */
    public function postReplaceImage($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        list($response) = $this->postReplaceImageWithHttpInfo($name, $page_number, $image_number, $image_file, $storage, $folder, $image);
        return $response;
    }

    /**
     * Operation postReplaceImageWithHttpInfo
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postReplaceImageWithHttpInfo($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->postReplaceImageRequest($name, $page_number, $image_number, $image_file, $storage, $folder, $image);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postReplaceImageAsync
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postReplaceImageAsync($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        return $this->postReplaceImageAsyncWithHttpInfo($name, $page_number, $image_number, $image_file, $storage, $folder, $image)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postReplaceImageAsyncWithHttpInfo
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postReplaceImageAsyncWithHttpInfo($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->postReplaceImageRequest($name, $page_number, $image_number, $image_file, $storage, $folder, $image);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postReplaceImage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postReplaceImageRequest($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postReplaceImage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postReplaceImage'
            );
        }
        // verify the required parameter 'image_number' is set
        if ($image_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_number when calling postReplaceImage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/{imageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_file !== null) {
            $queryParams['imageFile'] = ObjectSerializer::toQueryValue($image_file);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($image_number !== null) {
            $resourcePath = str_replace(
                '{' . 'imageNumber' . '}',
                ObjectSerializer::toPathValue($image_number),
                $resourcePath
            );
        }

        // form params
        if ($image !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($image);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['image'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['image'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSignDocument
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postSignDocument($name, $signature = null, $storage = null, $folder = null)
    {
        list($response) = $this->postSignDocumentWithHttpInfo($name, $signature, $storage, $folder);
        return $response;
    }

    /**
     * Operation postSignDocumentWithHttpInfo
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSignDocumentWithHttpInfo($name, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postSignDocumentRequest($name, $signature, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSignDocumentAsync
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignDocumentAsync($name, $signature = null, $storage = null, $folder = null)
    {
        return $this->postSignDocumentAsyncWithHttpInfo($name, $signature, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSignDocumentAsyncWithHttpInfo
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignDocumentAsyncWithHttpInfo($name, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postSignDocumentRequest($name, $signature, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSignDocument'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSignDocumentRequest($name, $signature = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSignDocument'
            );
        }

        $resourcePath = '/pdf/{name}/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($signature)) {
            $_tempBody = $signature;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSignPage
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postSignPage($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        list($response) = $this->postSignPageWithHttpInfo($name, $page_number, $signature, $storage, $folder);
        return $response;
    }

    /**
     * Operation postSignPageWithHttpInfo
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSignPageWithHttpInfo($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postSignPageRequest($name, $page_number, $signature, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSignPageAsync
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignPageAsync($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        return $this->postSignPageAsyncWithHttpInfo($name, $page_number, $signature, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSignPageAsyncWithHttpInfo
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignPageAsyncWithHttpInfo($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postSignPageRequest($name, $page_number, $signature, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSignPage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSignPageRequest($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSignPage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postSignPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($signature)) {
            $_tempBody = $signature;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSplitDocument
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SplitResultResponse
     */
    public function postSplitDocument($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        list($response) = $this->postSplitDocumentWithHttpInfo($name, $format, $from, $to, $storage, $folder);
        return $response;
    }

    /**
     * Operation postSplitDocumentWithHttpInfo
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SplitResultResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSplitDocumentWithHttpInfo($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SplitResultResponse';
        $request = $this->postSplitDocumentRequest($name, $format, $from, $to, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SplitResultResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSplitDocumentAsync
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSplitDocumentAsync($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        return $this->postSplitDocumentAsyncWithHttpInfo($name, $format, $from, $to, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSplitDocumentAsyncWithHttpInfo
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSplitDocumentAsyncWithHttpInfo($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SplitResultResponse';
        $request = $this->postSplitDocumentRequest($name, $format, $from, $to, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSplitDocument'
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSplitDocumentRequest($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSplitDocument'
            );
        }

        $resourcePath = '/pdf/{name}/split';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddNewPage
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPagesResponse
     */
    public function putAddNewPage($name, $storage = null, $folder = null)
    {
        list($response) = $this->putAddNewPageWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation putAddNewPageWithHttpInfo
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddNewPageWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->putAddNewPageRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddNewPageAsync
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddNewPageAsync($name, $storage = null, $folder = null)
    {
        return $this->putAddNewPageAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddNewPageAsyncWithHttpInfo
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddNewPageAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->putAddNewPageRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddNewPage'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddNewPageRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddNewPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddParagraph
     *
     * Add text to PDF document page. Deprecated
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putAddParagraph($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        list($response) = $this->putAddParagraphWithHttpInfo($name, $page_number, $paragraph, $storage, $folder);
        return $response;
    }

    /**
     * Operation putAddParagraphWithHttpInfo
     *
     * Add text to PDF document page. Deprecated
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddParagraphWithHttpInfo($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putAddParagraphRequest($name, $page_number, $paragraph, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddParagraphAsync
     *
     * Add text to PDF document page. Deprecated
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddParagraphAsync($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        return $this->putAddParagraphAsyncWithHttpInfo($name, $page_number, $paragraph, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddParagraphAsyncWithHttpInfo
     *
     * Add text to PDF document page. Deprecated
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddParagraphAsyncWithHttpInfo($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putAddParagraphRequest($name, $page_number, $paragraph, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddParagraph'
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddParagraphRequest($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddParagraph'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putAddParagraph'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/paragraph';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($paragraph)) {
            $_tempBody = $paragraph;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddText
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putAddText($name, $page_number, $paragraph = null, $folder = null)
    {
        list($response) = $this->putAddTextWithHttpInfo($name, $page_number, $paragraph, $folder);
        return $response;
    }

    /**
     * Operation putAddTextWithHttpInfo
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddTextWithHttpInfo($name, $page_number, $paragraph = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putAddTextRequest($name, $page_number, $paragraph, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddTextAsync
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddTextAsync($name, $page_number, $paragraph = null, $folder = null)
    {
        return $this->putAddTextAsyncWithHttpInfo($name, $page_number, $paragraph, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddTextAsyncWithHttpInfo
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddTextAsyncWithHttpInfo($name, $page_number, $paragraph = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putAddTextRequest($name, $page_number, $paragraph, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddText'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddTextRequest($name, $page_number, $paragraph = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putAddText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($paragraph)) {
            $_tempBody = $paragraph;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putConvertDocument
     *
     * Convert document from request content to format specified.
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putConvertDocument($format = null, $url = null, $out_path = null, $file = null)
    {
        list($response) = $this->putConvertDocumentWithHttpInfo($format, $url, $out_path, $file);
        return $response;
    }

    /**
     * Operation putConvertDocumentWithHttpInfo
     *
     * Convert document from request content to format specified.
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putConvertDocumentWithHttpInfo($format = null, $url = null, $out_path = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putConvertDocumentRequest($format, $url, $out_path, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putConvertDocumentAsync
     *
     * Convert document from request content to format specified.
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putConvertDocumentAsync($format = null, $url = null, $out_path = null, $file = null)
    {
        return $this->putConvertDocumentAsyncWithHttpInfo($format, $url, $out_path, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putConvertDocumentAsyncWithHttpInfo
     *
     * Convert document from request content to format specified.
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putConvertDocumentAsyncWithHttpInfo($format = null, $url = null, $out_path = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putConvertDocumentRequest($format, $url, $out_path, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putConvertDocument'
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putConvertDocumentRequest($format = null, $url = null, $out_path = null, $file = null)
    {

        $resourcePath = '/pdf/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreate
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putCreate($path, $file, $version_id = null, $storage = null)
    {
        list($response) = $this->putCreateWithHttpInfo($path, $file, $version_id, $storage);
        return $response;
    }

    /**
     * Operation putCreateWithHttpInfo
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateWithHttpInfo($path, $file, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putCreateRequest($path, $file, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateAsync
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateAsync($path, $file, $version_id = null, $storage = null)
    {
        return $this->putCreateAsyncWithHttpInfo($path, $file, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateAsyncWithHttpInfo
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateAsyncWithHttpInfo($path, $file, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putCreateRequest($path, $file, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreate'
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateRequest($path, $file, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling putCreate'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling putCreate'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreateDocument
     *
     * Create new document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function putCreateDocument($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        list($response) = $this->putCreateDocumentWithHttpInfo($name, $template_file, $data_file, $template_type, $storage, $folder, $url, $fit_size);
        return $response;
    }

    /**
     * Operation putCreateDocumentWithHttpInfo
     *
     * Create new document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateDocumentWithHttpInfo($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentRequest($name, $template_file, $data_file, $template_type, $storage, $folder, $url, $fit_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateDocumentAsync
     *
     * Create new document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentAsync($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        return $this->putCreateDocumentAsyncWithHttpInfo($name, $template_file, $data_file, $template_type, $storage, $folder, $url, $fit_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateDocumentAsyncWithHttpInfo
     *
     * Create new document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentAsyncWithHttpInfo($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentRequest($name, $template_file, $data_file, $template_type, $storage, $folder, $url, $fit_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreateDocument'
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateDocumentRequest($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCreateDocument'
            );
        }

        $resourcePath = '/pdf/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($template_file !== null) {
            $queryParams['templateFile'] = ObjectSerializer::toQueryValue($template_file);
        }
        // query params
        if ($data_file !== null) {
            $queryParams['dataFile'] = ObjectSerializer::toQueryValue($data_file);
        }
        // query params
        if ($template_type !== null) {
            $queryParams['templateType'] = ObjectSerializer::toQueryValue($template_type);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($fit_size !== null) {
            $queryParams['fitSize'] = ObjectSerializer::toQueryValue($fit_size);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreateDocumentFromImages
     *
     * Create new document from images.
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function putCreateDocumentFromImages($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        list($response) = $this->putCreateDocumentFromImagesWithHttpInfo($name, $images, $ocr, $ocr_lang, $storage, $folder);
        return $response;
    }

    /**
     * Operation putCreateDocumentFromImagesWithHttpInfo
     *
     * Create new document from images.
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateDocumentFromImagesWithHttpInfo($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentFromImagesRequest($name, $images, $ocr, $ocr_lang, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateDocumentFromImagesAsync
     *
     * Create new document from images.
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentFromImagesAsync($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        return $this->putCreateDocumentFromImagesAsyncWithHttpInfo($name, $images, $ocr, $ocr_lang, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateDocumentFromImagesAsyncWithHttpInfo
     *
     * Create new document from images.
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentFromImagesAsyncWithHttpInfo($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentFromImagesRequest($name, $images, $ocr, $ocr_lang, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreateDocumentFromImages'
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateDocumentFromImagesRequest($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCreateDocumentFromImages'
            );
        }

        $resourcePath = '/pdf/{name}/fromimages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ocr !== null) {
            $queryParams['ocr'] = ObjectSerializer::toQueryValue($ocr);
        }
        // query params
        if ($ocr_lang !== null) {
            $queryParams['ocrLang'] = ObjectSerializer::toQueryValue($ocr_lang);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($images)) {
            $_tempBody = $images;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDocumentSaveAsTiff
     *
     * Save document as Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putDocumentSaveAsTiff($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        list($response) = $this->putDocumentSaveAsTiffWithHttpInfo($name, $export_options, $result_file, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $folder);
        return $response;
    }

    /**
     * Operation putDocumentSaveAsTiffWithHttpInfo
     *
     * Save document as Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDocumentSaveAsTiffWithHttpInfo($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putDocumentSaveAsTiffRequest($name, $export_options, $result_file, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDocumentSaveAsTiffAsync
     *
     * Save document as Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDocumentSaveAsTiffAsync($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        return $this->putDocumentSaveAsTiffAsyncWithHttpInfo($name, $export_options, $result_file, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDocumentSaveAsTiffAsyncWithHttpInfo
     *
     * Save document as Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDocumentSaveAsTiffAsyncWithHttpInfo($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putDocumentSaveAsTiffRequest($name, $export_options, $result_file, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDocumentSaveAsTiff'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDocumentSaveAsTiffRequest($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putDocumentSaveAsTiff'
            );
        }

        $resourcePath = '/pdf/{name}/SaveAs/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($result_file !== null) {
            $queryParams['resultFile'] = ObjectSerializer::toQueryValue($result_file);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($export_options)) {
            $_tempBody = $export_options;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putEpubInStorageToPdf
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putEpubInStorageToPdf($name, $src_path, $dst_folder = null)
    {
        list($response) = $this->putEpubInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder);
        return $response;
    }

    /**
     * Operation putEpubInStorageToPdfWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putEpubInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putEpubInStorageToPdfRequest($name, $src_path, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putEpubInStorageToPdfAsync
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putEpubInStorageToPdfAsync($name, $src_path, $dst_folder = null)
    {
        return $this->putEpubInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putEpubInStorageToPdfAsyncWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putEpubInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putEpubInStorageToPdfRequest($name, $src_path, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putEpubInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putEpubInStorageToPdfRequest($name, $src_path, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putEpubInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putEpubInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFieldsFlatten
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putFieldsFlatten($name, $storage = null, $folder = null)
    {
        list($response) = $this->putFieldsFlattenWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation putFieldsFlattenWithHttpInfo
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFieldsFlattenWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putFieldsFlattenRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFieldsFlattenAsync
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldsFlattenAsync($name, $storage = null, $folder = null)
    {
        return $this->putFieldsFlattenAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFieldsFlattenAsyncWithHttpInfo
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldsFlattenAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putFieldsFlattenRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFieldsFlatten'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFieldsFlattenRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putFieldsFlatten'
            );
        }

        $resourcePath = '/pdf/{name}/fields/flatten';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putHtmlInStorageToPdf
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putHtmlInStorageToPdf($name, $src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        list($response) = $this->putHtmlInStorageToPdfWithHttpInfo($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder);
        return $response;
    }

    /**
     * Operation putHtmlInStorageToPdfWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putHtmlInStorageToPdfWithHttpInfo($name, $src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putHtmlInStorageToPdfRequest($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putHtmlInStorageToPdfAsync
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHtmlInStorageToPdfAsync($name, $src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        return $this->putHtmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putHtmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHtmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putHtmlInStorageToPdfRequest($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putHtmlInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putHtmlInStorageToPdfRequest($name, $src_path, $html_file_name, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putHtmlInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putHtmlInStorageToPdf'
            );
        }
        // verify the required parameter 'html_file_name' is set
        if ($html_file_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $html_file_name when calling putHtmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($html_file_name !== null) {
            $queryParams['htmlFileName'] = ObjectSerializer::toQueryValue($html_file_name);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageInStorageToPdf
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putImageInStorageToPdf($name, $image_templates, $dst_folder = null)
    {
        list($response) = $this->putImageInStorageToPdfWithHttpInfo($name, $image_templates, $dst_folder);
        return $response;
    }

    /**
     * Operation putImageInStorageToPdfWithHttpInfo
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageInStorageToPdfWithHttpInfo($name, $image_templates, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImageInStorageToPdfRequest($name, $image_templates, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageInStorageToPdfAsync
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageInStorageToPdfAsync($name, $image_templates, $dst_folder = null)
    {
        return $this->putImageInStorageToPdfAsyncWithHttpInfo($name, $image_templates, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageInStorageToPdfAsyncWithHttpInfo
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageInStorageToPdfAsyncWithHttpInfo($name, $image_templates, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImageInStorageToPdfRequest($name, $image_templates, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageInStorageToPdfRequest($name, $image_templates, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageInStorageToPdf'
            );
        }
        // verify the required parameter 'image_templates' is set
        if ($image_templates === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_templates when calling putImageInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($image_templates)) {
            $_tempBody = $image_templates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsGif
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putImagesExtractAsGif($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        list($response) = $this->putImagesExtractAsGifWithHttpInfo($name, $page_number, $width, $height, $folder, $dest_folder);
        return $response;
    }

    /**
     * Operation putImagesExtractAsGifWithHttpInfo
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsGifWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImagesExtractAsGifRequest($name, $page_number, $width, $height, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsGifAsync
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsGifAsync($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsGifAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsGifAsyncWithHttpInfo
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsGifAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImagesExtractAsGifRequest($name, $page_number, $width, $height, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsGif'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsGifRequest($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsGif'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsGif'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsJpeg
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putImagesExtractAsJpeg($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        list($response) = $this->putImagesExtractAsJpegWithHttpInfo($name, $page_number, $width, $height, $folder, $dest_folder);
        return $response;
    }

    /**
     * Operation putImagesExtractAsJpegWithHttpInfo
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsJpegWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImagesExtractAsJpegRequest($name, $page_number, $width, $height, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsJpegAsync
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsJpegAsync($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsJpegAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsJpegAsyncWithHttpInfo
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsJpegAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImagesExtractAsJpegRequest($name, $page_number, $width, $height, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsJpegRequest($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsJpeg'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsPng
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putImagesExtractAsPng($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        list($response) = $this->putImagesExtractAsPngWithHttpInfo($name, $page_number, $width, $height, $folder, $dest_folder);
        return $response;
    }

    /**
     * Operation putImagesExtractAsPngWithHttpInfo
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsPngWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImagesExtractAsPngRequest($name, $page_number, $width, $height, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsPngAsync
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsPngAsync($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsPngAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsPngAsyncWithHttpInfo
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsPngAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImagesExtractAsPngRequest($name, $page_number, $width, $height, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsPng'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsPngRequest($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsPng'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsPng'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsTiff
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putImagesExtractAsTiff($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        list($response) = $this->putImagesExtractAsTiffWithHttpInfo($name, $page_number, $width, $height, $folder, $dest_folder);
        return $response;
    }

    /**
     * Operation putImagesExtractAsTiffWithHttpInfo
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsTiffWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImagesExtractAsTiffRequest($name, $page_number, $width, $height, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsTiffAsync
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsTiffAsync($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsTiffAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsTiffAsyncWithHttpInfo
     *
     * Extract document images in format specified to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsTiffAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putImagesExtractAsTiffRequest($name, $page_number, $width, $height, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsTiff'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsTiffRequest($name, $page_number, $width = null, $height = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsTiff'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsTiff'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putLaTeXInStorageToPdf
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putLaTeXInStorageToPdf($name, $src_path, $dst_folder = null)
    {
        list($response) = $this->putLaTeXInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder);
        return $response;
    }

    /**
     * Operation putLaTeXInStorageToPdfWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putLaTeXInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putLaTeXInStorageToPdfRequest($name, $src_path, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putLaTeXInStorageToPdfAsync
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLaTeXInStorageToPdfAsync($name, $src_path, $dst_folder = null)
    {
        return $this->putLaTeXInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putLaTeXInStorageToPdfAsyncWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLaTeXInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putLaTeXInStorageToPdfRequest($name, $src_path, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putLaTeXInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putLaTeXInStorageToPdfRequest($name, $src_path, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putLaTeXInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putLaTeXInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMergeDocuments
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function putMergeDocuments($name, $merge_documents = null, $storage = null, $folder = null)
    {
        list($response) = $this->putMergeDocumentsWithHttpInfo($name, $merge_documents, $storage, $folder);
        return $response;
    }

    /**
     * Operation putMergeDocumentsWithHttpInfo
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMergeDocumentsWithHttpInfo($name, $merge_documents = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putMergeDocumentsRequest($name, $merge_documents, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putMergeDocumentsAsync
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMergeDocumentsAsync($name, $merge_documents = null, $storage = null, $folder = null)
    {
        return $this->putMergeDocumentsAsyncWithHttpInfo($name, $merge_documents, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMergeDocumentsAsyncWithHttpInfo
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMergeDocumentsAsyncWithHttpInfo($name, $merge_documents = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putMergeDocumentsRequest($name, $merge_documents, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMergeDocuments'
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMergeDocumentsRequest($name, $merge_documents = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putMergeDocuments'
            );
        }

        $resourcePath = '/pdf/{name}/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($merge_documents)) {
            $_tempBody = $merge_documents;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMhtInStorageToPdf
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putMhtInStorageToPdf($name, $src_path, $dst_folder = null)
    {
        list($response) = $this->putMhtInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder);
        return $response;
    }

    /**
     * Operation putMhtInStorageToPdfWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMhtInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putMhtInStorageToPdfRequest($name, $src_path, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putMhtInStorageToPdfAsync
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMhtInStorageToPdfAsync($name, $src_path, $dst_folder = null)
    {
        return $this->putMhtInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMhtInStorageToPdfAsyncWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMhtInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putMhtInStorageToPdfRequest($name, $src_path, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMhtInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMhtInStorageToPdfRequest($name, $src_path, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putMhtInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putMhtInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/mht';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageAddStamp
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPageAddStamp($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        list($response) = $this->putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage, $folder);
        return $response;
    }

    /**
     * Operation putPageAddStampWithHttpInfo
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageAddStampRequest($name, $page_number, $stamp, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageAddStampAsync
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageAddStampAsync($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        return $this->putPageAddStampAsyncWithHttpInfo($name, $page_number, $stamp, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageAddStampAsyncWithHttpInfo
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageAddStampAsyncWithHttpInfo($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageAddStampRequest($name, $page_number, $stamp, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageAddStamp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageAddStampRequest($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageAddStamp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageAddStamp'
            );
        }
        // verify the required parameter 'stamp' is set
        if ($stamp === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamp when calling putPageAddStamp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/stamp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($stamp)) {
            $_tempBody = $stamp;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToBmp
     *
     * Convert document page to bmp image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPageConvertToBmp($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->putPageConvertToBmpWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation putPageConvertToBmpWithHttpInfo
     *
     * Convert document page to bmp image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToBmpWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToBmpRequest($name, $page_number, $out_path, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToBmpAsync
     *
     * Convert document page to bmp image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToBmpAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        return $this->putPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToBmpAsyncWithHttpInfo
     *
     * Convert document page to bmp image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToBmpRequest($name, $page_number, $out_path, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToBmp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToBmpRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToBmp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToBmp'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToBmp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/bmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToEmf
     *
     * Convert document page to emf image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPageConvertToEmf($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->putPageConvertToEmfWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation putPageConvertToEmfWithHttpInfo
     *
     * Convert document page to emf image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToEmfWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToEmfRequest($name, $page_number, $out_path, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToEmfAsync
     *
     * Convert document page to emf image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToEmfAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        return $this->putPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToEmfAsyncWithHttpInfo
     *
     * Convert document page to emf image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToEmfRequest($name, $page_number, $out_path, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToEmf'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToEmfRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToEmf'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToEmf'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToEmf'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/emf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToGif
     *
     * Convert document page to gif image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPageConvertToGif($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->putPageConvertToGifWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation putPageConvertToGifWithHttpInfo
     *
     * Convert document page to gif image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToGifWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToGifRequest($name, $page_number, $out_path, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToGifAsync
     *
     * Convert document page to gif image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToGifAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        return $this->putPageConvertToGifAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToGifAsyncWithHttpInfo
     *
     * Convert document page to gif image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToGifAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToGifRequest($name, $page_number, $out_path, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToGif'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToGifRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToGif'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToGif'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToGif'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToJpeg
     *
     * Convert document page to Jpeg image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPageConvertToJpeg($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->putPageConvertToJpegWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation putPageConvertToJpegWithHttpInfo
     *
     * Convert document page to Jpeg image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToJpegWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToJpegRequest($name, $page_number, $out_path, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToJpegAsync
     *
     * Convert document page to Jpeg image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToJpegAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        return $this->putPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToJpegAsyncWithHttpInfo
     *
     * Convert document page to Jpeg image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToJpegRequest($name, $page_number, $out_path, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToJpegRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToJpeg'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToJpeg'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToPng
     *
     * Convert document page to png image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPageConvertToPng($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->putPageConvertToPngWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation putPageConvertToPngWithHttpInfo
     *
     * Convert document page to png image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToPngWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToPngRequest($name, $page_number, $out_path, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToPngAsync
     *
     * Convert document page to png image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToPngAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        return $this->putPageConvertToPngAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToPngAsyncWithHttpInfo
     *
     * Convert document page to png image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToPngAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToPngRequest($name, $page_number, $out_path, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToPng'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToPngRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToPng'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToPng'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToPng'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToTiff
     *
     * Convert document page to Tiff image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPageConvertToTiff($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        list($response) = $this->putPageConvertToTiffWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder);
        return $response;
    }

    /**
     * Operation putPageConvertToTiffWithHttpInfo
     *
     * Convert document page to Tiff image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToTiffWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToTiffRequest($name, $page_number, $out_path, $width, $height, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToTiffAsync
     *
     * Convert document page to Tiff image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToTiffAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        return $this->putPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToTiffAsyncWithHttpInfo
     *
     * Convert document page to Tiff image and save in storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageConvertToTiffRequest($name, $page_number, $out_path, $width, $height, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToTiffRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToTiff'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToTiff'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPclInStorageToPdf
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPclInStorageToPdf($name, $src_path, $dst_folder = null)
    {
        list($response) = $this->putPclInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder);
        return $response;
    }

    /**
     * Operation putPclInStorageToPdfWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPclInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPclInStorageToPdfRequest($name, $src_path, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPclInStorageToPdfAsync
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPclInStorageToPdfAsync($name, $src_path, $dst_folder = null)
    {
        return $this->putPclInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPclInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPclInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPclInStorageToPdfRequest($name, $src_path, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPclInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPclInStorageToPdfRequest($name, $src_path, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPclInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putPclInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/pcl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToDoc
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToDoc($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToDocWithHttpInfo
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToDocRequest($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToDocAsync
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToDocAsync($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        return $this->putPdfInRequestToDocAsyncWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToDocAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToDocAsyncWithHttpInfo($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToDocRequest($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToDoc'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToDocRequest($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToDoc'
            );
        }

        $resourcePath = '/pdf/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToEpub
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToEpub($out_path, $content_recognition_mode = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToEpubWithHttpInfo($out_path, $content_recognition_mode, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToEpubWithHttpInfo
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToEpubWithHttpInfo($out_path, $content_recognition_mode = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToEpubRequest($out_path, $content_recognition_mode, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToEpubAsync
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToEpubAsync($out_path, $content_recognition_mode = null, $file = null)
    {
        return $this->putPdfInRequestToEpubAsyncWithHttpInfo($out_path, $content_recognition_mode, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToEpubAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToEpubAsyncWithHttpInfo($out_path, $content_recognition_mode = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToEpubRequest($out_path, $content_recognition_mode, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToEpub'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToEpubRequest($out_path, $content_recognition_mode = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToEpub'
            );
        }

        $resourcePath = '/pdf/convert/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($content_recognition_mode !== null) {
            $queryParams['contentRecognitionMode'] = ObjectSerializer::toQueryValue($content_recognition_mode);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToHtml
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToHtml($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToHtmlWithHttpInfo($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToHtmlWithHttpInfo
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToHtmlWithHttpInfo($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToHtmlRequest($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToHtmlAsync
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToHtmlAsync($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $file = null)
    {
        return $this->putPdfInRequestToHtmlAsyncWithHttpInfo($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToHtmlAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToHtmlAsyncWithHttpInfo($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToHtmlRequest($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToHtml'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToHtmlRequest($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToHtml'
            );
        }

        $resourcePath = '/pdf/convert/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($additional_margin_width_in_points !== null) {
            $queryParams['additionalMarginWidthInPoints'] = ObjectSerializer::toQueryValue($additional_margin_width_in_points);
        }
        // query params
        if ($compress_svg_graphics_if_any !== null) {
            $queryParams['compressSvgGraphicsIfAny'] = ObjectSerializer::toQueryValue($compress_svg_graphics_if_any);
        }
        // query params
        if ($convert_marked_content_to_layers !== null) {
            $queryParams['convertMarkedContentToLayers'] = ObjectSerializer::toQueryValue($convert_marked_content_to_layers);
        }
        // query params
        if ($default_font_name !== null) {
            $queryParams['defaultFontName'] = ObjectSerializer::toQueryValue($default_font_name);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($fixed_layout !== null) {
            $queryParams['fixedLayout'] = ObjectSerializer::toQueryValue($fixed_layout);
        }
        // query params
        if ($image_resolution !== null) {
            $queryParams['imageResolution'] = ObjectSerializer::toQueryValue($image_resolution);
        }
        // query params
        if ($minimal_line_width !== null) {
            $queryParams['minimalLineWidth'] = ObjectSerializer::toQueryValue($minimal_line_width);
        }
        // query params
        if ($prevent_glyphs_grouping !== null) {
            $queryParams['preventGlyphsGrouping'] = ObjectSerializer::toQueryValue($prevent_glyphs_grouping);
        }
        // query params
        if ($split_css_into_pages !== null) {
            $queryParams['splitCssIntoPages'] = ObjectSerializer::toQueryValue($split_css_into_pages);
        }
        // query params
        if ($split_into_pages !== null) {
            $queryParams['splitIntoPages'] = ObjectSerializer::toQueryValue($split_into_pages);
        }
        // query params
        if ($use_z_order !== null) {
            $queryParams['useZOrder'] = ObjectSerializer::toQueryValue($use_z_order);
        }
        // query params
        if ($antialiasing_processing !== null) {
            $queryParams['antialiasingProcessing'] = ObjectSerializer::toQueryValue($antialiasing_processing);
        }
        // query params
        if ($css_class_names_prefix !== null) {
            $queryParams['cssClassNamesPrefix'] = ObjectSerializer::toQueryValue($css_class_names_prefix);
        }
        // query params
        if (is_array($explicit_list_of_saved_pages)) {
            $explicit_list_of_saved_pages = ObjectSerializer::serializeCollection($explicit_list_of_saved_pages, 'multi', true);
        }
        if ($explicit_list_of_saved_pages !== null) {
            $queryParams['explicitListOfSavedPages'] = ObjectSerializer::toQueryValue($explicit_list_of_saved_pages);
        }
        // query params
        if ($font_encoding_strategy !== null) {
            $queryParams['fontEncodingStrategy'] = ObjectSerializer::toQueryValue($font_encoding_strategy);
        }
        // query params
        if ($font_saving_mode !== null) {
            $queryParams['fontSavingMode'] = ObjectSerializer::toQueryValue($font_saving_mode);
        }
        // query params
        if ($html_markup_generation_mode !== null) {
            $queryParams['htmlMarkupGenerationMode'] = ObjectSerializer::toQueryValue($html_markup_generation_mode);
        }
        // query params
        if ($letters_positioning_method !== null) {
            $queryParams['lettersPositioningMethod'] = ObjectSerializer::toQueryValue($letters_positioning_method);
        }
        // query params
        if ($pages_flow_type_depends_on_viewers_screen_size !== null) {
            $queryParams['pagesFlowTypeDependsOnViewersScreenSize'] = ObjectSerializer::toQueryValue($pages_flow_type_depends_on_viewers_screen_size);
        }
        // query params
        if ($parts_embedding_mode !== null) {
            $queryParams['partsEmbeddingMode'] = ObjectSerializer::toQueryValue($parts_embedding_mode);
        }
        // query params
        if ($raster_images_saving_mode !== null) {
            $queryParams['rasterImagesSavingMode'] = ObjectSerializer::toQueryValue($raster_images_saving_mode);
        }
        // query params
        if ($remove_empty_areas_on_top_and_bottom !== null) {
            $queryParams['removeEmptyAreasOnTopAndBottom'] = ObjectSerializer::toQueryValue($remove_empty_areas_on_top_and_bottom);
        }
        // query params
        if ($save_shadowed_texts_as_transparent_texts !== null) {
            $queryParams['saveShadowedTextsAsTransparentTexts'] = ObjectSerializer::toQueryValue($save_shadowed_texts_as_transparent_texts);
        }
        // query params
        if ($save_transparent_texts !== null) {
            $queryParams['saveTransparentTexts'] = ObjectSerializer::toQueryValue($save_transparent_texts);
        }
        // query params
        if ($special_folder_for_all_images !== null) {
            $queryParams['specialFolderForAllImages'] = ObjectSerializer::toQueryValue($special_folder_for_all_images);
        }
        // query params
        if ($special_folder_for_svg_images !== null) {
            $queryParams['specialFolderForSvgImages'] = ObjectSerializer::toQueryValue($special_folder_for_svg_images);
        }
        // query params
        if ($try_save_text_underlining_and_strikeouting_in_css !== null) {
            $queryParams['trySaveTextUnderliningAndStrikeoutingInCss'] = ObjectSerializer::toQueryValue($try_save_text_underlining_and_strikeouting_in_css);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToLaTeX
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToLaTeX($out_path, $pages_count = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToLaTeXWithHttpInfo($out_path, $pages_count, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToLaTeXWithHttpInfo
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToLaTeXWithHttpInfo($out_path, $pages_count = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToLaTeXRequest($out_path, $pages_count, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToLaTeXAsync
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToLaTeXAsync($out_path, $pages_count = null, $file = null)
    {
        return $this->putPdfInRequestToLaTeXAsyncWithHttpInfo($out_path, $pages_count, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToLaTeXAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToLaTeXAsyncWithHttpInfo($out_path, $pages_count = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToLaTeXRequest($out_path, $pages_count, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToLaTeX'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToLaTeXRequest($out_path, $pages_count = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToLaTeX'
            );
        }

        $resourcePath = '/pdf/convert/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($pages_count !== null) {
            $queryParams['pagesCount'] = ObjectSerializer::toQueryValue($pages_count);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToMobiXml
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToMobiXml($out_path, $file = null)
    {
        list($response) = $this->putPdfInRequestToMobiXmlWithHttpInfo($out_path, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToMobiXmlWithHttpInfo
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToMobiXmlWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToMobiXmlRequest($out_path, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToMobiXmlAsync
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToMobiXmlAsync($out_path, $file = null)
    {
        return $this->putPdfInRequestToMobiXmlAsyncWithHttpInfo($out_path, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToMobiXmlAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToMobiXmlAsyncWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToMobiXmlRequest($out_path, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToMobiXml'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToMobiXmlRequest($out_path, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToMobiXml'
            );
        }

        $resourcePath = '/pdf/convert/mobixml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToPdfA
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToPdfA($out_path, $type, $file = null)
    {
        list($response) = $this->putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToPdfAWithHttpInfo
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToPdfARequest($out_path, $type, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToPdfAAsync
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPdfAAsync($out_path, $type, $file = null)
    {
        return $this->putPdfInRequestToPdfAAsyncWithHttpInfo($out_path, $type, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPdfAAsyncWithHttpInfo($out_path, $type, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToPdfARequest($out_path, $type, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToPdfA'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToPdfARequest($out_path, $type, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling putPdfInRequestToPdfA'
            );
        }

        $resourcePath = '/pdf/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToPptx
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToPptx($out_path, $separate_images = null, $slides_as_images = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToPptxWithHttpInfo($out_path, $separate_images, $slides_as_images, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToPptxWithHttpInfo
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToPptxWithHttpInfo($out_path, $separate_images = null, $slides_as_images = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToPptxRequest($out_path, $separate_images, $slides_as_images, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToPptxAsync
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPptxAsync($out_path, $separate_images = null, $slides_as_images = null, $file = null)
    {
        return $this->putPdfInRequestToPptxAsyncWithHttpInfo($out_path, $separate_images, $slides_as_images, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToPptxAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPptxAsyncWithHttpInfo($out_path, $separate_images = null, $slides_as_images = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToPptxRequest($out_path, $separate_images, $slides_as_images, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToPptx'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToPptxRequest($out_path, $separate_images = null, $slides_as_images = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToPptx'
            );
        }

        $resourcePath = '/pdf/convert/pptx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($separate_images !== null) {
            $queryParams['separateImages'] = ObjectSerializer::toQueryValue($separate_images);
        }
        // query params
        if ($slides_as_images !== null) {
            $queryParams['slidesAsImages'] = ObjectSerializer::toQueryValue($slides_as_images);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToSvg
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToSvg($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToSvgWithHttpInfo($out_path, $compress_output_to_zip_archive, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToSvgWithHttpInfo
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToSvgWithHttpInfo($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToSvgRequest($out_path, $compress_output_to_zip_archive, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToSvgAsync
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToSvgAsync($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        return $this->putPdfInRequestToSvgAsyncWithHttpInfo($out_path, $compress_output_to_zip_archive, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToSvgAsyncWithHttpInfo($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToSvgRequest($out_path, $compress_output_to_zip_archive, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToSvg'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToSvgRequest($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToSvg'
            );
        }

        $resourcePath = '/pdf/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($compress_output_to_zip_archive !== null) {
            $queryParams['compressOutputToZipArchive'] = ObjectSerializer::toQueryValue($compress_output_to_zip_archive);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToTiff
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToTiff($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToTiffWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToTiffWithHttpInfo
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToTiffWithHttpInfo($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToTiffRequest($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToTiffAsync
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToTiffAsync($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        return $this->putPdfInRequestToTiffAsyncWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToTiffAsyncWithHttpInfo($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToTiffRequest($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToTiff'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToTiffRequest($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToTiff'
            );
        }

        $resourcePath = '/pdf/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXls
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToXls($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToXlsWithHttpInfo
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXlsAsync
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsAsync($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        return $this->putPdfInRequestToXlsAsyncWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsAsyncWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXls'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXls'
            );
        }

        $resourcePath = '/pdf/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXml
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToXml($out_path, $file = null)
    {
        list($response) = $this->putPdfInRequestToXmlWithHttpInfo($out_path, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToXmlWithHttpInfo
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXmlWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToXmlRequest($out_path, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXmlAsync
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXmlAsync($out_path, $file = null)
    {
        return $this->putPdfInRequestToXmlAsyncWithHttpInfo($out_path, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXmlAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXmlAsyncWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToXmlRequest($out_path, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXml'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXmlRequest($out_path, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXml'
            );
        }

        $resourcePath = '/pdf/convert/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXps
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInRequestToXps($out_path, $file = null)
    {
        list($response) = $this->putPdfInRequestToXpsWithHttpInfo($out_path, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToXpsWithHttpInfo
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXpsWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToXpsRequest($out_path, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXpsAsync
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXpsAsync($out_path, $file = null)
    {
        return $this->putPdfInRequestToXpsAsyncWithHttpInfo($out_path, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXpsAsyncWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInRequestToXpsRequest($out_path, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXps'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXpsRequest($out_path, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXps'
            );
        }

        $resourcePath = '/pdf/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToDoc
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToDoc($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToDocWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToDocAsync
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToDocAsync($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        return $this->putPdfInStorageToDocAsyncWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToDocAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToDocAsyncWithHttpInfo($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToDoc'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToDoc'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToDoc'
            );
        }

        $resourcePath = '/pdf/{name}/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToEpub
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToEpub($name, $out_path, $content_recognition_mode = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToEpubWithHttpInfo($name, $out_path, $content_recognition_mode, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToEpubWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToEpubWithHttpInfo($name, $out_path, $content_recognition_mode = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToEpubRequest($name, $out_path, $content_recognition_mode, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToEpubAsync
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToEpubAsync($name, $out_path, $content_recognition_mode = null, $folder = null)
    {
        return $this->putPdfInStorageToEpubAsyncWithHttpInfo($name, $out_path, $content_recognition_mode, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToEpubAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToEpubAsyncWithHttpInfo($name, $out_path, $content_recognition_mode = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToEpubRequest($name, $out_path, $content_recognition_mode, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToEpub'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode roperty tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToEpubRequest($name, $out_path, $content_recognition_mode = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToEpub'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToEpub'
            );
        }

        $resourcePath = '/pdf/{name}/convert/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($content_recognition_mode !== null) {
            $queryParams['contentRecognitionMode'] = ObjectSerializer::toQueryValue($content_recognition_mode);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToHtml
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToHtml($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToHtmlWithHttpInfo($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToHtmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToHtmlWithHttpInfo($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToHtmlRequest($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToHtmlAsync
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToHtmlAsync($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        return $this->putPdfInStorageToHtmlAsyncWithHttpInfo($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToHtmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToHtmlAsyncWithHttpInfo($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToHtmlRequest($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToHtml'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToHtmlRequest($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToHtml'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToHtml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($additional_margin_width_in_points !== null) {
            $queryParams['additionalMarginWidthInPoints'] = ObjectSerializer::toQueryValue($additional_margin_width_in_points);
        }
        // query params
        if ($compress_svg_graphics_if_any !== null) {
            $queryParams['compressSvgGraphicsIfAny'] = ObjectSerializer::toQueryValue($compress_svg_graphics_if_any);
        }
        // query params
        if ($convert_marked_content_to_layers !== null) {
            $queryParams['convertMarkedContentToLayers'] = ObjectSerializer::toQueryValue($convert_marked_content_to_layers);
        }
        // query params
        if ($default_font_name !== null) {
            $queryParams['defaultFontName'] = ObjectSerializer::toQueryValue($default_font_name);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($fixed_layout !== null) {
            $queryParams['fixedLayout'] = ObjectSerializer::toQueryValue($fixed_layout);
        }
        // query params
        if ($image_resolution !== null) {
            $queryParams['imageResolution'] = ObjectSerializer::toQueryValue($image_resolution);
        }
        // query params
        if ($minimal_line_width !== null) {
            $queryParams['minimalLineWidth'] = ObjectSerializer::toQueryValue($minimal_line_width);
        }
        // query params
        if ($prevent_glyphs_grouping !== null) {
            $queryParams['preventGlyphsGrouping'] = ObjectSerializer::toQueryValue($prevent_glyphs_grouping);
        }
        // query params
        if ($split_css_into_pages !== null) {
            $queryParams['splitCssIntoPages'] = ObjectSerializer::toQueryValue($split_css_into_pages);
        }
        // query params
        if ($split_into_pages !== null) {
            $queryParams['splitIntoPages'] = ObjectSerializer::toQueryValue($split_into_pages);
        }
        // query params
        if ($use_z_order !== null) {
            $queryParams['useZOrder'] = ObjectSerializer::toQueryValue($use_z_order);
        }
        // query params
        if ($antialiasing_processing !== null) {
            $queryParams['antialiasingProcessing'] = ObjectSerializer::toQueryValue($antialiasing_processing);
        }
        // query params
        if ($css_class_names_prefix !== null) {
            $queryParams['cssClassNamesPrefix'] = ObjectSerializer::toQueryValue($css_class_names_prefix);
        }
        // query params
        if (is_array($explicit_list_of_saved_pages)) {
            $explicit_list_of_saved_pages = ObjectSerializer::serializeCollection($explicit_list_of_saved_pages, 'multi', true);
        }
        if ($explicit_list_of_saved_pages !== null) {
            $queryParams['explicitListOfSavedPages'] = ObjectSerializer::toQueryValue($explicit_list_of_saved_pages);
        }
        // query params
        if ($font_encoding_strategy !== null) {
            $queryParams['fontEncodingStrategy'] = ObjectSerializer::toQueryValue($font_encoding_strategy);
        }
        // query params
        if ($font_saving_mode !== null) {
            $queryParams['fontSavingMode'] = ObjectSerializer::toQueryValue($font_saving_mode);
        }
        // query params
        if ($html_markup_generation_mode !== null) {
            $queryParams['htmlMarkupGenerationMode'] = ObjectSerializer::toQueryValue($html_markup_generation_mode);
        }
        // query params
        if ($letters_positioning_method !== null) {
            $queryParams['lettersPositioningMethod'] = ObjectSerializer::toQueryValue($letters_positioning_method);
        }
        // query params
        if ($pages_flow_type_depends_on_viewers_screen_size !== null) {
            $queryParams['pagesFlowTypeDependsOnViewersScreenSize'] = ObjectSerializer::toQueryValue($pages_flow_type_depends_on_viewers_screen_size);
        }
        // query params
        if ($parts_embedding_mode !== null) {
            $queryParams['partsEmbeddingMode'] = ObjectSerializer::toQueryValue($parts_embedding_mode);
        }
        // query params
        if ($raster_images_saving_mode !== null) {
            $queryParams['rasterImagesSavingMode'] = ObjectSerializer::toQueryValue($raster_images_saving_mode);
        }
        // query params
        if ($remove_empty_areas_on_top_and_bottom !== null) {
            $queryParams['removeEmptyAreasOnTopAndBottom'] = ObjectSerializer::toQueryValue($remove_empty_areas_on_top_and_bottom);
        }
        // query params
        if ($save_shadowed_texts_as_transparent_texts !== null) {
            $queryParams['saveShadowedTextsAsTransparentTexts'] = ObjectSerializer::toQueryValue($save_shadowed_texts_as_transparent_texts);
        }
        // query params
        if ($save_transparent_texts !== null) {
            $queryParams['saveTransparentTexts'] = ObjectSerializer::toQueryValue($save_transparent_texts);
        }
        // query params
        if ($special_folder_for_all_images !== null) {
            $queryParams['specialFolderForAllImages'] = ObjectSerializer::toQueryValue($special_folder_for_all_images);
        }
        // query params
        if ($special_folder_for_svg_images !== null) {
            $queryParams['specialFolderForSvgImages'] = ObjectSerializer::toQueryValue($special_folder_for_svg_images);
        }
        // query params
        if ($try_save_text_underlining_and_strikeouting_in_css !== null) {
            $queryParams['trySaveTextUnderliningAndStrikeoutingInCss'] = ObjectSerializer::toQueryValue($try_save_text_underlining_and_strikeouting_in_css);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToLaTeX
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToLaTeX($name, $out_path, $pages_count = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToLaTeXWithHttpInfo($name, $out_path, $pages_count, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToLaTeXWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToLaTeXWithHttpInfo($name, $out_path, $pages_count = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToLaTeXRequest($name, $out_path, $pages_count, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToLaTeXAsync
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToLaTeXAsync($name, $out_path, $pages_count = null, $folder = null)
    {
        return $this->putPdfInStorageToLaTeXAsyncWithHttpInfo($name, $out_path, $pages_count, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToLaTeXAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToLaTeXAsyncWithHttpInfo($name, $out_path, $pages_count = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToLaTeXRequest($name, $out_path, $pages_count, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToLaTeX'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToLaTeXRequest($name, $out_path, $pages_count = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToLaTeX'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToLaTeX'
            );
        }

        $resourcePath = '/pdf/{name}/convert/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($pages_count !== null) {
            $queryParams['pagesCount'] = ObjectSerializer::toQueryValue($pages_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToMobiXml
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToMobiXml($name, $out_path, $folder = null)
    {
        list($response) = $this->putPdfInStorageToMobiXmlWithHttpInfo($name, $out_path, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToMobiXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToMobiXmlWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToMobiXmlRequest($name, $out_path, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToMobiXmlAsync
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToMobiXmlAsync($name, $out_path, $folder = null)
    {
        return $this->putPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $out_path, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToMobiXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToMobiXmlRequest($name, $out_path, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToMobiXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToMobiXmlRequest($name, $out_path, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToMobiXml'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToMobiXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/mobixml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToPdfA
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToPdfA($name, $out_path, $type, $folder = null)
    {
        list($response) = $this->putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToPdfAWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToPdfARequest($name, $out_path, $type, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToPdfAAsync
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPdfAAsync($name, $out_path, $type, $folder = null)
    {
        return $this->putPdfInStorageToPdfAAsyncWithHttpInfo($name, $out_path, $type, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPdfAAsyncWithHttpInfo($name, $out_path, $type, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToPdfARequest($name, $out_path, $type, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToPdfA'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToPdfARequest($name, $out_path, $type, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling putPdfInStorageToPdfA'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToPptx
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToPptx($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToPptxWithHttpInfo($name, $out_path, $separate_images, $slides_as_images, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToPptxWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToPptxWithHttpInfo($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToPptxRequest($name, $out_path, $separate_images, $slides_as_images, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToPptxAsync
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPptxAsync($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        return $this->putPdfInStorageToPptxAsyncWithHttpInfo($name, $out_path, $separate_images, $slides_as_images, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToPptxAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPptxAsyncWithHttpInfo($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToPptxRequest($name, $out_path, $separate_images, $slides_as_images, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToPptx'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToPptxRequest($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToPptx'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToPptx'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pptx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($separate_images !== null) {
            $queryParams['separateImages'] = ObjectSerializer::toQueryValue($separate_images);
        }
        // query params
        if ($slides_as_images !== null) {
            $queryParams['slidesAsImages'] = ObjectSerializer::toQueryValue($slides_as_images);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToSvg
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToSvg($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToSvgWithHttpInfo($name, $out_path, $compress_output_to_zip_archive, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToSvgWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToSvgWithHttpInfo($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToSvgRequest($name, $out_path, $compress_output_to_zip_archive, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToSvgAsync
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToSvgAsync($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        return $this->putPdfInStorageToSvgAsyncWithHttpInfo($name, $out_path, $compress_output_to_zip_archive, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToSvgAsyncWithHttpInfo($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToSvgRequest($name, $out_path, $compress_output_to_zip_archive, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToSvg'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToSvgRequest($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToSvg'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToSvg'
            );
        }

        $resourcePath = '/pdf/{name}/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($compress_output_to_zip_archive !== null) {
            $queryParams['compressOutputToZipArchive'] = ObjectSerializer::toQueryValue($compress_output_to_zip_archive);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToTiff
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToTiff($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToTiffWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToTiffRequest($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToTiffAsync
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToTiffAsync($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        return $this->putPdfInStorageToTiffAsyncWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToTiffAsyncWithHttpInfo($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToTiffRequest($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToTiffRequest($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToTiff'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXls
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToXls($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToXlsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXlsAsync
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsAsync($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        return $this->putPdfInStorageToXlsAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXls'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXls'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXls'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXml
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToXml($name, $out_path, $folder = null)
    {
        list($response) = $this->putPdfInStorageToXmlWithHttpInfo($name, $out_path, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXmlWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToXmlRequest($name, $out_path, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXmlAsync
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXmlAsync($name, $out_path, $folder = null)
    {
        return $this->putPdfInStorageToXmlAsyncWithHttpInfo($name, $out_path, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXmlAsyncWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToXmlRequest($name, $out_path, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXmlRequest($name, $out_path, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXml'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXps
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPdfInStorageToXps($name, $out_path, $folder = null)
    {
        list($response) = $this->putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToXpsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToXpsRequest($name, $out_path, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXpsAsync
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXpsAsync($name, $out_path, $folder = null)
    {
        return $this->putPdfInStorageToXpsAsyncWithHttpInfo($name, $out_path, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXpsAsyncWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPdfInStorageToXpsRequest($name, $out_path, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXps'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXpsRequest($name, $out_path, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXps'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXps'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPrivileges
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPrivileges($name, $privileges = null, $folder = null)
    {
        list($response) = $this->putPrivilegesWithHttpInfo($name, $privileges, $folder);
        return $response;
    }

    /**
     * Operation putPrivilegesWithHttpInfo
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPrivilegesWithHttpInfo($name, $privileges = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPrivilegesRequest($name, $privileges, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPrivilegesAsync
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPrivilegesAsync($name, $privileges = null, $folder = null)
    {
        return $this->putPrivilegesAsyncWithHttpInfo($name, $privileges, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPrivilegesAsyncWithHttpInfo
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPrivilegesAsyncWithHttpInfo($name, $privileges = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPrivilegesRequest($name, $privileges, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPrivileges'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPrivilegesRequest($name, $privileges = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPrivileges'
            );
        }

        $resourcePath = '/pdf/{name}/privileges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($privileges)) {
            $_tempBody = $privileges;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPsInStorageToPdf
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPsInStorageToPdf($name, $src_path, $dst_folder = null)
    {
        list($response) = $this->putPsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder);
        return $response;
    }

    /**
     * Operation putPsInStorageToPdfWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPsInStorageToPdfRequest($name, $src_path, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPsInStorageToPdfAsync
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPsInStorageToPdfAsync($name, $src_path, $dst_folder = null)
    {
        return $this->putPsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPsInStorageToPdfRequest($name, $src_path, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPsInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPsInStorageToPdfRequest($name, $src_path, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPsInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putPsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/ps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSearchableDocument
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putSearchableDocument($name, $storage = null, $folder = null, $lang = null)
    {
        list($response) = $this->putSearchableDocumentWithHttpInfo($name, $storage, $folder, $lang);
        return $response;
    }

    /**
     * Operation putSearchableDocumentWithHttpInfo
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSearchableDocumentWithHttpInfo($name, $storage = null, $folder = null, $lang = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putSearchableDocumentRequest($name, $storage, $folder, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSearchableDocumentAsync
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSearchableDocumentAsync($name, $storage = null, $folder = null, $lang = null)
    {
        return $this->putSearchableDocumentAsyncWithHttpInfo($name, $storage, $folder, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSearchableDocumentAsyncWithHttpInfo
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSearchableDocumentAsyncWithHttpInfo($name, $storage = null, $folder = null, $lang = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putSearchableDocumentRequest($name, $storage, $folder, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSearchableDocument'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSearchableDocumentRequest($name, $storage = null, $folder = null, $lang = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSearchableDocument'
            );
        }

        $resourcePath = '/pdf/{name}/ocr';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSetProperty
     *
     * Add/update document property.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property property (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertyResponse
     */
    public function putSetProperty($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        list($response) = $this->putSetPropertyWithHttpInfo($name, $property_name, $property, $storage, $folder);
        return $response;
    }

    /**
     * Operation putSetPropertyWithHttpInfo
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSetPropertyWithHttpInfo($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->putSetPropertyRequest($name, $property_name, $property, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSetPropertyAsync
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSetPropertyAsync($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        return $this->putSetPropertyAsyncWithHttpInfo($name, $property_name, $property, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSetPropertyAsyncWithHttpInfo
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSetPropertyAsyncWithHttpInfo($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->putSetPropertyRequest($name, $property_name, $property, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSetProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSetPropertyRequest($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSetProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling putSetProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($property)) {
            $_tempBody = $property;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSvgInStorageToPdf
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putSvgInStorageToPdf($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        list($response) = $this->putSvgInStorageToPdfWithHttpInfo($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder);
        return $response;
    }

    /**
     * Operation putSvgInStorageToPdfWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSvgInStorageToPdfWithHttpInfo($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putSvgInStorageToPdfRequest($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSvgInStorageToPdfAsync
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSvgInStorageToPdfAsync($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        return $this->putSvgInStorageToPdfAsyncWithHttpInfo($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSvgInStorageToPdfAsyncWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSvgInStorageToPdfAsyncWithHttpInfo($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putSvgInStorageToPdfRequest($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSvgInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSvgInStorageToPdfRequest($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSvgInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putSvgInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($adjust_page_size !== null) {
            $queryParams['adjustPageSize'] = ObjectSerializer::toQueryValue($adjust_page_size);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUpdateField
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldResponse
     */
    public function putUpdateField($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        list($response) = $this->putUpdateFieldWithHttpInfo($name, $field_name, $field, $storage, $folder);
        return $response;
    }

    /**
     * Operation putUpdateFieldWithHttpInfo
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUpdateFieldWithHttpInfo($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->putUpdateFieldRequest($name, $field_name, $field, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUpdateFieldAsync
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldAsync($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        return $this->putUpdateFieldAsyncWithHttpInfo($name, $field_name, $field, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUpdateFieldAsyncWithHttpInfo
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldAsyncWithHttpInfo($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->putUpdateFieldRequest($name, $field_name, $field, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUpdateField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUpdateFieldRequest($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUpdateField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling putUpdateField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($field)) {
            $_tempBody = $field;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUpdateFields
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldsResponse
     */
    public function putUpdateFields($name, $fields = null, $storage = null, $folder = null)
    {
        list($response) = $this->putUpdateFieldsWithHttpInfo($name, $fields, $storage, $folder);
        return $response;
    }

    /**
     * Operation putUpdateFieldsWithHttpInfo
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUpdateFieldsWithHttpInfo($name, $fields = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->putUpdateFieldsRequest($name, $fields, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUpdateFieldsAsync
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldsAsync($name, $fields = null, $storage = null, $folder = null)
    {
        return $this->putUpdateFieldsAsyncWithHttpInfo($name, $fields, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUpdateFieldsAsyncWithHttpInfo
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldsAsyncWithHttpInfo($name, $fields = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->putUpdateFieldsRequest($name, $fields, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUpdateFields'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUpdateFieldsRequest($name, $fields = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUpdateFields'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($fields)) {
            $_tempBody = $fields;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putWebInStorageToPdf
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putWebInStorageToPdf($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        list($response) = $this->putWebInStorageToPdfWithHttpInfo($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder);
        return $response;
    }

    /**
     * Operation putWebInStorageToPdfWithHttpInfo
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putWebInStorageToPdfWithHttpInfo($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putWebInStorageToPdfRequest($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putWebInStorageToPdfAsync
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putWebInStorageToPdfAsync($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        return $this->putWebInStorageToPdfAsyncWithHttpInfo($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putWebInStorageToPdfAsyncWithHttpInfo
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putWebInStorageToPdfAsyncWithHttpInfo($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putWebInStorageToPdfRequest($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putWebInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putWebInStorageToPdfRequest($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putWebInStorageToPdf'
            );
        }
        // verify the required parameter 'url' is set
        if ($url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling putWebInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/web';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXfaPdfInRequestToAcroForm
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putXfaPdfInRequestToAcroForm($out_path, $file = null)
    {
        list($response) = $this->putXfaPdfInRequestToAcroFormWithHttpInfo($out_path, $file);
        return $response;
    }

    /**
     * Operation putXfaPdfInRequestToAcroFormWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXfaPdfInRequestToAcroFormWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXfaPdfInRequestToAcroFormRequest($out_path, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXfaPdfInRequestToAcroFormAsync
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInRequestToAcroFormAsync($out_path, $file = null)
    {
        return $this->putXfaPdfInRequestToAcroFormAsyncWithHttpInfo($out_path, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXfaPdfInRequestToAcroFormAsyncWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInRequestToAcroFormAsyncWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXfaPdfInRequestToAcroFormRequest($out_path, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXfaPdfInRequestToAcroForm'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXfaPdfInRequestToAcroFormRequest($out_path, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putXfaPdfInRequestToAcroForm'
            );
        }

        $resourcePath = '/pdf/convert/xfatoacroform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXfaPdfInStorageToAcroForm
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putXfaPdfInStorageToAcroForm($name, $out_path, $folder = null)
    {
        list($response) = $this->putXfaPdfInStorageToAcroFormWithHttpInfo($name, $out_path, $folder);
        return $response;
    }

    /**
     * Operation putXfaPdfInStorageToAcroFormWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXfaPdfInStorageToAcroFormWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXfaPdfInStorageToAcroFormRequest($name, $out_path, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXfaPdfInStorageToAcroFormAsync
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInStorageToAcroFormAsync($name, $out_path, $folder = null)
    {
        return $this->putXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $out_path, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXfaPdfInStorageToAcroFormAsyncWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXfaPdfInStorageToAcroFormRequest($name, $out_path, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXfaPdfInStorageToAcroForm'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXfaPdfInStorageToAcroFormRequest($name, $out_path, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXfaPdfInStorageToAcroForm'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putXfaPdfInStorageToAcroForm'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xfatoacroform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXmlInStorageToPdf
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putXmlInStorageToPdf($name, $src_path, $xsl_file_path = null, $dst_folder = null)
    {
        list($response) = $this->putXmlInStorageToPdfWithHttpInfo($name, $src_path, $xsl_file_path, $dst_folder);
        return $response;
    }

    /**
     * Operation putXmlInStorageToPdfWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXmlInStorageToPdfWithHttpInfo($name, $src_path, $xsl_file_path = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXmlInStorageToPdfRequest($name, $src_path, $xsl_file_path, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXmlInStorageToPdfAsync
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXmlInStorageToPdfAsync($name, $src_path, $xsl_file_path = null, $dst_folder = null)
    {
        return $this->putXmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $xsl_file_path, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $xsl_file_path = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXmlInStorageToPdfRequest($name, $src_path, $xsl_file_path, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXmlInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXmlInStorageToPdfRequest($name, $src_path, $xsl_file_path = null, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXmlInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putXmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($xsl_file_path !== null) {
            $queryParams['xslFilePath'] = ObjectSerializer::toQueryValue($xsl_file_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXpsInStorageToPdf
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putXpsInStorageToPdf($name, $src_path, $dst_folder = null)
    {
        list($response) = $this->putXpsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder);
        return $response;
    }

    /**
     * Operation putXpsInStorageToPdfWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXpsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXpsInStorageToPdfRequest($name, $src_path, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXpsInStorageToPdfAsync
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXpsInStorageToPdfAsync($name, $src_path, $dst_folder = null)
    {
        return $this->putXpsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXpsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXpsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXpsInStorageToPdfRequest($name, $src_path, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXpsInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXpsInStorageToPdfRequest($name, $src_path, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXpsInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putXpsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXslFoInStorageToPdf
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putXslFoInStorageToPdf($name, $src_path, $dst_folder = null)
    {
        list($response) = $this->putXslFoInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder);
        return $response;
    }

    /**
     * Operation putXslFoInStorageToPdfWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXslFoInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXslFoInStorageToPdfRequest($name, $src_path, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXslFoInStorageToPdfAsync
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXslFoInStorageToPdfAsync($name, $src_path, $dst_folder = null)
    {
        return $this->putXslFoInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXslFoInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXslFoInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putXslFoInStorageToPdfRequest($name, $src_path, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXslFoInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXslFoInStorageToPdfRequest($name, $src_path, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXslFoInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putXslFoInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/xslfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }
        
        //PDFCLOUD-418
        $options['connect_timeout'] = 5 * 60;
        
        return $options;
    }

    //ASPOSE_PDF_CLOUD
    /*
     * Gets a request token from server
     */
    private function _requestToken()
    {
        $requestUrl = $this->config->getHost() . "/oauth2/token";
        $requestUrl = str_replace($this->config->getBasePath(), '', $requestUrl);
        $postData = "grant_type=client_credentials" . "&client_id=" . $this->config->getAppSid() . "&client_secret=" . $this->config->getAppKey();
        $response = $this->client->send(new Request('POST', $requestUrl, [], $postData));
        $result = json_decode($response->getBody()->getContents(), true);
        $this->config->setAccessToken($result["access_token"]);
        $this->config->setRefreshToken($result["refresh_token"]);
    }
    /*
     * Refresh token
     */
    private function _refreshToken()
    {
        $requestUrl = $this->config->getHost() . "/oauth2/token";
        $requestUrl = str_replace($this->config->getBasePath(), '', $requestUrl);
        $postData = "grant_type=refresh_token&refresh_token=" . $this->config->getRefreshToken();
        $response = $this->client->send(new Request('POST', $requestUrl, [], $postData));
        $result = json_decode($response->getBody()->getContents(), true);
        $this->config->setAccessToken($result["access_token"]);
        $this->config->setRefreshToken($result["refresh_token"]);
    }
    //ASPOSE_PDF_CLOUD
}
