<?php
/**
 * PdfApi
 * PHP version 5
 *
 * @category Class
 * @package  Aspose\PDF
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 *
 *   Copyright (c) 2018 Aspose.Pdf for Cloud
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Aspose\PDF\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Aspose\PDF\ApiException;
use Aspose\PDF\Configuration;
use Aspose\PDF\HeaderSelector;
use Aspose\PDF\ObjectSerializer;

/**
 * PdfApi Class Doc Comment
 *
 * @category Class
 * @package  Aspose\PDF
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PdfApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deletePage
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function deletePage($name, $page_number, $storage = null, $folder = null)
    {
        list($response) = $this->deletePageWithHttpInfo($name, $page_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation deletePageWithHttpInfo
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePageRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageAsync
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageAsyncWithHttpInfo
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePageRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProperties
     *
     * Delete custom document properties.
     *
     * @param  string $name name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function deleteProperties($name, $storage = null, $folder = null)
    {
        list($response) = $this->deletePropertiesWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation deletePropertiesWithHttpInfo
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePropertiesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePropertiesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePropertiesAsync
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertiesAsync($name, $storage = null, $folder = null)
    {
        return $this->deletePropertiesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePropertiesAsyncWithHttpInfo
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertiesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePropertiesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProperties'
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePropertiesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteProperties'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProperty
     *
     * Delete document property.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function deleteProperty($name, $property_name, $storage = null, $folder = null)
    {
        list($response) = $this->deletePropertyWithHttpInfo($name, $property_name, $storage, $folder);
        return $response;
    }

    /**
     * Operation deletePropertyWithHttpInfo
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePropertyWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePropertyRequest($name, $property_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePropertyAsync
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertyAsync($name, $property_name, $storage = null, $folder = null)
    {
        return $this->deletePropertyAsyncWithHttpInfo($name, $property_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePropertyAsyncWithHttpInfo
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertyAsyncWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->deletePropertyRequest($name, $property_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePropertyRequest($name, $property_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling deleteProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocument
     *
     * Read common document info or convert to some format if the format specified.
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocument($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        list($response) = $this->getDocumentWithHttpInfo($name, $format, $storage, $folder, $out_path);
        return $response;
    }

    /**
     * Operation getDocumentWithHttpInfo
     *
     * Read common document info or convert to some format if the format specified.
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentWithHttpInfo($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentRequest($name, $format, $storage, $folder, $out_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAsync
     *
     * Read common document info or convert to some format if the format specified.
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsync($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        return $this->getDocumentAsyncWithHttpInfo($name, $format, $storage, $folder, $out_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAsyncWithHttpInfo
     *
     * Read common document info or convert to some format if the format specified.
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsyncWithHttpInfo($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentRequest($name, $format, $storage, $folder, $out_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocument'
     *
     * @param  string $name The document name. (required)
     * @param  string $format The format to convert. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $out_path Path to save result (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentRequest($name, $format = null, $storage = null, $folder = null, $out_path = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocument'
            );
        }

        $resourcePath = '/pdf/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAttachmentByIndex
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AttachmentResponse
     */
    public function getDocumentAttachmentByIndex($name, $attachment_index, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentAttachmentByIndexWithHttpInfo
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AttachmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentResponse';
        $request = $this->getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AttachmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAttachmentByIndexAsync
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentByIndexAsync($name, $attachment_index, $storage = null, $folder = null)
    {
        return $this->getDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAttachmentByIndexAsyncWithHttpInfo
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentResponse';
        $request = $this->getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAttachmentByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAttachmentByIndex'
            );
        }
        // verify the required parameter 'attachment_index' is set
        if ($attachment_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_index when calling getDocumentAttachmentByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/attachments/{attachmentIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($attachment_index !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentIndex' . '}',
                ObjectSerializer::toPathValue($attachment_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAttachments
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AttachmentsResponse
     */
    public function getDocumentAttachments($name, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentAttachmentsWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentAttachmentsWithHttpInfo
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AttachmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAttachmentsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentsResponse';
        $request = $this->getDocumentAttachmentsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AttachmentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAttachmentsAsync
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentAttachmentsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAttachmentsAsyncWithHttpInfo
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentsResponse';
        $request = $this->getDocumentAttachmentsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAttachments'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAttachmentsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAttachments'
            );
        }

        $resourcePath = '/pdf/{name}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentBookmarks
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentBookmarks($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentBookmarksWithHttpInfo($name, $bookmark_path, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentBookmarksWithHttpInfo
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentBookmarksWithHttpInfo($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentBookmarksRequest($name, $bookmark_path, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentBookmarksAsync
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentBookmarksAsync($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        return $this->getDocumentBookmarksAsyncWithHttpInfo($name, $bookmark_path, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentBookmarksAsyncWithHttpInfo
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentBookmarksAsyncWithHttpInfo($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentBookmarksRequest($name, $bookmark_path, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentBookmarks'
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentBookmarksRequest($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentBookmarks'
            );
        }

        $resourcePath = '/pdf/{name}/bookmarks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($bookmark_path !== null) {
            $queryParams['bookmarkPath'] = ObjectSerializer::toQueryValue($bookmark_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentProperties
     *
     * Read document properties.
     *
     * @param  string $name name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertiesResponse
     */
    public function getDocumentProperties($name, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentPropertiesWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentPropertiesWithHttpInfo
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertiesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPropertiesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertiesResponse';
        $request = $this->getDocumentPropertiesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertiesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPropertiesAsync
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPropertiesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPropertiesAsyncWithHttpInfo
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertiesResponse';
        $request = $this->getDocumentPropertiesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentProperties'
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPropertiesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentProperties'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentProperty
     *
     * Read document property by name.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertyResponse
     */
    public function getDocumentProperty($name, $property_name, $storage = null, $folder = null)
    {
        list($response) = $this->getDocumentPropertyWithHttpInfo($name, $property_name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDocumentPropertyWithHttpInfo
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPropertyWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->getDocumentPropertyRequest($name, $property_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPropertyAsync
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyAsync($name, $property_name, $storage = null, $folder = null)
    {
        return $this->getDocumentPropertyAsyncWithHttpInfo($name, $property_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPropertyAsyncWithHttpInfo
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyAsyncWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->getDocumentPropertyRequest($name, $property_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPropertyRequest($name, $property_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling getDocumentProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownload
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDownload($path, $version_id = null, $storage = null)
    {
        list($response) = $this->getDownloadWithHttpInfo($path, $version_id, $storage);
        return $response;
    }

    /**
     * Operation getDownloadWithHttpInfo
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadRequest($path, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadAsync
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadAsync($path, $version_id = null, $storage = null)
    {
        return $this->getDownloadAsyncWithHttpInfo($path, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadAsyncWithHttpInfo
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadAsyncWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadRequest($path, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownload'
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadRequest($path, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getDownload'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndex
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDownloadDocumentAttachmentByIndex($name, $attachment_index, $storage = null, $folder = null)
    {
        list($response) = $this->getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
        return $response;
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexWithHttpInfo
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexAsync
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadDocumentAttachmentByIndexAsync($name, $attachment_index, $storage = null, $folder = null)
    {
        return $this->getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadDocumentAttachmentByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDownloadDocumentAttachmentByIndex'
            );
        }
        // verify the required parameter 'attachment_index' is set
        if ($attachment_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_index when calling getDownloadDocumentAttachmentByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/attachments/{attachmentIndex}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($attachment_index !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentIndex' . '}',
                ObjectSerializer::toPathValue($attachment_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getField
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldResponse
     */
    public function getField($name, $field_name, $storage = null, $folder = null)
    {
        list($response) = $this->getFieldWithHttpInfo($name, $field_name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFieldWithHttpInfo
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->getFieldRequest($name, $field_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldAsync
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsync($name, $field_name, $storage = null, $folder = null)
    {
        return $this->getFieldAsyncWithHttpInfo($name, $field_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldAsyncWithHttpInfo
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsyncWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->getFieldRequest($name, $field_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFieldRequest($name, $field_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFields
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldsResponse
     */
    public function getFields($name, $storage = null, $folder = null)
    {
        list($response) = $this->getFieldsWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFieldsWithHttpInfo
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->getFieldsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldsAsync
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsync($name, $storage = null, $folder = null)
    {
        return $this->getFieldsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldsAsyncWithHttpInfo
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->getFieldsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFields'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFieldsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFields'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFragment
     *
     * Read page fragment.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getFragment($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getFragmentWithHttpInfo($name, $page_number, $fragment_number, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFragmentWithHttpInfo
     *
     * Read page fragment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFragmentWithHttpInfo($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getFragmentRequest($name, $page_number, $fragment_number, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFragmentAsync
     *
     * Read page fragment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentAsync($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getFragmentAsyncWithHttpInfo($name, $page_number, $fragment_number, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFragmentAsyncWithHttpInfo
     *
     * Read page fragment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentAsyncWithHttpInfo($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getFragmentRequest($name, $page_number, $fragment_number, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFragment'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFragmentRequest($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFragment'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getFragment'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getFragment'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFragmentTextFormat
     *
     * Read page fragment text format.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextFormatResponse
     */
    public function getFragmentTextFormat($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        list($response) = $this->getFragmentTextFormatWithHttpInfo($name, $page_number, $fragment_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFragmentTextFormatWithHttpInfo
     *
     * Read page fragment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFragmentTextFormatWithHttpInfo($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextFormatResponse';
        $request = $this->getFragmentTextFormatRequest($name, $page_number, $fragment_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextFormatResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFragmentTextFormatAsync
     *
     * Read page fragment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentTextFormatAsync($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        return $this->getFragmentTextFormatAsyncWithHttpInfo($name, $page_number, $fragment_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFragmentTextFormatAsyncWithHttpInfo
     *
     * Read page fragment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentTextFormatAsyncWithHttpInfo($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextFormatResponse';
        $request = $this->getFragmentTextFormatRequest($name, $page_number, $fragment_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFragmentTextFormat'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFragmentTextFormatRequest($name, $page_number, $fragment_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFragmentTextFormat'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getFragmentTextFormat'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getFragmentTextFormat'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/textFormat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFragments
     *
     * Read page fragments.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getFragments($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getFragmentsWithHttpInfo($name, $page_number, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getFragmentsWithHttpInfo
     *
     * Read page fragments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFragmentsWithHttpInfo($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getFragmentsRequest($name, $page_number, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFragmentsAsync
     *
     * Read page fragments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentsAsync($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getFragmentsAsyncWithHttpInfo($name, $page_number, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFragmentsAsyncWithHttpInfo
     *
     * Read page fragments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFragmentsAsyncWithHttpInfo($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getFragmentsRequest($name, $page_number, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFragments'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFragmentsRequest($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFragments'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getFragments'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImage
     *
     * Extract document image in format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImage($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        list($response) = $this->getImageWithHttpInfo($name, $page_number, $image_number, $format, $width, $height, $storage, $folder);
        return $response;
    }

    /**
     * Operation getImageWithHttpInfo
     *
     * Extract document image in format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageWithHttpInfo($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageRequest($name, $page_number, $image_number, $format, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageAsync
     *
     * Extract document image in format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageAsync($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        return $this->getImageAsyncWithHttpInfo($name, $page_number, $image_number, $format, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageAsyncWithHttpInfo
     *
     * Extract document image in format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageAsyncWithHttpInfo($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageRequest($name, $page_number, $image_number, $format, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image format. (required)
     * @param  string $format Image format to convert, if not specified the common image data is read. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageRequest($name, $page_number, $image_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getImage'
            );
        }
        // verify the required parameter 'image_number' is set
        if ($image_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_number when calling getImage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/{imageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($image_number !== null) {
            $resourcePath = str_replace(
                '{' . 'imageNumber' . '}',
                ObjectSerializer::toPathValue($image_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImages
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImagesResponse
     */
    public function getImages($name, $page_number, $storage = null, $folder = null)
    {
        list($response) = $this->getImagesWithHttpInfo($name, $page_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getImagesWithHttpInfo
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImagesWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImagesResponse';
        $request = $this->getImagesRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImagesAsync
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getImagesAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImagesAsyncWithHttpInfo
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImagesResponse';
        $request = $this->getImagesRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImages'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImagesRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImages'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getImages'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPage
     *
     * Convert document page to format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPage($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        list($response) = $this->getPageWithHttpInfo($name, $page_number, $format, $width, $height, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageWithHttpInfo
     *
     * Convert document page to format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageWithHttpInfo($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageRequest($name, $page_number, $format, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAsync
     *
     * Convert document page to format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAsync($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        return $this->getPageAsyncWithHttpInfo($name, $page_number, $format, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAsyncWithHttpInfo
     *
     * Convert document page to format specified.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAsyncWithHttpInfo($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageRequest($name, $page_number, $format, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $format The format to convert if specified. (optional)
     * @param  int $width The converted image width. (optional, default to 0)
     * @param  int $height The converted image height. (optional, default to 0)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageRequest($name, $page_number, $format = null, $width = '0', $height = '0', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageAnnotation
     *
     * Read document page annotation by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AnnotationResponse
     */
    public function getPageAnnotation($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        list($response) = $this->getPageAnnotationWithHttpInfo($name, $page_number, $annotation_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageAnnotationWithHttpInfo
     *
     * Read document page annotation by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageAnnotationWithHttpInfo($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationResponse';
        $request = $this->getPageAnnotationRequest($name, $page_number, $annotation_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAnnotationAsync
     *
     * Read document page annotation by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationAsync($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        return $this->getPageAnnotationAsyncWithHttpInfo($name, $page_number, $annotation_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAnnotationAsyncWithHttpInfo
     *
     * Read document page annotation by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationAsyncWithHttpInfo($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationResponse';
        $request = $this->getPageAnnotationRequest($name, $page_number, $annotation_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $annotation_number The annotation number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageAnnotationRequest($name, $page_number, $annotation_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageAnnotation'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageAnnotation'
            );
        }
        // verify the required parameter 'annotation_number' is set
        if ($annotation_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_number when calling getPageAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/{annotationNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($annotation_number !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationNumber' . '}',
                ObjectSerializer::toPathValue($annotation_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageAnnotations
     *
     * Read documant page annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AnnotationsResponse
     */
    public function getPageAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        list($response) = $this->getPageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageAnnotationsWithHttpInfo
     *
     * Read documant page annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsResponse';
        $request = $this->getPageAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAnnotationsAsync
     *
     * Read documant page annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAnnotationsAsyncWithHttpInfo
     *
     * Read documant page annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsResponse';
        $request = $this->getPageAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLinkAnnotationByIndex
     *
     * Read document page link annotation by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationResponse
     */
    public function getPageLinkAnnotationByIndex($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        list($response) = $this->getPageLinkAnnotationByIndexWithHttpInfo($name, $page_number, $link_index, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageLinkAnnotationByIndexWithHttpInfo
     *
     * Read document page link annotation by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLinkAnnotationByIndexWithHttpInfo($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getPageLinkAnnotationByIndexRequest($name, $page_number, $link_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLinkAnnotationByIndexAsync
     *
     * Read document page link annotation by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationByIndexAsync($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        return $this->getPageLinkAnnotationByIndexAsyncWithHttpInfo($name, $page_number, $link_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLinkAnnotationByIndexAsyncWithHttpInfo
     *
     * Read document page link annotation by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationByIndexAsyncWithHttpInfo($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getPageLinkAnnotationByIndexRequest($name, $page_number, $link_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLinkAnnotationByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $link_index The link index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLinkAnnotationByIndexRequest($name, $page_number, $link_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLinkAnnotationByIndex'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLinkAnnotationByIndex'
            );
        }
        // verify the required parameter 'link_index' is set
        if ($link_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_index when calling getPageLinkAnnotationByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links/{linkIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($link_index !== null) {
            $resourcePath = str_replace(
                '{' . 'linkIndex' . '}',
                ObjectSerializer::toPathValue($link_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLinkAnnotations
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationsResponse
     */
    public function getPageLinkAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        list($response) = $this->getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageLinkAnnotationsWithHttpInfo
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationsResponse';
        $request = $this->getPageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLinkAnnotationsAsync
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLinkAnnotationsAsyncWithHttpInfo
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationsResponse';
        $request = $this->getPageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLinkAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLinkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageText
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x x (required)
     * @param  int $y y (required)
     * @param  int $width width (required)
     * @param  int $height height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextRectsResponse
     */
    public function getPageText($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        list($response) = $this->getPageTextWithHttpInfo($name, $page_number, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);
        return $response;
    }

    /**
     * Operation getPageTextWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextRectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageTextWithHttpInfo($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getPageTextRequest($name, $page_number, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextRectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageTextAsync
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAsync($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        return $this->getPageTextAsyncWithHttpInfo($name, $page_number, $x, $y, $width, $height, $format, $regex, $split_rects, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageTextAsyncWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAsyncWithHttpInfo($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getPageTextRequest($name, $page_number, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageText'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageTextRequest($name, $page_number, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageText'
            );
        }
        // verify the required parameter 'x' is set
        if ($x === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x when calling getPageText'
            );
        }
        // verify the required parameter 'y' is set
        if ($y === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $y when calling getPageText'
            );
        }
        // verify the required parameter 'width' is set
        if ($width === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $width when calling getPageText'
            );
        }
        // verify the required parameter 'height' is set
        if ($height === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $height when calling getPageText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($format)) {
            $format = ObjectSerializer::serializeCollection($format, 'multi', true);
        }
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($regex !== null) {
            $queryParams['regex'] = ObjectSerializer::toQueryValue($regex);
        }
        // query params
        if ($x !== null) {
            $queryParams['X'] = ObjectSerializer::toQueryValue($x);
        }
        // query params
        if ($y !== null) {
            $queryParams['Y'] = ObjectSerializer::toQueryValue($y);
        }
        // query params
        if ($width !== null) {
            $queryParams['Width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['Height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($split_rects !== null) {
            $queryParams['splitRects'] = ObjectSerializer::toQueryValue($split_rects);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageTextItems
     *
     * Read page text items.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getPageTextItems($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getPageTextItemsWithHttpInfo($name, $page_number, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPageTextItemsWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageTextItemsWithHttpInfo($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getPageTextItemsRequest($name, $page_number, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageTextItemsAsync
     *
     * Read page text items.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextItemsAsync($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getPageTextItemsAsyncWithHttpInfo($name, $page_number, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageTextItemsAsyncWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextItemsAsyncWithHttpInfo($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getPageTextItemsRequest($name, $page_number, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageTextItems'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageTextItemsRequest($name, $page_number, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageTextItems'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageTextItems'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/textItems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPages
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPagesResponse
     */
    public function getPages($name, $storage = null, $folder = null)
    {
        list($response) = $this->getPagesWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getPagesWithHttpInfo
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->getPagesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagesAsync
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesAsync($name, $storage = null, $folder = null)
    {
        return $this->getPagesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagesAsyncWithHttpInfo
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->getPagesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPages'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPages'
            );
        }

        $resourcePath = '/pdf/{name}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToDoc
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToDoc($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToDocWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToDocRequest($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToDocAsync
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToDocAsync($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        return $this->getPdfInStorageToDocAsyncWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToDocAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToDocAsyncWithHttpInfo($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToDocRequest($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToDoc'
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToDocRequest($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToDoc'
            );
        }

        $resourcePath = '/pdf/{name}/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToPdfA
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToPdfA($name, $type, $folder = null)
    {
        list($response) = $this->getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToPdfAWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPdfARequest($name, $type, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToPdfAAsync
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPdfAAsync($name, $type, $folder = null)
    {
        return $this->getPdfInStorageToPdfAAsyncWithHttpInfo($name, $type, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPdfAAsyncWithHttpInfo($name, $type, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPdfARequest($name, $type, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToPdfA'
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToPdfARequest($name, $type, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getPdfInStorageToPdfA'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToSvg
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToSvg($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToSvgWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToSvgAsync
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToSvgAsync($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        return $this->getPdfInStorageToSvgAsyncWithHttpInfo($name, $compress_output_to_zip_archive, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToSvgAsyncWithHttpInfo($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToSvg'
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToSvg'
            );
        }

        $resourcePath = '/pdf/{name}/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($compress_output_to_zip_archive !== null) {
            $queryParams['compressOutputToZipArchive'] = ObjectSerializer::toQueryValue($compress_output_to_zip_archive);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToTiff
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToTiff($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToTiffWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToTiffWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToTiffWithHttpInfo($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToTiffRequest($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToTiffAsync
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToTiffAsync($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        return $this->getPdfInStorageToTiffAsyncWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToTiffAsyncWithHttpInfo($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToTiffRequest($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToTiffRequest($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXls
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXls($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        list($response) = $this->getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToXlsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXlsAsync
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsAsync($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        return $this->getPdfInStorageToXlsAsyncWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsAsyncWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXls'
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXls'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXps
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXps($name, $folder = null)
    {
        list($response) = $this->getPdfInStorageToXpsWithHttpInfo($name, $folder);
        return $response;
    }

    /**
     * Operation getPdfInStorageToXpsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXpsWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXpsRequest($name, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXpsAsync
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXpsAsync($name, $folder = null)
    {
        return $this->getPdfInStorageToXpsAsyncWithHttpInfo($name, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXpsAsyncWithHttpInfo($name, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXpsRequest($name, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXps'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXpsRequest($name, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXps'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSegment
     *
     * Read segment.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  int $segment_number segment_number (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemResponse
     */
    public function getSegment($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        list($response) = $this->getSegmentWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getSegmentWithHttpInfo
     *
     * Read segment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSegmentWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemResponse';
        $request = $this->getSegmentRequest($name, $page_number, $fragment_number, $segment_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSegmentAsync
     *
     * Read segment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentAsync($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        return $this->getSegmentAsyncWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSegmentAsyncWithHttpInfo
     *
     * Read segment.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentAsyncWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemResponse';
        $request = $this->getSegmentRequest($name, $page_number, $fragment_number, $segment_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSegment'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSegmentRequest($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSegment'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getSegment'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getSegment'
            );
        }
        // verify the required parameter 'segment_number' is set
        if ($segment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_number when calling getSegment'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/segments/{segmentNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }
        // path params
        if ($segment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentNumber' . '}',
                ObjectSerializer::toPathValue($segment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSegmentTextFormat
     *
     * Read segment text format.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  int $segment_number segment_number (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextFormatResponse
     */
    public function getSegmentTextFormat($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        list($response) = $this->getSegmentTextFormatWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage, $folder);
        return $response;
    }

    /**
     * Operation getSegmentTextFormatWithHttpInfo
     *
     * Read segment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSegmentTextFormatWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextFormatResponse';
        $request = $this->getSegmentTextFormatRequest($name, $page_number, $fragment_number, $segment_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextFormatResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSegmentTextFormatAsync
     *
     * Read segment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentTextFormatAsync($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        return $this->getSegmentTextFormatAsyncWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSegmentTextFormatAsyncWithHttpInfo
     *
     * Read segment text format.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentTextFormatAsyncWithHttpInfo($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextFormatResponse';
        $request = $this->getSegmentTextFormatRequest($name, $page_number, $fragment_number, $segment_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSegmentTextFormat'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  int $segment_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSegmentTextFormatRequest($name, $page_number, $fragment_number, $segment_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSegmentTextFormat'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getSegmentTextFormat'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getSegmentTextFormat'
            );
        }
        // verify the required parameter 'segment_number' is set
        if ($segment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_number when calling getSegmentTextFormat'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/segments/{segmentNumber}/textformat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }
        // path params
        if ($segment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentNumber' . '}',
                ObjectSerializer::toPathValue($segment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSegments
     *
     * Read fragment segments.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  int $fragment_number fragment_number (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getSegments($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getSegmentsWithHttpInfo($name, $page_number, $fragment_number, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getSegmentsWithHttpInfo
     *
     * Read fragment segments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSegmentsWithHttpInfo($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getSegmentsRequest($name, $page_number, $fragment_number, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSegmentsAsync
     *
     * Read fragment segments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentsAsync($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getSegmentsAsyncWithHttpInfo($name, $page_number, $fragment_number, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSegmentsAsyncWithHttpInfo
     *
     * Read fragment segments.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSegmentsAsyncWithHttpInfo($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getSegmentsRequest($name, $page_number, $fragment_number, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSegments'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  int $fragment_number (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSegmentsRequest($name, $page_number, $fragment_number, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSegments'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getSegments'
            );
        }
        // verify the required parameter 'fragment_number' is set
        if ($fragment_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fragment_number when calling getSegments'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/fragments/{fragmentNumber}/segments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($fragment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'fragmentNumber' . '}',
                ObjectSerializer::toPathValue($fragment_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getText
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  int $x x (required)
     * @param  int $y y (required)
     * @param  int $width width (required)
     * @param  int $height height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextRectsResponse
     */
    public function getText($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        list($response) = $this->getTextWithHttpInfo($name, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);
        return $response;
    }

    /**
     * Operation getTextWithHttpInfo
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextRectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTextWithHttpInfo($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getTextRequest($name, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextRectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTextAsync
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAsync($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        return $this->getTextAsyncWithHttpInfo($name, $x, $y, $width, $height, $format, $regex, $split_rects, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTextAsyncWithHttpInfo
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAsyncWithHttpInfo($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getTextRequest($name, $x, $y, $width, $height, $format, $regex, $split_rects, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getText'
     *
     * @param  string $name The document name. (required)
     * @param  int $x (required)
     * @param  int $y (required)
     * @param  int $width (required)
     * @param  int $height (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTextRequest($name, $x, $y, $width, $height, $format = null, $regex = null, $split_rects = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getText'
            );
        }
        // verify the required parameter 'x' is set
        if ($x === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x when calling getText'
            );
        }
        // verify the required parameter 'y' is set
        if ($y === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $y when calling getText'
            );
        }
        // verify the required parameter 'width' is set
        if ($width === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $width when calling getText'
            );
        }
        // verify the required parameter 'height' is set
        if ($height === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $height when calling getText'
            );
        }

        $resourcePath = '/pdf/{name}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($format)) {
            $format = ObjectSerializer::serializeCollection($format, 'multi', true);
        }
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($regex !== null) {
            $queryParams['regex'] = ObjectSerializer::toQueryValue($regex);
        }
        // query params
        if ($x !== null) {
            $queryParams['X'] = ObjectSerializer::toQueryValue($x);
        }
        // query params
        if ($y !== null) {
            $queryParams['Y'] = ObjectSerializer::toQueryValue($y);
        }
        // query params
        if ($width !== null) {
            $queryParams['Width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['Height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($split_rects !== null) {
            $queryParams['splitRects'] = ObjectSerializer::toQueryValue($split_rects);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTextItems
     *
     * Read document text items.
     *
     * @param  string $name name (required)
     * @param  string $with_empty with_empty (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextItemsResponse
     */
    public function getTextItems($name, $with_empty = null, $storage = null, $folder = null)
    {
        list($response) = $this->getTextItemsWithHttpInfo($name, $with_empty, $storage, $folder);
        return $response;
    }

    /**
     * Operation getTextItemsWithHttpInfo
     *
     * Read document text items.
     *
     * @param  string $name (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextItemsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTextItemsWithHttpInfo($name, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getTextItemsRequest($name, $with_empty, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextItemsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTextItemsAsync
     *
     * Read document text items.
     *
     * @param  string $name (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextItemsAsync($name, $with_empty = null, $storage = null, $folder = null)
    {
        return $this->getTextItemsAsyncWithHttpInfo($name, $with_empty, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTextItemsAsyncWithHttpInfo
     *
     * Read document text items.
     *
     * @param  string $name (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextItemsAsyncWithHttpInfo($name, $with_empty = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextItemsResponse';
        $request = $this->getTextItemsRequest($name, $with_empty, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTextItems'
     *
     * @param  string $name (required)
     * @param  string $with_empty (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTextItemsRequest($name, $with_empty = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getTextItems'
            );
        }

        $resourcePath = '/pdf/{name}/textItems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_empty !== null) {
            $queryParams['withEmpty'] = ObjectSerializer::toQueryValue($with_empty);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWordsPerPage
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\WordCountResponse
     */
    public function getWordsPerPage($name, $storage = null, $folder = null)
    {
        list($response) = $this->getWordsPerPageWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation getWordsPerPageWithHttpInfo
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\WordCountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWordsPerPageWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\WordCountResponse';
        $request = $this->getWordsPerPageRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\WordCountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWordsPerPageAsync
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWordsPerPageAsync($name, $storage = null, $folder = null)
    {
        return $this->getWordsPerPageAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWordsPerPageAsyncWithHttpInfo
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWordsPerPageAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\WordCountResponse';
        $request = $this->getWordsPerPageRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWordsPerPage'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWordsPerPageRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getWordsPerPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/wordCount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAppendDocument
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function postAppendDocument($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        list($response) = $this->postAppendDocumentWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);
        return $response;
    }

    /**
     * Operation postAppendDocumentWithHttpInfo
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAppendDocumentWithHttpInfo($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->postAppendDocumentRequest($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAppendDocumentAsync
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAppendDocumentAsync($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        return $this->postAppendDocumentAsyncWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAppendDocumentAsyncWithHttpInfo
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAppendDocumentAsyncWithHttpInfo($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->postAppendDocumentRequest($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAppendDocument'
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAppendDocumentRequest($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postAppendDocument'
            );
        }

        $resourcePath = '/pdf/{name}/appendDocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($append_file !== null) {
            $queryParams['appendFile'] = ObjectSerializer::toQueryValue($append_file);
        }
        // query params
        if ($start_page !== null) {
            $queryParams['startPage'] = ObjectSerializer::toQueryValue($start_page);
        }
        // query params
        if ($end_page !== null) {
            $queryParams['endPage'] = ObjectSerializer::toQueryValue($end_page);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($append_document)) {
            $_tempBody = $append_document;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCreateField
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postCreateField($name, $page, $field = null, $storage = null, $folder = null)
    {
        list($response) = $this->postCreateFieldWithHttpInfo($name, $page, $field, $storage, $folder);
        return $response;
    }

    /**
     * Operation postCreateFieldWithHttpInfo
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCreateFieldWithHttpInfo($name, $page, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postCreateFieldRequest($name, $page, $field, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCreateFieldAsync
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCreateFieldAsync($name, $page, $field = null, $storage = null, $folder = null)
    {
        return $this->postCreateFieldAsyncWithHttpInfo($name, $page, $field, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCreateFieldAsyncWithHttpInfo
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCreateFieldAsyncWithHttpInfo($name, $page, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postCreateFieldRequest($name, $page, $field, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCreateField'
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postCreateFieldRequest($name, $page, $field = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postCreateField'
            );
        }
        // verify the required parameter 'page' is set
        if ($page === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling postCreateField'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($field)) {
            $_tempBody = $field;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentReplaceText
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace text_replace (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentTextReplaceResponse
     */
    public function postDocumentReplaceText($name, $text_replace, $storage = null, $folder = null)
    {
        list($response) = $this->postDocumentReplaceTextWithHttpInfo($name, $text_replace, $storage, $folder);
        return $response;
    }

    /**
     * Operation postDocumentReplaceTextWithHttpInfo
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentTextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentReplaceTextWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentTextReplaceResponse';
        $request = $this->postDocumentReplaceTextRequest($name, $text_replace, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentTextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentReplaceTextAsync
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentReplaceTextAsync($name, $text_replace, $storage = null, $folder = null)
    {
        return $this->postDocumentReplaceTextAsyncWithHttpInfo($name, $text_replace, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentReplaceTextAsyncWithHttpInfo
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentReplaceTextAsyncWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentTextReplaceResponse';
        $request = $this->postDocumentReplaceTextRequest($name, $text_replace, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentReplaceText'
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentReplaceTextRequest($name, $text_replace, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentReplaceText'
            );
        }
        // verify the required parameter 'text_replace' is set
        if ($text_replace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace when calling postDocumentReplaceText'
            );
        }

        $resourcePath = '/pdf/{name}/replaceText';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace)) {
            $_tempBody = $text_replace;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentReplaceTextList
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request text_replace_list_request (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentTextReplaceResponse
     */
    public function postDocumentReplaceTextList($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        list($response) = $this->postDocumentReplaceTextListWithHttpInfo($name, $text_replace_list_request, $storage, $folder);
        return $response;
    }

    /**
     * Operation postDocumentReplaceTextListWithHttpInfo
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentTextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentReplaceTextListWithHttpInfo($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentTextReplaceResponse';
        $request = $this->postDocumentReplaceTextListRequest($name, $text_replace_list_request, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentTextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentReplaceTextListAsync
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentReplaceTextListAsync($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        return $this->postDocumentReplaceTextListAsyncWithHttpInfo($name, $text_replace_list_request, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentReplaceTextListAsyncWithHttpInfo
     *
     * Document's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentReplaceTextListAsyncWithHttpInfo($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentTextReplaceResponse';
        $request = $this->postDocumentReplaceTextListRequest($name, $text_replace_list_request, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentReplaceTextList'
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentReplaceTextListRequest($name, $text_replace_list_request, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentReplaceTextList'
            );
        }
        // verify the required parameter 'text_replace_list_request' is set
        if ($text_replace_list_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace_list_request when calling postDocumentReplaceTextList'
            );
        }

        $resourcePath = '/pdf/{name}/replaceTextList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace_list_request)) {
            $_tempBody = $text_replace_list_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentTextReplace
     *
     * Document's replace text method.
     *
     * @param  string $name name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace text_replace (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextReplaceResponse
     */
    public function postDocumentTextReplace($name, $text_replace, $storage = null, $folder = null)
    {
        list($response) = $this->postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage, $folder);
        return $response;
    }

    /**
     * Operation postDocumentTextReplaceWithHttpInfo
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postDocumentTextReplaceRequest($name, $text_replace, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentTextReplaceAsync
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextReplaceAsync($name, $text_replace, $storage = null, $folder = null)
    {
        return $this->postDocumentTextReplaceAsyncWithHttpInfo($name, $text_replace, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentTextReplaceAsyncWithHttpInfo
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextReplaceAsyncWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postDocumentTextReplaceRequest($name, $text_replace, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentTextReplace'
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentTextReplaceRequest($name, $text_replace, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentTextReplace'
            );
        }
        // verify the required parameter 'text_replace' is set
        if ($text_replace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace when calling postDocumentTextReplace'
            );
        }

        $resourcePath = '/pdf/{name}/text/replace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace)) {
            $_tempBody = $text_replace;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postMovePage
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postMovePage($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        list($response) = $this->postMovePageWithHttpInfo($name, $page_number, $new_index, $storage, $folder);
        return $response;
    }

    /**
     * Operation postMovePageWithHttpInfo
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMovePageWithHttpInfo($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postMovePageRequest($name, $page_number, $new_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postMovePageAsync
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMovePageAsync($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        return $this->postMovePageAsyncWithHttpInfo($name, $page_number, $new_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postMovePageAsyncWithHttpInfo
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMovePageAsyncWithHttpInfo($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postMovePageRequest($name, $page_number, $new_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postMovePage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postMovePageRequest($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postMovePage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postMovePage'
            );
        }
        // verify the required parameter 'new_index' is set
        if ($new_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_index when calling postMovePage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/movePage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_index !== null) {
            $queryParams['newIndex'] = ObjectSerializer::toQueryValue($new_index);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postOptimizeDocument
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postOptimizeDocument($name, $options = null, $storage = null, $folder = null)
    {
        list($response) = $this->postOptimizeDocumentWithHttpInfo($name, $options, $storage, $folder);
        return $response;
    }

    /**
     * Operation postOptimizeDocumentWithHttpInfo
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postOptimizeDocumentWithHttpInfo($name, $options = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postOptimizeDocumentRequest($name, $options, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postOptimizeDocumentAsync
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOptimizeDocumentAsync($name, $options = null, $storage = null, $folder = null)
    {
        return $this->postOptimizeDocumentAsyncWithHttpInfo($name, $options, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postOptimizeDocumentAsyncWithHttpInfo
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOptimizeDocumentAsyncWithHttpInfo($name, $options = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postOptimizeDocumentRequest($name, $options, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postOptimizeDocument'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postOptimizeDocumentRequest($name, $options = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postOptimizeDocument'
            );
        }

        $resourcePath = '/pdf/{name}/optimize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($options)) {
            $_tempBody = $options;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageReplaceText
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace text_replace (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PageTextReplaceResponse
     */
    public function postPageReplaceText($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        list($response) = $this->postPageReplaceTextWithHttpInfo($name, $page_number, $text_replace, $storage, $folder);
        return $response;
    }

    /**
     * Operation postPageReplaceTextWithHttpInfo
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PageTextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageReplaceTextWithHttpInfo($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PageTextReplaceResponse';
        $request = $this->postPageReplaceTextRequest($name, $page_number, $text_replace, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PageTextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageReplaceTextAsync
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageReplaceTextAsync($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        return $this->postPageReplaceTextAsyncWithHttpInfo($name, $page_number, $text_replace, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageReplaceTextAsyncWithHttpInfo
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageReplaceTextAsyncWithHttpInfo($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PageTextReplaceResponse';
        $request = $this->postPageReplaceTextRequest($name, $page_number, $text_replace, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageReplaceText'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageReplaceTextRequest($name, $page_number, $text_replace, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageReplaceText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageReplaceText'
            );
        }
        // verify the required parameter 'text_replace' is set
        if ($text_replace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace when calling postPageReplaceText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/replaceText';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace)) {
            $_tempBody = $text_replace;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageReplaceTextList
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request text_replace_list_request (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PageTextReplaceResponse
     */
    public function postPageReplaceTextList($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        list($response) = $this->postPageReplaceTextListWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder);
        return $response;
    }

    /**
     * Operation postPageReplaceTextListWithHttpInfo
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PageTextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageReplaceTextListWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PageTextReplaceResponse';
        $request = $this->postPageReplaceTextListRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PageTextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageReplaceTextListAsync
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageReplaceTextListAsync($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        return $this->postPageReplaceTextListAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageReplaceTextListAsyncWithHttpInfo
     *
     * Page's replace text method. Deprecated
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageReplaceTextListAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PageTextReplaceResponse';
        $request = $this->postPageReplaceTextListRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageReplaceTextList'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageReplaceTextListRequest($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageReplaceTextList'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageReplaceTextList'
            );
        }
        // verify the required parameter 'text_replace_list_request' is set
        if ($text_replace_list_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace_list_request when calling postPageReplaceTextList'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/replaceTextList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace_list_request)) {
            $_tempBody = $text_replace_list_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageTextReplace
     *
     * Page's replace text method.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request text_replace_list_request (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextReplaceResponse
     */
    public function postPageTextReplace($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        list($response) = $this->postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder);
        return $response;
    }

    /**
     * Operation postPageTextReplaceWithHttpInfo
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageTextReplaceAsync
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextReplaceAsync($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        return $this->postPageTextReplaceAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageTextReplaceAsyncWithHttpInfo
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextReplaceAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageTextReplace'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageTextReplace'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageTextReplace'
            );
        }
        // verify the required parameter 'text_replace_list_request' is set
        if ($text_replace_list_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace_list_request when calling postPageTextReplace'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text/replace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace_list_request)) {
            $_tempBody = $text_replace_list_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postReplaceImage
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImageResponse
     */
    public function postReplaceImage($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        list($response) = $this->postReplaceImageWithHttpInfo($name, $page_number, $image_number, $image_file, $storage, $folder, $image);
        return $response;
    }

    /**
     * Operation postReplaceImageWithHttpInfo
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postReplaceImageWithHttpInfo($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->postReplaceImageRequest($name, $page_number, $image_number, $image_file, $storage, $folder, $image);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postReplaceImageAsync
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postReplaceImageAsync($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        return $this->postReplaceImageAsyncWithHttpInfo($name, $page_number, $image_number, $image_file, $storage, $folder, $image)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postReplaceImageAsyncWithHttpInfo
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postReplaceImageAsyncWithHttpInfo($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->postReplaceImageRequest($name, $page_number, $image_number, $image_file, $storage, $folder, $image);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postReplaceImage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $image_number The image number. (required)
     * @param  string $image_file Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postReplaceImageRequest($name, $page_number, $image_number, $image_file = null, $storage = null, $folder = null, $image = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postReplaceImage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postReplaceImage'
            );
        }
        // verify the required parameter 'image_number' is set
        if ($image_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_number when calling postReplaceImage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/{imageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_file !== null) {
            $queryParams['imageFile'] = ObjectSerializer::toQueryValue($image_file);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($image_number !== null) {
            $resourcePath = str_replace(
                '{' . 'imageNumber' . '}',
                ObjectSerializer::toPathValue($image_number),
                $resourcePath
            );
        }

        // form params
        if ($image !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($image);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['image'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['image'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSignDocument
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postSignDocument($name, $signature = null, $storage = null, $folder = null)
    {
        list($response) = $this->postSignDocumentWithHttpInfo($name, $signature, $storage, $folder);
        return $response;
    }

    /**
     * Operation postSignDocumentWithHttpInfo
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSignDocumentWithHttpInfo($name, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postSignDocumentRequest($name, $signature, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSignDocumentAsync
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignDocumentAsync($name, $signature = null, $storage = null, $folder = null)
    {
        return $this->postSignDocumentAsyncWithHttpInfo($name, $signature, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSignDocumentAsyncWithHttpInfo
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignDocumentAsyncWithHttpInfo($name, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postSignDocumentRequest($name, $signature, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSignDocument'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSignDocumentRequest($name, $signature = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSignDocument'
            );
        }

        $resourcePath = '/pdf/{name}/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($signature)) {
            $_tempBody = $signature;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSignPage
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function postSignPage($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        list($response) = $this->postSignPageWithHttpInfo($name, $page_number, $signature, $storage, $folder);
        return $response;
    }

    /**
     * Operation postSignPageWithHttpInfo
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSignPageWithHttpInfo($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postSignPageRequest($name, $page_number, $signature, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSignPageAsync
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignPageAsync($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        return $this->postSignPageAsyncWithHttpInfo($name, $page_number, $signature, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSignPageAsyncWithHttpInfo
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignPageAsyncWithHttpInfo($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->postSignPageRequest($name, $page_number, $signature, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSignPage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSignPageRequest($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSignPage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postSignPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($signature)) {
            $_tempBody = $signature;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSplitDocument
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SplitResultResponse
     */
    public function postSplitDocument($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        list($response) = $this->postSplitDocumentWithHttpInfo($name, $format, $from, $to, $storage, $folder);
        return $response;
    }

    /**
     * Operation postSplitDocumentWithHttpInfo
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SplitResultResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSplitDocumentWithHttpInfo($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SplitResultResponse';
        $request = $this->postSplitDocumentRequest($name, $format, $from, $to, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SplitResultResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSplitDocumentAsync
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSplitDocumentAsync($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        return $this->postSplitDocumentAsyncWithHttpInfo($name, $format, $from, $to, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSplitDocumentAsyncWithHttpInfo
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSplitDocumentAsyncWithHttpInfo($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SplitResultResponse';
        $request = $this->postSplitDocumentRequest($name, $format, $from, $to, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSplitDocument'
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSplitDocumentRequest($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSplitDocument'
            );
        }

        $resourcePath = '/pdf/{name}/split';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddNewPage
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPagesResponse
     */
    public function putAddNewPage($name, $storage = null, $folder = null)
    {
        list($response) = $this->putAddNewPageWithHttpInfo($name, $storage, $folder);
        return $response;
    }

    /**
     * Operation putAddNewPageWithHttpInfo
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddNewPageWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->putAddNewPageRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddNewPageAsync
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddNewPageAsync($name, $storage = null, $folder = null)
    {
        return $this->putAddNewPageAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddNewPageAsyncWithHttpInfo
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddNewPageAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->putAddNewPageRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddNewPage'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddNewPageRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddNewPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddParagraph
     *
     * Add text to PDF document page. Deprecated
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putAddParagraph($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        list($response) = $this->putAddParagraphWithHttpInfo($name, $page_number, $paragraph, $storage, $folder);
        return $response;
    }

    /**
     * Operation putAddParagraphWithHttpInfo
     *
     * Add text to PDF document page. Deprecated
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddParagraphWithHttpInfo($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putAddParagraphRequest($name, $page_number, $paragraph, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddParagraphAsync
     *
     * Add text to PDF document page. Deprecated
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddParagraphAsync($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        return $this->putAddParagraphAsyncWithHttpInfo($name, $page_number, $paragraph, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddParagraphAsyncWithHttpInfo
     *
     * Add text to PDF document page. Deprecated
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddParagraphAsyncWithHttpInfo($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putAddParagraphRequest($name, $page_number, $paragraph, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddParagraph'
     *
     * @param  string $name Name of the document to which text should be added. (required)
     * @param  int $page_number Number of page (starting with 1) to which text should be added. (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $storage File storage to be used. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddParagraphRequest($name, $page_number, $paragraph = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddParagraph'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putAddParagraph'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/paragraph';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($paragraph)) {
            $_tempBody = $paragraph;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddText
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putAddText($name, $page_number, $paragraph = null, $folder = null)
    {
        list($response) = $this->putAddTextWithHttpInfo($name, $page_number, $paragraph, $folder);
        return $response;
    }

    /**
     * Operation putAddTextWithHttpInfo
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddTextWithHttpInfo($name, $page_number, $paragraph = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putAddTextRequest($name, $page_number, $paragraph, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddTextAsync
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddTextAsync($name, $page_number, $paragraph = null, $folder = null)
    {
        return $this->putAddTextAsyncWithHttpInfo($name, $page_number, $paragraph, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddTextAsyncWithHttpInfo
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddTextAsyncWithHttpInfo($name, $page_number, $paragraph = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putAddTextRequest($name, $page_number, $paragraph, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddText'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddTextRequest($name, $page_number, $paragraph = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putAddText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($paragraph)) {
            $_tempBody = $paragraph;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putConvertDocument
     *
     * Convert document from request content to format specified.
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putConvertDocument($format = null, $url = null, $out_path = null, $file = null)
    {
        list($response) = $this->putConvertDocumentWithHttpInfo($format, $url, $out_path, $file);
        return $response;
    }

    /**
     * Operation putConvertDocumentWithHttpInfo
     *
     * Convert document from request content to format specified.
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putConvertDocumentWithHttpInfo($format = null, $url = null, $out_path = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putConvertDocumentRequest($format, $url, $out_path, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putConvertDocumentAsync
     *
     * Convert document from request content to format specified.
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putConvertDocumentAsync($format = null, $url = null, $out_path = null, $file = null)
    {
        return $this->putConvertDocumentAsyncWithHttpInfo($format, $url, $out_path, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putConvertDocumentAsyncWithHttpInfo
     *
     * Convert document from request content to format specified.
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putConvertDocumentAsyncWithHttpInfo($format = null, $url = null, $out_path = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putConvertDocumentRequest($format, $url, $out_path, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putConvertDocument'
     *
     * @param  string $format The format to convert. (optional)
     * @param  string $url (optional)
     * @param  string $out_path Path to save result (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putConvertDocumentRequest($format = null, $url = null, $out_path = null, $file = null)
    {

        $resourcePath = '/pdf/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreate
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putCreate($path, $file, $version_id = null, $storage = null)
    {
        list($response) = $this->putCreateWithHttpInfo($path, $file, $version_id, $storage);
        return $response;
    }

    /**
     * Operation putCreateWithHttpInfo
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateWithHttpInfo($path, $file, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putCreateRequest($path, $file, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateAsync
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateAsync($path, $file, $version_id = null, $storage = null)
    {
        return $this->putCreateAsyncWithHttpInfo($path, $file, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateAsyncWithHttpInfo
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateAsyncWithHttpInfo($path, $file, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putCreateRequest($path, $file, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreate'
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateRequest($path, $file, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling putCreate'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling putCreate'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreateDocument
     *
     * Create new document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function putCreateDocument($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        list($response) = $this->putCreateDocumentWithHttpInfo($name, $template_file, $data_file, $template_type, $storage, $folder, $url, $fit_size);
        return $response;
    }

    /**
     * Operation putCreateDocumentWithHttpInfo
     *
     * Create new document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateDocumentWithHttpInfo($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentRequest($name, $template_file, $data_file, $template_type, $storage, $folder, $url, $fit_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateDocumentAsync
     *
     * Create new document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentAsync($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        return $this->putCreateDocumentAsyncWithHttpInfo($name, $template_file, $data_file, $template_type, $storage, $folder, $url, $fit_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateDocumentAsyncWithHttpInfo
     *
     * Create new document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentAsyncWithHttpInfo($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentRequest($name, $template_file, $data_file, $template_type, $storage, $folder, $url, $fit_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreateDocument'
     *
     * @param  string $name The new document name. (required)
     * @param  string $template_file The template file server path if defined. (optional)
     * @param  string $data_file The data file path (for xml template only). (optional)
     * @param  string $template_type The template type, can be xml, html, bmp, jpg, png, tiff, emf, cgm, tex. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     * @param  string $url The url of web page if defined. (optional)
     * @param  bool $fit_size Draw a margin around content in resulting pdf. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateDocumentRequest($name, $template_file = null, $data_file = null, $template_type = null, $storage = null, $folder = null, $url = null, $fit_size = 'false')
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCreateDocument'
            );
        }

        $resourcePath = '/pdf/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($template_file !== null) {
            $queryParams['templateFile'] = ObjectSerializer::toQueryValue($template_file);
        }
        // query params
        if ($data_file !== null) {
            $queryParams['dataFile'] = ObjectSerializer::toQueryValue($data_file);
        }
        // query params
        if ($template_type !== null) {
            $queryParams['templateType'] = ObjectSerializer::toQueryValue($template_type);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($fit_size !== null) {
            $queryParams['fitSize'] = ObjectSerializer::toQueryValue($fit_size);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreateDocumentFromImages
     *
     * Create new document from images.
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function putCreateDocumentFromImages($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        list($response) = $this->putCreateDocumentFromImagesWithHttpInfo($name, $images, $ocr, $ocr_lang, $storage, $folder);
        return $response;
    }

    /**
     * Operation putCreateDocumentFromImagesWithHttpInfo
     *
     * Create new document from images.
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateDocumentFromImagesWithHttpInfo($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentFromImagesRequest($name, $images, $ocr, $ocr_lang, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateDocumentFromImagesAsync
     *
     * Create new document from images.
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentFromImagesAsync($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        return $this->putCreateDocumentFromImagesAsyncWithHttpInfo($name, $images, $ocr, $ocr_lang, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateDocumentFromImagesAsyncWithHttpInfo
     *
     * Create new document from images.
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentFromImagesAsyncWithHttpInfo($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentFromImagesRequest($name, $images, $ocr, $ocr_lang, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreateDocumentFromImages'
     *
     * @param  string $name The new document name. (required)
     * @param  \Aspose\PDF\Model\ImagesListRequest $images The images file paths set. (optional)
     * @param  bool $ocr To create OCR layer for image or not. (optional, default to false)
     * @param  string $ocr_lang The language which is defined for OCR engine. Default is eng. (optional, default to eng)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateDocumentFromImagesRequest($name, $images = null, $ocr = 'false', $ocr_lang = 'eng', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCreateDocumentFromImages'
            );
        }

        $resourcePath = '/pdf/{name}/fromimages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ocr !== null) {
            $queryParams['ocr'] = ObjectSerializer::toQueryValue($ocr);
        }
        // query params
        if ($ocr_lang !== null) {
            $queryParams['ocrLang'] = ObjectSerializer::toQueryValue($ocr_lang);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($images)) {
            $_tempBody = $images;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDocumentSaveAsTiff
     *
     * Save document as Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putDocumentSaveAsTiff($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        list($response) = $this->putDocumentSaveAsTiffWithHttpInfo($name, $export_options, $result_file, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $folder);
        return $response;
    }

    /**
     * Operation putDocumentSaveAsTiffWithHttpInfo
     *
     * Save document as Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDocumentSaveAsTiffWithHttpInfo($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putDocumentSaveAsTiffRequest($name, $export_options, $result_file, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDocumentSaveAsTiffAsync
     *
     * Save document as Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDocumentSaveAsTiffAsync($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        return $this->putDocumentSaveAsTiffAsyncWithHttpInfo($name, $export_options, $result_file, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDocumentSaveAsTiffAsyncWithHttpInfo
     *
     * Save document as Tiff image.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDocumentSaveAsTiffAsyncWithHttpInfo($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putDocumentSaveAsTiffRequest($name, $export_options, $result_file, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDocumentSaveAsTiff'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TiffExportOptions $export_options with tiff export options. (optional)
     * @param  string $result_file The resulting file. (optional)
     * @param  double $brightness The image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDocumentSaveAsTiffRequest($name, $export_options = null, $result_file = null, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putDocumentSaveAsTiff'
            );
        }

        $resourcePath = '/pdf/{name}/SaveAs/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($result_file !== null) {
            $queryParams['resultFile'] = ObjectSerializer::toQueryValue($result_file);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($export_options)) {
            $_tempBody = $export_options;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMergeDocuments
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function putMergeDocuments($name, $merge_documents = null, $storage = null, $folder = null)
    {
        list($response) = $this->putMergeDocumentsWithHttpInfo($name, $merge_documents, $storage, $folder);
        return $response;
    }

    /**
     * Operation putMergeDocumentsWithHttpInfo
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMergeDocumentsWithHttpInfo($name, $merge_documents = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putMergeDocumentsRequest($name, $merge_documents, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putMergeDocumentsAsync
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMergeDocumentsAsync($name, $merge_documents = null, $storage = null, $folder = null)
    {
        return $this->putMergeDocumentsAsyncWithHttpInfo($name, $merge_documents, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMergeDocumentsAsyncWithHttpInfo
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMergeDocumentsAsyncWithHttpInfo($name, $merge_documents = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putMergeDocumentsRequest($name, $merge_documents, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMergeDocuments'
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMergeDocumentsRequest($name, $merge_documents = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putMergeDocuments'
            );
        }

        $resourcePath = '/pdf/{name}/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($merge_documents)) {
            $_tempBody = $merge_documents;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageAddStamp
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putPageAddStamp($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        list($response) = $this->putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage, $folder);
        return $response;
    }

    /**
     * Operation putPageAddStampWithHttpInfo
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageAddStampRequest($name, $page_number, $stamp, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageAddStampAsync
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageAddStampAsync($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        return $this->putPageAddStampAsyncWithHttpInfo($name, $page_number, $stamp, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageAddStampAsyncWithHttpInfo
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageAddStampAsyncWithHttpInfo($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putPageAddStampRequest($name, $page_number, $stamp, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageAddStamp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageAddStampRequest($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageAddStamp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageAddStamp'
            );
        }
        // verify the required parameter 'stamp' is set
        if ($stamp === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamp when calling putPageAddStamp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/stamp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($stamp)) {
            $_tempBody = $stamp;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToDoc
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInRequestToDoc($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToDocWithHttpInfo
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToDocRequest($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToDocAsync
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToDocAsync($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        return $this->putPdfInRequestToDocAsyncWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToDocAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToDocAsyncWithHttpInfo($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToDocRequest($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToDoc'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToDocRequest($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToDoc'
            );
        }

        $resourcePath = '/pdf/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToPdfA
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInRequestToPdfA($out_path, $type, $file = null)
    {
        list($response) = $this->putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToPdfAWithHttpInfo
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToPdfARequest($out_path, $type, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToPdfAAsync
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPdfAAsync($out_path, $type, $file = null)
    {
        return $this->putPdfInRequestToPdfAAsyncWithHttpInfo($out_path, $type, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPdfAAsyncWithHttpInfo($out_path, $type, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToPdfARequest($out_path, $type, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToPdfA'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToPdfARequest($out_path, $type, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling putPdfInRequestToPdfA'
            );
        }

        $resourcePath = '/pdf/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToSvg
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInRequestToSvg($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToSvgWithHttpInfo($out_path, $compress_output_to_zip_archive, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToSvgWithHttpInfo
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToSvgWithHttpInfo($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToSvgRequest($out_path, $compress_output_to_zip_archive, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToSvgAsync
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToSvgAsync($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        return $this->putPdfInRequestToSvgAsyncWithHttpInfo($out_path, $compress_output_to_zip_archive, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToSvgAsyncWithHttpInfo($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToSvgRequest($out_path, $compress_output_to_zip_archive, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToSvg'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToSvgRequest($out_path, $compress_output_to_zip_archive = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToSvg'
            );
        }

        $resourcePath = '/pdf/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($compress_output_to_zip_archive !== null) {
            $queryParams['compressOutputToZipArchive'] = ObjectSerializer::toQueryValue($compress_output_to_zip_archive);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToTiff
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInRequestToTiff($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToTiffWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToTiffWithHttpInfo
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToTiffWithHttpInfo($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToTiffRequest($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToTiffAsync
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToTiffAsync($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        return $this->putPdfInRequestToTiffAsyncWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToTiffAsyncWithHttpInfo($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToTiffRequest($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToTiff'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToTiffRequest($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToTiff'
            );
        }

        $resourcePath = '/pdf/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXls
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInRequestToXls($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        list($response) = $this->putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToXlsWithHttpInfo
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXlsAsync
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsAsync($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        return $this->putPdfInRequestToXlsAsyncWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsAsyncWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXls'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXls'
            );
        }

        $resourcePath = '/pdf/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXps
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInRequestToXps($out_path, $file = null)
    {
        list($response) = $this->putPdfInRequestToXpsWithHttpInfo($out_path, $file);
        return $response;
    }

    /**
     * Operation putPdfInRequestToXpsWithHttpInfo
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXpsWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToXpsRequest($out_path, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXpsAsync
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXpsAsync($out_path, $file = null)
    {
        return $this->putPdfInRequestToXpsAsyncWithHttpInfo($out_path, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXpsAsyncWithHttpInfo($out_path, $file = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInRequestToXpsRequest($out_path, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXps'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXpsRequest($out_path, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXps'
            );
        }

        $resourcePath = '/pdf/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToDoc
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInStorageToDoc($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToDocWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToDocAsync
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToDocAsync($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        return $this->putPdfInStorageToDocAsyncWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToDocAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToDocAsyncWithHttpInfo($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToDoc'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  int $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToDoc'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToDoc'
            );
        }

        $resourcePath = '/pdf/{name}/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToPdfA
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInStorageToPdfA($name, $out_path, $type, $folder = null)
    {
        list($response) = $this->putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToPdfAWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToPdfARequest($name, $out_path, $type, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToPdfAAsync
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPdfAAsync($name, $out_path, $type, $folder = null)
    {
        return $this->putPdfInStorageToPdfAAsyncWithHttpInfo($name, $out_path, $type, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPdfAAsyncWithHttpInfo($name, $out_path, $type, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToPdfARequest($name, $out_path, $type, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToPdfA'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToPdfARequest($name, $out_path, $type, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling putPdfInStorageToPdfA'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToSvg
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInStorageToSvg($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToSvgWithHttpInfo($name, $out_path, $compress_output_to_zip_archive, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToSvgWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToSvgWithHttpInfo($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToSvgRequest($name, $out_path, $compress_output_to_zip_archive, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToSvgAsync
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToSvgAsync($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        return $this->putPdfInStorageToSvgAsyncWithHttpInfo($name, $out_path, $compress_output_to_zip_archive, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToSvgAsyncWithHttpInfo($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToSvgRequest($name, $out_path, $compress_output_to_zip_archive, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToSvg'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToSvgRequest($name, $out_path, $compress_output_to_zip_archive = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToSvg'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToSvg'
            );
        }

        $resourcePath = '/pdf/{name}/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($compress_output_to_zip_archive !== null) {
            $queryParams['compressOutputToZipArchive'] = ObjectSerializer::toQueryValue($compress_output_to_zip_archive);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToTiff
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInStorageToTiff($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToTiffWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToTiffRequest($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToTiffAsync
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToTiffAsync($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        return $this->putPdfInStorageToTiffAsyncWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToTiffAsyncWithHttpInfo($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToTiffRequest($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToTiffRequest($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToTiff'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXls
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInStorageToXls($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        list($response) = $this->putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToXlsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXlsAsync
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsAsync($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        return $this->putPdfInStorageToXlsAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXls'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXls'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXls'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXps
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putPdfInStorageToXps($name, $out_path, $folder = null)
    {
        list($response) = $this->putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder);
        return $response;
    }

    /**
     * Operation putPdfInStorageToXpsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToXpsRequest($name, $out_path, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXpsAsync
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXpsAsync($name, $out_path, $folder = null)
    {
        return $this->putPdfInStorageToXpsAsyncWithHttpInfo($name, $out_path, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXpsAsyncWithHttpInfo($name, $out_path, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putPdfInStorageToXpsRequest($name, $out_path, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXps'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXpsRequest($name, $out_path, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXps'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXps'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSearchableDocument
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SaaSposeResponse
     */
    public function putSearchableDocument($name, $storage = null, $folder = null, $lang = null)
    {
        list($response) = $this->putSearchableDocumentWithHttpInfo($name, $storage, $folder, $lang);
        return $response;
    }

    /**
     * Operation putSearchableDocumentWithHttpInfo
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SaaSposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSearchableDocumentWithHttpInfo($name, $storage = null, $folder = null, $lang = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putSearchableDocumentRequest($name, $storage, $folder, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SaaSposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSearchableDocumentAsync
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSearchableDocumentAsync($name, $storage = null, $folder = null, $lang = null)
    {
        return $this->putSearchableDocumentAsyncWithHttpInfo($name, $storage, $folder, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSearchableDocumentAsyncWithHttpInfo
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSearchableDocumentAsyncWithHttpInfo($name, $storage = null, $folder = null, $lang = null)
    {
        $returnType = '\Aspose\PDF\Model\SaaSposeResponse';
        $request = $this->putSearchableDocumentRequest($name, $storage, $folder, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSearchableDocument'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSearchableDocumentRequest($name, $storage = null, $folder = null, $lang = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSearchableDocument'
            );
        }

        $resourcePath = '/pdf/{name}/ocr';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSetProperty
     *
     * Add/update document property.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property property (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertyResponse
     */
    public function putSetProperty($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        list($response) = $this->putSetPropertyWithHttpInfo($name, $property_name, $property, $storage, $folder);
        return $response;
    }

    /**
     * Operation putSetPropertyWithHttpInfo
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSetPropertyWithHttpInfo($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->putSetPropertyRequest($name, $property_name, $property, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSetPropertyAsync
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSetPropertyAsync($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        return $this->putSetPropertyAsyncWithHttpInfo($name, $property_name, $property, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSetPropertyAsyncWithHttpInfo
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSetPropertyAsyncWithHttpInfo($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->putSetPropertyRequest($name, $property_name, $property, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSetProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  \Aspose\PDF\Model\DocumentProperty $property (optional)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSetPropertyRequest($name, $property_name, $property = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSetProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling putSetProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($property)) {
            $_tempBody = $property;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUpdateField
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldResponse
     */
    public function putUpdateField($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        list($response) = $this->putUpdateFieldWithHttpInfo($name, $field_name, $field, $storage, $folder);
        return $response;
    }

    /**
     * Operation putUpdateFieldWithHttpInfo
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUpdateFieldWithHttpInfo($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->putUpdateFieldRequest($name, $field_name, $field, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUpdateFieldAsync
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldAsync($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        return $this->putUpdateFieldAsyncWithHttpInfo($name, $field_name, $field, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUpdateFieldAsyncWithHttpInfo
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldAsyncWithHttpInfo($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->putUpdateFieldRequest($name, $field_name, $field, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUpdateField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUpdateFieldRequest($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUpdateField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling putUpdateField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($field)) {
            $_tempBody = $field;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUpdateFields
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldsResponse
     */
    public function putUpdateFields($name, $fields = null, $storage = null, $folder = null)
    {
        list($response) = $this->putUpdateFieldsWithHttpInfo($name, $fields, $storage, $folder);
        return $response;
    }

    /**
     * Operation putUpdateFieldsWithHttpInfo
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUpdateFieldsWithHttpInfo($name, $fields = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->putUpdateFieldsRequest($name, $fields, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUpdateFieldsAsync
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldsAsync($name, $fields = null, $storage = null, $folder = null)
    {
        return $this->putUpdateFieldsAsyncWithHttpInfo($name, $fields, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUpdateFieldsAsyncWithHttpInfo
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldsAsyncWithHttpInfo($name, $fields = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->putUpdateFieldsRequest($name, $fields, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUpdateFields'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUpdateFieldsRequest($name, $fields = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUpdateFields'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($fields)) {
            $_tempBody = $fields;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    //ASPOSE_PDF_CLOUD
    /*
     * Gets a request token from server
     */
    private function _requestToken()
    {
        $requestUrl = $this->config->getHost() . "/oauth2/token";
        $requestUrl = str_replace($this->config->getBasePath(), '', $requestUrl);
        $postData = "grant_type=client_credentials" . "&client_id=" . $this->config->getAppSid() . "&client_secret=" . $this->config->getAppKey();
        $response = $this->client->send(new Request('POST', $requestUrl, [], $postData));
        $result = json_decode($response->getBody()->getContents(), true);
        $this->config->setAccessToken($result["access_token"]);
        $this->config->setRefreshToken($result["refresh_token"]);
    }
    /*
     * Refresh token
     */
    private function _refreshToken()
    {
        $requestUrl = $this->config->getHost() . "/oauth2/token";
        $requestUrl = str_replace($this->config->getBasePath(), '', $requestUrl);
        $postData = "grant_type=refresh_token&refresh_token=" . $this->config->getRefreshToken();
        $response = $this->client->send(new Request('POST', $requestUrl, [], $postData));
        $result = json_decode($response->getBody()->getContents(), true);
        $this->config->setAccessToken($result["access_token"]);
        $this->config->setRefreshToken($result["refresh_token"]);
    }
    //ASPOSE_PDF_CLOUD
}
