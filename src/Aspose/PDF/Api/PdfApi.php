<?php
/**
 * PdfApi
 * PHP version 5
 *
 * @category Class
 * @package  Aspose\PDF
 * @author   Aspose PDF Cloud
 * @link     https://github.com/aspose-pdf-cloud/aspose-pdf-cloud-php
 */

/**
 *
 *   Copyright (c) 2018 Aspose.PDF Cloud
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */


namespace Aspose\PDF\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Aspose\PDF\ApiException;
use Aspose\PDF\Configuration;
use Aspose\PDF\HeaderSelector;
use Aspose\PDF\ObjectSerializer;

class PdfApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteAnnotation
     *
     * Delete document annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteAnnotationWithHttpInfo
     *
     * Delete document annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAnnotationAsync
     *
     * Delete document annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->deleteAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAnnotationAsyncWithHttpInfo
     *
     * Delete document annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling deleteAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocumentAnnotations
     *
     * Delete all annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteDocumentAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteDocumentAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteDocumentAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteDocumentAnnotationsWithHttpInfo
     *
     * Delete all annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDocumentAnnotationsAsync
     *
     * Delete all annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->deleteDocumentAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentAnnotationsAsyncWithHttpInfo
     *
     * Delete all annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocumentAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDocumentAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteDocumentAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocumentLinkAnnotations
     *
     * Delete all link annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteDocumentLinkAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteDocumentLinkAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteDocumentLinkAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteDocumentLinkAnnotationsWithHttpInfo
     *
     * Delete all link annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentLinkAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentLinkAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDocumentLinkAnnotationsAsync
     *
     * Delete all link annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentLinkAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->deleteDocumentLinkAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentLinkAnnotationsAsyncWithHttpInfo
     *
     * Delete all link annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentLinkAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentLinkAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocumentLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDocumentLinkAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteDocumentLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteField
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteField($name, $field_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteFieldWithHttpInfo($name, $field_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteFieldWithHttpInfo($name, $field_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteFieldWithHttpInfo
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFieldWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFieldRequest($name, $field_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFieldAsync
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsync($name, $field_name, $storage = null, $folder = null)
    {
        return $this->deleteFieldAsyncWithHttpInfo($name, $field_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFieldAsyncWithHttpInfo
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsyncWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFieldRequest($name, $field_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFieldRequest($name, $field_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling deleteField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFile
     *
     * Remove a specific file
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteFile($path, $version_id = null, $storage = null)
    {
        try
        {
            list($response) = $this->deleteFileWithHttpInfo($path, $version_id, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteFileWithHttpInfo($path, $version_id, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * Remove a specific file
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFileRequest($path, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileAsync
     *
     * Remove a specific file
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsync($path, $version_id = null, $storage = null)
    {
        return $this->deleteFileAsyncWithHttpInfo($path, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAsyncWithHttpInfo
     *
     * Remove a specific file
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsyncWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFileRequest($path, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFile'
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFileRequest($path, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling deleteFile'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFolder
     *
     * Remove a specific folder
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteFolder($path, $storage = null, $recursive = 'false')
    {
        try
        {
            list($response) = $this->deleteFolderWithHttpInfo($path, $storage, $recursive);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteFolderWithHttpInfo($path, $storage, $recursive);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteFolderWithHttpInfo
     *
     * Remove a specific folder
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFolderWithHttpInfo($path, $storage = null, $recursive = 'false')
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFolderRequest($path, $storage, $recursive);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFolderAsync
     *
     * Remove a specific folder
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsync($path, $storage = null, $recursive = 'false')
    {
        return $this->deleteFolderAsyncWithHttpInfo($path, $storage, $recursive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFolderAsyncWithHttpInfo
     *
     * Remove a specific folder
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsyncWithHttpInfo($path, $storage = null, $recursive = 'false')
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFolderRequest($path, $storage, $recursive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFolder'
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFolderRequest($path, $storage = null, $recursive = 'false')
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling deleteFolder'
            );
        }

        $resourcePath = '/storage/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($recursive !== null) {
            $queryParams['recursive'] = ObjectSerializer::toQueryValue($recursive);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteImage
     *
     * Delete image from document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteImage($name, $image_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteImageWithHttpInfo($name, $image_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteImageWithHttpInfo($name, $image_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteImageWithHttpInfo
     *
     * Delete image from document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteImageWithHttpInfo($name, $image_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteImageRequest($name, $image_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteImageAsync
     *
     * Delete image from document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteImageAsync($name, $image_id, $storage = null, $folder = null)
    {
        return $this->deleteImageAsyncWithHttpInfo($name, $image_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteImageAsyncWithHttpInfo
     *
     * Delete image from document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteImageAsyncWithHttpInfo($name, $image_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteImageRequest($name, $image_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteImage'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteImageRequest($name, $image_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteImage'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling deleteImage'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLinkAnnotation
     *
     * Delete document page link annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteLinkAnnotation($name, $link_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteLinkAnnotationWithHttpInfo($name, $link_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteLinkAnnotationWithHttpInfo($name, $link_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteLinkAnnotationWithHttpInfo
     *
     * Delete document page link annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLinkAnnotationWithHttpInfo($name, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteLinkAnnotationRequest($name, $link_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteLinkAnnotationAsync
     *
     * Delete document page link annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLinkAnnotationAsync($name, $link_id, $storage = null, $folder = null)
    {
        return $this->deleteLinkAnnotationAsyncWithHttpInfo($name, $link_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLinkAnnotationAsyncWithHttpInfo
     *
     * Delete document page link annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLinkAnnotationAsyncWithHttpInfo($name, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteLinkAnnotationRequest($name, $link_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteLinkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteLinkAnnotationRequest($name, $link_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteLinkAnnotation'
            );
        }
        // verify the required parameter 'link_id' is set
        if ($link_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_id when calling deleteLinkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/links/{linkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'linkId' . '}',
                ObjectSerializer::toPathValue($link_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePage
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deletePage($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePageWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePageWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePageWithHttpInfo
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageAsync
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageAsyncWithHttpInfo
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePageAnnotations
     *
     * Delete all annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deletePageAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePageAnnotationsWithHttpInfo
     *
     * Delete all annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageAnnotationsAsync
     *
     * Delete all annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageAnnotationsAsyncWithHttpInfo
     *
     * Delete all annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePageAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePageAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePageAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePageLinkAnnotations
     *
     * Delete all link annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deletePageLinkAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePageLinkAnnotationsWithHttpInfo
     *
     * Delete all link annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageLinkAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageLinkAnnotationsAsync
     *
     * Delete all link annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageLinkAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageLinkAnnotationsAsyncWithHttpInfo
     *
     * Delete all link annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePageLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageLinkAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePageLinkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePageLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProperties
     *
     * Delete custom document properties.
     *
     * @param  string $name name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteProperties($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePropertiesWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePropertiesWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePropertiesWithHttpInfo
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePropertiesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePropertiesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePropertiesAsync
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertiesAsync($name, $storage = null, $folder = null)
    {
        return $this->deletePropertiesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePropertiesAsyncWithHttpInfo
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertiesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePropertiesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProperties'
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePropertiesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteProperties'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProperty
     *
     * Delete document property.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteProperty($name, $property_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePropertyWithHttpInfo($name, $property_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePropertyWithHttpInfo($name, $property_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePropertyWithHttpInfo
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePropertyWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePropertyRequest($name, $property_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePropertyAsync
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertyAsync($name, $property_name, $storage = null, $folder = null)
    {
        return $this->deletePropertyAsyncWithHttpInfo($name, $property_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePropertyAsyncWithHttpInfo
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertyAsyncWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePropertyRequest($name, $property_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePropertyRequest($name, $property_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling deleteProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCaretAnnotation
     *
     * Read document page caret annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CaretAnnotationResponse
     */
    public function getCaretAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getCaretAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getCaretAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getCaretAnnotationWithHttpInfo
     *
     * Read document page caret annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CaretAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCaretAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationResponse';
        $request = $this->getCaretAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CaretAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCaretAnnotationAsync
     *
     * Read document page caret annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCaretAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getCaretAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCaretAnnotationAsyncWithHttpInfo
     *
     * Read document page caret annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCaretAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationResponse';
        $request = $this->getCaretAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCaretAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCaretAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getCaretAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getCaretAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/caret/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCircleAnnotation
     *
     * Read document page circle annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CircleAnnotationResponse
     */
    public function getCircleAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getCircleAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getCircleAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getCircleAnnotationWithHttpInfo
     *
     * Read document page circle annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CircleAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCircleAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationResponse';
        $request = $this->getCircleAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CircleAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCircleAnnotationAsync
     *
     * Read document page circle annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCircleAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getCircleAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCircleAnnotationAsyncWithHttpInfo
     *
     * Read document page circle annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCircleAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationResponse';
        $request = $this->getCircleAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCircleAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCircleAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getCircleAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getCircleAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/circle/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDiscUsage
     *
     * Check the disk usage of the current account
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DiscUsageResponse
     */
    public function getDiscUsage($storage = null)
    {
        try
        {
            list($response) = $this->getDiscUsageWithHttpInfo($storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDiscUsageWithHttpInfo($storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDiscUsageWithHttpInfo
     *
     * Check the disk usage of the current account
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DiscUsageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDiscUsageWithHttpInfo($storage = null)
    {
        $returnType = '\Aspose\PDF\Model\DiscUsageResponse';
        $request = $this->getDiscUsageRequest($storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DiscUsageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDiscUsageAsync
     *
     * Check the disk usage of the current account
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDiscUsageAsync($storage = null)
    {
        return $this->getDiscUsageAsyncWithHttpInfo($storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDiscUsageAsyncWithHttpInfo
     *
     * Check the disk usage of the current account
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDiscUsageAsyncWithHttpInfo($storage = null)
    {
        $returnType = '\Aspose\PDF\Model\DiscUsageResponse';
        $request = $this->getDiscUsageRequest($storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDiscUsage'
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDiscUsageRequest($storage = null)
    {

        $resourcePath = '/storage/disc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocument
     *
     * Read common document info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function getDocument($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentWithHttpInfo
     *
     * Read common document info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->getDocumentRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAsync
     *
     * Read common document info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAsyncWithHttpInfo
     *
     * Read common document info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->getDocumentRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocument'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocument'
            );
        }

        $resourcePath = '/pdf/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAnnotations
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AnnotationsInfoResponse
     */
    public function getDocumentAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentAnnotationsWithHttpInfo
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AnnotationsInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsInfoResponse';
        $request = $this->getDocumentAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AnnotationsInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAnnotationsAsync
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAnnotationsAsyncWithHttpInfo
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsInfoResponse';
        $request = $this->getDocumentAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAttachmentByIndex
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AttachmentResponse
     */
    public function getDocumentAttachmentByIndex($name, $attachment_index, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentAttachmentByIndexWithHttpInfo
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AttachmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentResponse';
        $request = $this->getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AttachmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAttachmentByIndexAsync
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentByIndexAsync($name, $attachment_index, $storage = null, $folder = null)
    {
        return $this->getDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAttachmentByIndexAsyncWithHttpInfo
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentResponse';
        $request = $this->getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAttachmentByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAttachmentByIndex'
            );
        }
        // verify the required parameter 'attachment_index' is set
        if ($attachment_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_index when calling getDocumentAttachmentByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/attachments/{attachmentIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($attachment_index !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentIndex' . '}',
                ObjectSerializer::toPathValue($attachment_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAttachments
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AttachmentsResponse
     */
    public function getDocumentAttachments($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentAttachmentsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentAttachmentsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentAttachmentsWithHttpInfo
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AttachmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAttachmentsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentsResponse';
        $request = $this->getDocumentAttachmentsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AttachmentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAttachmentsAsync
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentAttachmentsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAttachmentsAsyncWithHttpInfo
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentsResponse';
        $request = $this->getDocumentAttachmentsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAttachments'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAttachmentsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAttachments'
            );
        }

        $resourcePath = '/pdf/{name}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentBookmarks
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentBookmarks($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentBookmarksWithHttpInfo($name, $bookmark_path, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentBookmarksWithHttpInfo($name, $bookmark_path, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentBookmarksWithHttpInfo
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentBookmarksWithHttpInfo($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentBookmarksRequest($name, $bookmark_path, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentBookmarksAsync
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentBookmarksAsync($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        return $this->getDocumentBookmarksAsyncWithHttpInfo($name, $bookmark_path, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentBookmarksAsyncWithHttpInfo
     *
     * Read document bookmark/bookmarks (including children).
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentBookmarksAsyncWithHttpInfo($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentBookmarksRequest($name, $bookmark_path, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentBookmarks'
     *
     * @param  string $name The document name. (required)
     * @param  string $bookmark_path The bookmark path. Leave it empty if you want to get all the bookmarks in the document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentBookmarksRequest($name, $bookmark_path = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentBookmarks'
            );
        }

        $resourcePath = '/pdf/{name}/bookmarks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($bookmark_path !== null) {
            $queryParams['bookmarkPath'] = ObjectSerializer::toQueryValue($bookmark_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentCaretAnnotations
     *
     * Read document caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CaretAnnotationsResponse
     */
    public function getDocumentCaretAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentCaretAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentCaretAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentCaretAnnotationsWithHttpInfo
     *
     * Read document caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CaretAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentCaretAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationsResponse';
        $request = $this->getDocumentCaretAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CaretAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentCaretAnnotationsAsync
     *
     * Read document caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentCaretAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentCaretAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentCaretAnnotationsAsyncWithHttpInfo
     *
     * Read document caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentCaretAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationsResponse';
        $request = $this->getDocumentCaretAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentCaretAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentCaretAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentCaretAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/caret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentCircleAnnotations
     *
     * Read document circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CircleAnnotationsResponse
     */
    public function getDocumentCircleAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentCircleAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentCircleAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentCircleAnnotationsWithHttpInfo
     *
     * Read document circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CircleAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentCircleAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationsResponse';
        $request = $this->getDocumentCircleAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CircleAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentCircleAnnotationsAsync
     *
     * Read document circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentCircleAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentCircleAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentCircleAnnotationsAsyncWithHttpInfo
     *
     * Read document circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentCircleAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationsResponse';
        $request = $this->getDocumentCircleAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentCircleAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentCircleAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentCircleAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/circle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentFreeTextAnnotations
     *
     * Read document free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FreeTextAnnotationsResponse
     */
    public function getDocumentFreeTextAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentFreeTextAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentFreeTextAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentFreeTextAnnotationsWithHttpInfo
     *
     * Read document free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FreeTextAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentFreeTextAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationsResponse';
        $request = $this->getDocumentFreeTextAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FreeTextAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentFreeTextAnnotationsAsync
     *
     * Read document free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFreeTextAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentFreeTextAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentFreeTextAnnotationsAsyncWithHttpInfo
     *
     * Read document free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFreeTextAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationsResponse';
        $request = $this->getDocumentFreeTextAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentFreeTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentFreeTextAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentFreeTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/freetext';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentHighlightAnnotations
     *
     * Read document highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\HighlightAnnotationsResponse
     */
    public function getDocumentHighlightAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentHighlightAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentHighlightAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentHighlightAnnotationsWithHttpInfo
     *
     * Read document highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\HighlightAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentHighlightAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationsResponse';
        $request = $this->getDocumentHighlightAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\HighlightAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentHighlightAnnotationsAsync
     *
     * Read document highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentHighlightAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentHighlightAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentHighlightAnnotationsAsyncWithHttpInfo
     *
     * Read document highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentHighlightAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationsResponse';
        $request = $this->getDocumentHighlightAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentHighlightAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentHighlightAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentHighlightAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/highlight';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentInkAnnotations
     *
     * Read document ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\InkAnnotationsResponse
     */
    public function getDocumentInkAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentInkAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentInkAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentInkAnnotationsWithHttpInfo
     *
     * Read document ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\InkAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentInkAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationsResponse';
        $request = $this->getDocumentInkAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\InkAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentInkAnnotationsAsync
     *
     * Read document ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentInkAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentInkAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentInkAnnotationsAsyncWithHttpInfo
     *
     * Read document ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentInkAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationsResponse';
        $request = $this->getDocumentInkAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentInkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentInkAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentInkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/ink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentLineAnnotations
     *
     * Read document line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LineAnnotationsResponse
     */
    public function getDocumentLineAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentLineAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentLineAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentLineAnnotationsWithHttpInfo
     *
     * Read document line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentLineAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationsResponse';
        $request = $this->getDocumentLineAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentLineAnnotationsAsync
     *
     * Read document line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentLineAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentLineAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentLineAnnotationsAsyncWithHttpInfo
     *
     * Read document line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentLineAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationsResponse';
        $request = $this->getDocumentLineAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentLineAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/line';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentPolyLineAnnotations
     *
     * Read document polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolyLineAnnotationsResponse
     */
    public function getDocumentPolyLineAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPolyLineAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPolyLineAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPolyLineAnnotationsWithHttpInfo
     *
     * Read document polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolyLineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPolyLineAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationsResponse';
        $request = $this->getDocumentPolyLineAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolyLineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPolyLineAnnotationsAsync
     *
     * Read document polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPolyLineAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPolyLineAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPolyLineAnnotationsAsyncWithHttpInfo
     *
     * Read document polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPolyLineAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationsResponse';
        $request = $this->getDocumentPolyLineAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentPolyLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPolyLineAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentPolyLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polyline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentPolygonAnnotations
     *
     * Read document polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolygonAnnotationsResponse
     */
    public function getDocumentPolygonAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPolygonAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPolygonAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPolygonAnnotationsWithHttpInfo
     *
     * Read document polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolygonAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPolygonAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationsResponse';
        $request = $this->getDocumentPolygonAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolygonAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPolygonAnnotationsAsync
     *
     * Read document polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPolygonAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPolygonAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPolygonAnnotationsAsyncWithHttpInfo
     *
     * Read document polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPolygonAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationsResponse';
        $request = $this->getDocumentPolygonAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentPolygonAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPolygonAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentPolygonAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polygon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentPopupAnnotations
     *
     * Read document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationsResponse
     */
    public function getDocumentPopupAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPopupAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPopupAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPopupAnnotationsWithHttpInfo
     *
     * Read document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPopupAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getDocumentPopupAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPopupAnnotationsAsync
     *
     * Read document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPopupAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPopupAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPopupAnnotationsAsyncWithHttpInfo
     *
     * Read document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPopupAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getDocumentPopupAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentPopupAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPopupAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentPopupAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/popup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentPopupAnnotationsByParent
     *
     * Read document popup annotations by parent id.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationsResponse
     */
    public function getDocumentPopupAnnotationsByParent($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPopupAnnotationsByParentWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPopupAnnotationsByParentWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPopupAnnotationsByParentWithHttpInfo
     *
     * Read document popup annotations by parent id.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPopupAnnotationsByParentWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getDocumentPopupAnnotationsByParentRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPopupAnnotationsByParentAsync
     *
     * Read document popup annotations by parent id.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPopupAnnotationsByParentAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getDocumentPopupAnnotationsByParentAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPopupAnnotationsByParentAsyncWithHttpInfo
     *
     * Read document popup annotations by parent id.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPopupAnnotationsByParentAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getDocumentPopupAnnotationsByParentRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentPopupAnnotationsByParent'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPopupAnnotationsByParentRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentPopupAnnotationsByParent'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getDocumentPopupAnnotationsByParent'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/{annotationId}/popup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentProperties
     *
     * Read document properties.
     *
     * @param  string $name name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertiesResponse
     */
    public function getDocumentProperties($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPropertiesWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPropertiesWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPropertiesWithHttpInfo
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertiesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPropertiesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertiesResponse';
        $request = $this->getDocumentPropertiesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertiesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPropertiesAsync
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPropertiesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPropertiesAsyncWithHttpInfo
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertiesResponse';
        $request = $this->getDocumentPropertiesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentProperties'
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPropertiesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentProperties'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentProperty
     *
     * Read document property by name.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertyResponse
     */
    public function getDocumentProperty($name, $property_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPropertyWithHttpInfo($name, $property_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPropertyWithHttpInfo($name, $property_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPropertyWithHttpInfo
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPropertyWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->getDocumentPropertyRequest($name, $property_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPropertyAsync
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyAsync($name, $property_name, $storage = null, $folder = null)
    {
        return $this->getDocumentPropertyAsyncWithHttpInfo($name, $property_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPropertyAsyncWithHttpInfo
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyAsyncWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->getDocumentPropertyRequest($name, $property_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPropertyRequest($name, $property_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling getDocumentProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentSquareAnnotations
     *
     * Read document square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquareAnnotationsResponse
     */
    public function getDocumentSquareAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentSquareAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentSquareAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentSquareAnnotationsWithHttpInfo
     *
     * Read document square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquareAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentSquareAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationsResponse';
        $request = $this->getDocumentSquareAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquareAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentSquareAnnotationsAsync
     *
     * Read document square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSquareAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentSquareAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentSquareAnnotationsAsyncWithHttpInfo
     *
     * Read document square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSquareAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationsResponse';
        $request = $this->getDocumentSquareAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentSquareAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentSquareAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentSquareAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/square';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentSquigglyAnnotations
     *
     * Read document squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquigglyAnnotationsResponse
     */
    public function getDocumentSquigglyAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentSquigglyAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentSquigglyAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentSquigglyAnnotationsWithHttpInfo
     *
     * Read document squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquigglyAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentSquigglyAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationsResponse';
        $request = $this->getDocumentSquigglyAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquigglyAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentSquigglyAnnotationsAsync
     *
     * Read document squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSquigglyAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentSquigglyAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentSquigglyAnnotationsAsyncWithHttpInfo
     *
     * Read document squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSquigglyAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationsResponse';
        $request = $this->getDocumentSquigglyAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentSquigglyAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentSquigglyAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentSquigglyAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/squiggly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentStrikeOutAnnotations
     *
     * Read document StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StrikeOutAnnotationsResponse
     */
    public function getDocumentStrikeOutAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentStrikeOutAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentStrikeOutAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentStrikeOutAnnotationsWithHttpInfo
     *
     * Read document StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StrikeOutAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentStrikeOutAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationsResponse';
        $request = $this->getDocumentStrikeOutAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StrikeOutAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentStrikeOutAnnotationsAsync
     *
     * Read document StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStrikeOutAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentStrikeOutAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentStrikeOutAnnotationsAsyncWithHttpInfo
     *
     * Read document StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStrikeOutAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationsResponse';
        $request = $this->getDocumentStrikeOutAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentStrikeOutAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentStrikeOutAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentStrikeOutAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/strikeout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentTextAnnotations
     *
     * Read document text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextAnnotationsResponse
     */
    public function getDocumentTextAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentTextAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentTextAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentTextAnnotationsWithHttpInfo
     *
     * Read document text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentTextAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationsResponse';
        $request = $this->getDocumentTextAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentTextAnnotationsAsync
     *
     * Read document text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentTextAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentTextAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentTextAnnotationsAsyncWithHttpInfo
     *
     * Read document text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentTextAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationsResponse';
        $request = $this->getDocumentTextAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentTextAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentUnderlineAnnotations
     *
     * Read document underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\UnderlineAnnotationsResponse
     */
    public function getDocumentUnderlineAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentUnderlineAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentUnderlineAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentUnderlineAnnotationsWithHttpInfo
     *
     * Read document underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\UnderlineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentUnderlineAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationsResponse';
        $request = $this->getDocumentUnderlineAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\UnderlineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentUnderlineAnnotationsAsync
     *
     * Read document underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentUnderlineAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentUnderlineAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentUnderlineAnnotationsAsyncWithHttpInfo
     *
     * Read document underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentUnderlineAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationsResponse';
        $request = $this->getDocumentUnderlineAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentUnderlineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentUnderlineAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentUnderlineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/underline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownload
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDownload($path, $version_id = null, $storage = null)
    {
        try
        {
            list($response) = $this->getDownloadWithHttpInfo($path, $version_id, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDownloadWithHttpInfo($path, $version_id, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDownloadWithHttpInfo
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadRequest($path, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadAsync
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadAsync($path, $version_id = null, $storage = null)
    {
        return $this->getDownloadAsyncWithHttpInfo($path, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadAsyncWithHttpInfo
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadAsyncWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadRequest($path, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownload'
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadRequest($path, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getDownload'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndex
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDownloadDocumentAttachmentByIndex($name, $attachment_index, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexWithHttpInfo
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexAsync
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadDocumentAttachmentByIndexAsync($name, $attachment_index, $storage = null, $folder = null)
    {
        return $this->getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadDocumentAttachmentByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDownloadDocumentAttachmentByIndex'
            );
        }
        // verify the required parameter 'attachment_index' is set
        if ($attachment_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_index when calling getDownloadDocumentAttachmentByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/attachments/{attachmentIndex}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($attachment_index !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentIndex' . '}',
                ObjectSerializer::toPathValue($attachment_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpubInStorageToPdf
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getEpubInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getEpubInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getEpubInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getEpubInStorageToPdfWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEpubInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getEpubInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEpubInStorageToPdfAsync
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpubInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getEpubInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpubInStorageToPdfAsyncWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpubInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getEpubInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEpubInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEpubInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getEpubInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getField
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldResponse
     */
    public function getField($name, $field_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getFieldWithHttpInfo($name, $field_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getFieldWithHttpInfo($name, $field_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getFieldWithHttpInfo
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->getFieldRequest($name, $field_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldAsync
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsync($name, $field_name, $storage = null, $folder = null)
    {
        return $this->getFieldAsyncWithHttpInfo($name, $field_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldAsyncWithHttpInfo
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsyncWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->getFieldRequest($name, $field_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFieldRequest($name, $field_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFields
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldsResponse
     */
    public function getFields($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getFieldsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getFieldsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getFieldsWithHttpInfo
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->getFieldsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldsAsync
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsync($name, $storage = null, $folder = null)
    {
        return $this->getFieldsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldsAsyncWithHttpInfo
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->getFieldsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFields'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFieldsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFields'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFreeTextAnnotation
     *
     * Read document page free text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FreeTextAnnotationResponse
     */
    public function getFreeTextAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getFreeTextAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getFreeTextAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getFreeTextAnnotationWithHttpInfo
     *
     * Read document page free text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FreeTextAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFreeTextAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationResponse';
        $request = $this->getFreeTextAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FreeTextAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFreeTextAnnotationAsync
     *
     * Read document page free text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFreeTextAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getFreeTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFreeTextAnnotationAsyncWithHttpInfo
     *
     * Read document page free text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFreeTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationResponse';
        $request = $this->getFreeTextAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFreeTextAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFreeTextAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFreeTextAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getFreeTextAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/freetext/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHighlightAnnotation
     *
     * Read document page highlight annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\HighlightAnnotationResponse
     */
    public function getHighlightAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getHighlightAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getHighlightAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getHighlightAnnotationWithHttpInfo
     *
     * Read document page highlight annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\HighlightAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHighlightAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationResponse';
        $request = $this->getHighlightAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\HighlightAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHighlightAnnotationAsync
     *
     * Read document page highlight annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHighlightAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getHighlightAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHighlightAnnotationAsyncWithHttpInfo
     *
     * Read document page highlight annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHighlightAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationResponse';
        $request = $this->getHighlightAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHighlightAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHighlightAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getHighlightAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getHighlightAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/highlight/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHtmlInStorageToPdf
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getHtmlInStorageToPdf($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        try
        {
            list($response) = $this->getHtmlInStorageToPdfWithHttpInfo($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getHtmlInStorageToPdfWithHttpInfo($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getHtmlInStorageToPdfWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHtmlInStorageToPdfWithHttpInfo($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getHtmlInStorageToPdfRequest($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHtmlInStorageToPdfAsync
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHtmlInStorageToPdfAsync($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        return $this->getHtmlInStorageToPdfAsyncWithHttpInfo($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHtmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHtmlInStorageToPdfAsyncWithHttpInfo($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getHtmlInStorageToPdfRequest($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHtmlInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHtmlInStorageToPdfRequest($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getHtmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($html_file_name !== null) {
            $queryParams['htmlFileName'] = ObjectSerializer::toQueryValue($html_file_name);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImage
     *
     * Read document image by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImageResponse
     */
    public function getImage($name, $image_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageWithHttpInfo($name, $image_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageWithHttpInfo($name, $image_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageWithHttpInfo
     *
     * Read document image by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageWithHttpInfo($name, $image_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->getImageRequest($name, $image_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageAsync
     *
     * Read document image by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageAsync($name, $image_id, $storage = null, $folder = null)
    {
        return $this->getImageAsyncWithHttpInfo($name, $image_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageAsyncWithHttpInfo
     *
     * Read document image by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageAsyncWithHttpInfo($name, $image_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->getImageRequest($name, $image_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImage'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageRequest($name, $image_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImage'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImage'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImageExtractAsGif
     *
     * Extract document image in GIF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImageExtractAsGif($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageExtractAsGifWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageExtractAsGifWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageExtractAsGifWithHttpInfo
     *
     * Extract document image in GIF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageExtractAsGifWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsGifRequest($name, $image_id, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageExtractAsGifAsync
     *
     * Extract document image in GIF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsGifAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        return $this->getImageExtractAsGifAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageExtractAsGifAsyncWithHttpInfo
     *
     * Extract document image in GIF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsGifAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsGifRequest($name, $image_id, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImageExtractAsGif'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageExtractAsGifRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImageExtractAsGif'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImageExtractAsGif'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImageExtractAsJpeg
     *
     * Extract document image in JPEG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImageExtractAsJpeg($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageExtractAsJpegWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageExtractAsJpegWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageExtractAsJpegWithHttpInfo
     *
     * Extract document image in JPEG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageExtractAsJpegWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsJpegRequest($name, $image_id, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageExtractAsJpegAsync
     *
     * Extract document image in JPEG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsJpegAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        return $this->getImageExtractAsJpegAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageExtractAsJpegAsyncWithHttpInfo
     *
     * Extract document image in JPEG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsJpegAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsJpegRequest($name, $image_id, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImageExtractAsJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageExtractAsJpegRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImageExtractAsJpeg'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImageExtractAsJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImageExtractAsPng
     *
     * Extract document image in PNG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImageExtractAsPng($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageExtractAsPngWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageExtractAsPngWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageExtractAsPngWithHttpInfo
     *
     * Extract document image in PNG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageExtractAsPngWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsPngRequest($name, $image_id, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageExtractAsPngAsync
     *
     * Extract document image in PNG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsPngAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        return $this->getImageExtractAsPngAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageExtractAsPngAsyncWithHttpInfo
     *
     * Extract document image in PNG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsPngAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsPngRequest($name, $image_id, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImageExtractAsPng'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageExtractAsPngRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImageExtractAsPng'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImageExtractAsPng'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImageExtractAsTiff
     *
     * Extract document image in TIFF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImageExtractAsTiff($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageExtractAsTiffWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageExtractAsTiffWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageExtractAsTiffWithHttpInfo
     *
     * Extract document image in TIFF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageExtractAsTiffWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsTiffRequest($name, $image_id, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageExtractAsTiffAsync
     *
     * Extract document image in TIFF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsTiffAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        return $this->getImageExtractAsTiffAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageExtractAsTiffAsyncWithHttpInfo
     *
     * Extract document image in TIFF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsTiffAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsTiffRequest($name, $image_id, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImageExtractAsTiff'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageExtractAsTiffRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImageExtractAsTiff'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImageExtractAsTiff'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImages
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImagesResponse
     */
    public function getImages($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImagesWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImagesWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImagesWithHttpInfo
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImagesWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImagesResponse';
        $request = $this->getImagesRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImagesAsync
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getImagesAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImagesAsyncWithHttpInfo
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImagesResponse';
        $request = $this->getImagesRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImages'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImagesRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImages'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getImages'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInkAnnotation
     *
     * Read document page ink annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\InkAnnotationResponse
     */
    public function getInkAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getInkAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getInkAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getInkAnnotationWithHttpInfo
     *
     * Read document page ink annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\InkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInkAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationResponse';
        $request = $this->getInkAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\InkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInkAnnotationAsync
     *
     * Read document page ink annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInkAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getInkAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInkAnnotationAsyncWithHttpInfo
     *
     * Read document page ink annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInkAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationResponse';
        $request = $this->getInkAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInkAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getInkAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getInkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/ink/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIsExist
     *
     * Check if a specific file or folder exists
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FileExistResponse
     */
    public function getIsExist($path, $version_id = null, $storage = null)
    {
        try
        {
            list($response) = $this->getIsExistWithHttpInfo($path, $version_id, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getIsExistWithHttpInfo($path, $version_id, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getIsExistWithHttpInfo
     *
     * Check if a specific file or folder exists
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FileExistResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIsExistWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FileExistResponse';
        $request = $this->getIsExistRequest($path, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FileExistResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIsExistAsync
     *
     * Check if a specific file or folder exists
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIsExistAsync($path, $version_id = null, $storage = null)
    {
        return $this->getIsExistAsyncWithHttpInfo($path, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIsExistAsyncWithHttpInfo
     *
     * Check if a specific file or folder exists
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIsExistAsyncWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FileExistResponse';
        $request = $this->getIsExistRequest($path, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIsExist'
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIsExistRequest($path, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getIsExist'
            );
        }

        $resourcePath = '/storage/exist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIsStorageExist
     *
     * Check if storage exists
     *
     * @param  string $name Storage name (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StorageExistResponse
     */
    public function getIsStorageExist($name)
    {
        try
        {
            list($response) = $this->getIsStorageExistWithHttpInfo($name);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getIsStorageExistWithHttpInfo($name);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getIsStorageExistWithHttpInfo
     *
     * Check if storage exists
     *
     * @param  string $name Storage name (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StorageExistResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIsStorageExistWithHttpInfo($name)
    {
        $returnType = '\Aspose\PDF\Model\StorageExistResponse';
        $request = $this->getIsStorageExistRequest($name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StorageExistResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIsStorageExistAsync
     *
     * Check if storage exists
     *
     * @param  string $name Storage name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIsStorageExistAsync($name)
    {
        return $this->getIsStorageExistAsyncWithHttpInfo($name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIsStorageExistAsyncWithHttpInfo
     *
     * Check if storage exists
     *
     * @param  string $name Storage name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIsStorageExistAsyncWithHttpInfo($name)
    {
        $returnType = '\Aspose\PDF\Model\StorageExistResponse';
        $request = $this->getIsStorageExistRequest($name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIsStorageExist'
     *
     * @param  string $name Storage name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIsStorageExistRequest($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getIsStorageExist'
            );
        }

        $resourcePath = '/storage/{name}/exist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLaTeXInStorageToPdf
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getLaTeXInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getLaTeXInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getLaTeXInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getLaTeXInStorageToPdfWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLaTeXInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getLaTeXInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLaTeXInStorageToPdfAsync
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLaTeXInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getLaTeXInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLaTeXInStorageToPdfAsyncWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLaTeXInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getLaTeXInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLaTeXInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLaTeXInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getLaTeXInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLineAnnotation
     *
     * Read document page line annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LineAnnotationResponse
     */
    public function getLineAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getLineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getLineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getLineAnnotationWithHttpInfo
     *
     * Read document page line annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLineAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationResponse';
        $request = $this->getLineAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLineAnnotationAsync
     *
     * Read document page line annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLineAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLineAnnotationAsyncWithHttpInfo
     *
     * Read document page line annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationResponse';
        $request = $this->getLineAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLineAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getLineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getLineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/line/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLinkAnnotation
     *
     * Read document link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationResponse
     */
    public function getLinkAnnotation($name, $link_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getLinkAnnotationWithHttpInfo($name, $link_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getLinkAnnotationWithHttpInfo($name, $link_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getLinkAnnotationWithHttpInfo
     *
     * Read document link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLinkAnnotationWithHttpInfo($name, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getLinkAnnotationRequest($name, $link_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLinkAnnotationAsync
     *
     * Read document link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkAnnotationAsync($name, $link_id, $storage = null, $folder = null)
    {
        return $this->getLinkAnnotationAsyncWithHttpInfo($name, $link_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLinkAnnotationAsyncWithHttpInfo
     *
     * Read document link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkAnnotationAsyncWithHttpInfo($name, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getLinkAnnotationRequest($name, $link_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLinkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLinkAnnotationRequest($name, $link_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getLinkAnnotation'
            );
        }
        // verify the required parameter 'link_id' is set
        if ($link_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_id when calling getLinkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/links/{linkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'linkId' . '}',
                ObjectSerializer::toPathValue($link_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getListFileVersions
     *
     * Get the file's versions list
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FileVersionsResponse
     */
    public function getListFileVersions($path, $storage = null)
    {
        try
        {
            list($response) = $this->getListFileVersionsWithHttpInfo($path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getListFileVersionsWithHttpInfo($path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getListFileVersionsWithHttpInfo
     *
     * Get the file's versions list
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FileVersionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListFileVersionsWithHttpInfo($path, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FileVersionsResponse';
        $request = $this->getListFileVersionsRequest($path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FileVersionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getListFileVersionsAsync
     *
     * Get the file's versions list
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListFileVersionsAsync($path, $storage = null)
    {
        return $this->getListFileVersionsAsyncWithHttpInfo($path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListFileVersionsAsyncWithHttpInfo
     *
     * Get the file's versions list
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListFileVersionsAsyncWithHttpInfo($path, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FileVersionsResponse';
        $request = $this->getListFileVersionsRequest($path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getListFileVersions'
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getListFileVersionsRequest($path, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getListFileVersions'
            );
        }

        $resourcePath = '/storage/version';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getListFiles
     *
     * Get the file listing of a specific folder
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FilesResponse
     */
    public function getListFiles($path = '/', $storage = null)
    {
        try
        {
            list($response) = $this->getListFilesWithHttpInfo($path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getListFilesWithHttpInfo($path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getListFilesWithHttpInfo
     *
     * Get the file listing of a specific folder
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FilesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListFilesWithHttpInfo($path = '/', $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FilesResponse';
        $request = $this->getListFilesRequest($path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FilesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getListFilesAsync
     *
     * Get the file listing of a specific folder
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListFilesAsync($path = '/', $storage = null)
    {
        return $this->getListFilesAsyncWithHttpInfo($path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListFilesAsyncWithHttpInfo
     *
     * Get the file listing of a specific folder
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListFilesAsyncWithHttpInfo($path = '/', $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FilesResponse';
        $request = $this->getListFilesRequest($path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getListFiles'
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getListFilesRequest($path = '/', $storage = null)
    {

        $resourcePath = '/storage/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMhtInStorageToPdf
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getMhtInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getMhtInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getMhtInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getMhtInStorageToPdfWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMhtInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getMhtInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMhtInStorageToPdfAsync
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMhtInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getMhtInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMhtInStorageToPdfAsyncWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMhtInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getMhtInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMhtInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMhtInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getMhtInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/mht';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPage
     *
     * Read document page info.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPageResponse
     */
    public function getPage($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageWithHttpInfo
     *
     * Read document page info.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPageResponse';
        $request = $this->getPageRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAsync
     *
     * Read document page info.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAsyncWithHttpInfo
     *
     * Read document page info.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPageResponse';
        $request = $this->getPageRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageAnnotations
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AnnotationsInfoResponse
     */
    public function getPageAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageAnnotationsWithHttpInfo
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AnnotationsInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsInfoResponse';
        $request = $this->getPageAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AnnotationsInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAnnotationsAsync
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAnnotationsAsyncWithHttpInfo
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsInfoResponse';
        $request = $this->getPageAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageCaretAnnotations
     *
     * Read document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CaretAnnotationsResponse
     */
    public function getPageCaretAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageCaretAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageCaretAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageCaretAnnotationsWithHttpInfo
     *
     * Read document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CaretAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageCaretAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationsResponse';
        $request = $this->getPageCaretAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CaretAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageCaretAnnotationsAsync
     *
     * Read document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageCaretAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageCaretAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageCaretAnnotationsAsyncWithHttpInfo
     *
     * Read document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageCaretAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationsResponse';
        $request = $this->getPageCaretAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageCaretAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageCaretAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageCaretAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageCaretAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/caret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageCircleAnnotations
     *
     * Read document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CircleAnnotationsResponse
     */
    public function getPageCircleAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageCircleAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageCircleAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageCircleAnnotationsWithHttpInfo
     *
     * Read document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CircleAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageCircleAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationsResponse';
        $request = $this->getPageCircleAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CircleAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageCircleAnnotationsAsync
     *
     * Read document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageCircleAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageCircleAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageCircleAnnotationsAsyncWithHttpInfo
     *
     * Read document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageCircleAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationsResponse';
        $request = $this->getPageCircleAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageCircleAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageCircleAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageCircleAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageCircleAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/circle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToBmp
     *
     * Convert document page to Bmp image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToBmp($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToBmpWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToBmpWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToBmpWithHttpInfo
     *
     * Convert document page to Bmp image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToBmpWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToBmpRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToBmpAsync
     *
     * Convert document page to Bmp image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToBmpAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToBmpAsyncWithHttpInfo
     *
     * Convert document page to Bmp image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToBmpRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToBmp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToBmpRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToBmp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToBmp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/bmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToEmf
     *
     * Convert document page to Emf image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToEmf($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToEmfWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToEmfWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToEmfWithHttpInfo
     *
     * Convert document page to Emf image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToEmfWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToEmfRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToEmfAsync
     *
     * Convert document page to Emf image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToEmfAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToEmfAsyncWithHttpInfo
     *
     * Convert document page to Emf image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToEmfRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToEmf'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToEmfRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToEmf'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToEmf'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/emf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToGif
     *
     * Convert document page to Gif image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToGif($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToGifWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToGifWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToGifWithHttpInfo
     *
     * Convert document page to Gif image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToGifWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToGifRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToGifAsync
     *
     * Convert document page to Gif image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToGifAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToGifAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToGifAsyncWithHttpInfo
     *
     * Convert document page to Gif image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToGifAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToGifRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToGif'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToGifRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToGif'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToGif'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToJpeg
     *
     * Convert document page to Jpeg image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToJpeg($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToJpegWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToJpegWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToJpegWithHttpInfo
     *
     * Convert document page to Jpeg image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToJpegWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToJpegRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToJpegAsync
     *
     * Convert document page to Jpeg image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToJpegAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToJpegAsyncWithHttpInfo
     *
     * Convert document page to Jpeg image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToJpegRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToJpegRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToJpeg'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToPng
     *
     * Convert document page to Png image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToPng($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToPngWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToPngWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToPngWithHttpInfo
     *
     * Convert document page to Png image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToPngWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToPngRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToPngAsync
     *
     * Convert document page to Png image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToPngAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToPngAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToPngAsyncWithHttpInfo
     *
     * Convert document page to Png image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToPngAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToPngRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToPng'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToPngRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToPng'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToPng'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToTiff
     *
     * Convert document page to Tiff image  and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToTiff($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToTiffWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToTiffWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToTiffWithHttpInfo
     *
     * Convert document page to Tiff image  and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToTiffWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToTiffRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToTiffAsync
     *
     * Convert document page to Tiff image  and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToTiffAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToTiffAsyncWithHttpInfo
     *
     * Convert document page to Tiff image  and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToTiffRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToTiffRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToTiff'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageFreeTextAnnotations
     *
     * Read document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FreeTextAnnotationsResponse
     */
    public function getPageFreeTextAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageFreeTextAnnotationsWithHttpInfo
     *
     * Read document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FreeTextAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationsResponse';
        $request = $this->getPageFreeTextAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FreeTextAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageFreeTextAnnotationsAsync
     *
     * Read document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageFreeTextAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageFreeTextAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageFreeTextAnnotationsAsyncWithHttpInfo
     *
     * Read document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageFreeTextAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationsResponse';
        $request = $this->getPageFreeTextAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageFreeTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageFreeTextAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageFreeTextAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageFreeTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/freetext';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageHighlightAnnotations
     *
     * Read document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\HighlightAnnotationsResponse
     */
    public function getPageHighlightAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageHighlightAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageHighlightAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageHighlightAnnotationsWithHttpInfo
     *
     * Read document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\HighlightAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageHighlightAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationsResponse';
        $request = $this->getPageHighlightAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\HighlightAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageHighlightAnnotationsAsync
     *
     * Read document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageHighlightAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageHighlightAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageHighlightAnnotationsAsyncWithHttpInfo
     *
     * Read document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageHighlightAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationsResponse';
        $request = $this->getPageHighlightAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageHighlightAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageHighlightAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageHighlightAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageHighlightAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/highlight';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageInkAnnotations
     *
     * Read document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\InkAnnotationsResponse
     */
    public function getPageInkAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageInkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageInkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageInkAnnotationsWithHttpInfo
     *
     * Read document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\InkAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageInkAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationsResponse';
        $request = $this->getPageInkAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\InkAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageInkAnnotationsAsync
     *
     * Read document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageInkAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageInkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageInkAnnotationsAsyncWithHttpInfo
     *
     * Read document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageInkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationsResponse';
        $request = $this->getPageInkAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageInkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageInkAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageInkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageInkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/ink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLineAnnotations
     *
     * Read document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LineAnnotationsResponse
     */
    public function getPageLineAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageLineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageLineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageLineAnnotationsWithHttpInfo
     *
     * Read document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLineAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationsResponse';
        $request = $this->getPageLineAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLineAnnotationsAsync
     *
     * Read document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLineAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageLineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLineAnnotationsAsyncWithHttpInfo
     *
     * Read document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationsResponse';
        $request = $this->getPageLineAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLineAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/line';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLinkAnnotation
     *
     * Read document page link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationResponse
     */
    public function getPageLinkAnnotation($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageLinkAnnotationWithHttpInfo($name, $page_number, $link_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageLinkAnnotationWithHttpInfo($name, $page_number, $link_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageLinkAnnotationWithHttpInfo
     *
     * Read document page link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLinkAnnotationWithHttpInfo($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getPageLinkAnnotationRequest($name, $page_number, $link_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLinkAnnotationAsync
     *
     * Read document page link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationAsync($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        return $this->getPageLinkAnnotationAsyncWithHttpInfo($name, $page_number, $link_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLinkAnnotationAsyncWithHttpInfo
     *
     * Read document page link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationAsyncWithHttpInfo($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getPageLinkAnnotationRequest($name, $page_number, $link_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLinkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLinkAnnotationRequest($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLinkAnnotation'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLinkAnnotation'
            );
        }
        // verify the required parameter 'link_id' is set
        if ($link_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_id when calling getPageLinkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links/{linkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'linkId' . '}',
                ObjectSerializer::toPathValue($link_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLinkAnnotations
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationsResponse
     */
    public function getPageLinkAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageLinkAnnotationsWithHttpInfo
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationsResponse';
        $request = $this->getPageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLinkAnnotationsAsync
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLinkAnnotationsAsyncWithHttpInfo
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationsResponse';
        $request = $this->getPageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLinkAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLinkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagePolyLineAnnotations
     *
     * Read document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolyLineAnnotationsResponse
     */
    public function getPagePolyLineAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPagePolyLineAnnotationsWithHttpInfo
     *
     * Read document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolyLineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationsResponse';
        $request = $this->getPagePolyLineAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolyLineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagePolyLineAnnotationsAsync
     *
     * Read document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePolyLineAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPagePolyLineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagePolyLineAnnotationsAsyncWithHttpInfo
     *
     * Read document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePolyLineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationsResponse';
        $request = $this->getPagePolyLineAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagePolyLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagePolyLineAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPagePolyLineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPagePolyLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/polyline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagePolygonAnnotations
     *
     * Read document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolygonAnnotationsResponse
     */
    public function getPagePolygonAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPagePolygonAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPagePolygonAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPagePolygonAnnotationsWithHttpInfo
     *
     * Read document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolygonAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagePolygonAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationsResponse';
        $request = $this->getPagePolygonAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolygonAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagePolygonAnnotationsAsync
     *
     * Read document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePolygonAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPagePolygonAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagePolygonAnnotationsAsyncWithHttpInfo
     *
     * Read document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePolygonAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationsResponse';
        $request = $this->getPagePolygonAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagePolygonAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagePolygonAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPagePolygonAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPagePolygonAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/polygon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagePopupAnnotations
     *
     * Read document page popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationsResponse
     */
    public function getPagePopupAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPagePopupAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPagePopupAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPagePopupAnnotationsWithHttpInfo
     *
     * Read document page popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagePopupAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getPagePopupAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagePopupAnnotationsAsync
     *
     * Read document page popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePopupAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPagePopupAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagePopupAnnotationsAsyncWithHttpInfo
     *
     * Read document page popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePopupAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getPagePopupAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagePopupAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagePopupAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPagePopupAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPagePopupAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/popup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageSquareAnnotations
     *
     * Read document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquareAnnotationsResponse
     */
    public function getPageSquareAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageSquareAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageSquareAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageSquareAnnotationsWithHttpInfo
     *
     * Read document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquareAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageSquareAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationsResponse';
        $request = $this->getPageSquareAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquareAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageSquareAnnotationsAsync
     *
     * Read document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSquareAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageSquareAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageSquareAnnotationsAsyncWithHttpInfo
     *
     * Read document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSquareAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationsResponse';
        $request = $this->getPageSquareAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageSquareAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageSquareAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageSquareAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageSquareAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/square';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageSquigglyAnnotations
     *
     * Read document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquigglyAnnotationsResponse
     */
    public function getPageSquigglyAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageSquigglyAnnotationsWithHttpInfo
     *
     * Read document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquigglyAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationsResponse';
        $request = $this->getPageSquigglyAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquigglyAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageSquigglyAnnotationsAsync
     *
     * Read document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSquigglyAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageSquigglyAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageSquigglyAnnotationsAsyncWithHttpInfo
     *
     * Read document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSquigglyAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationsResponse';
        $request = $this->getPageSquigglyAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageSquigglyAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageSquigglyAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageSquigglyAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageSquigglyAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/squiggly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageStrikeOutAnnotations
     *
     * Read document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StrikeOutAnnotationsResponse
     */
    public function getPageStrikeOutAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageStrikeOutAnnotationsWithHttpInfo
     *
     * Read document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StrikeOutAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationsResponse';
        $request = $this->getPageStrikeOutAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StrikeOutAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageStrikeOutAnnotationsAsync
     *
     * Read document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageStrikeOutAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageStrikeOutAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageStrikeOutAnnotationsAsyncWithHttpInfo
     *
     * Read document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageStrikeOutAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationsResponse';
        $request = $this->getPageStrikeOutAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageStrikeOutAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageStrikeOutAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageStrikeOutAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageStrikeOutAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/strikeout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageText
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextRectsResponse
     */
    public function getPageText($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageTextWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageTextWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageTextWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextRectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageTextWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getPageTextRequest($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextRectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageTextAsync
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAsync($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        return $this->getPageTextAsyncWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageTextAsyncWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAsyncWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getPageTextRequest($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageText'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageTextRequest($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageText'
            );
        }
        // verify the required parameter 'llx' is set
        if ($llx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $llx when calling getPageText'
            );
        }
        // verify the required parameter 'lly' is set
        if ($lly === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lly when calling getPageText'
            );
        }
        // verify the required parameter 'urx' is set
        if ($urx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $urx when calling getPageText'
            );
        }
        // verify the required parameter 'ury' is set
        if ($ury === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ury when calling getPageText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($format)) {
            $format = ObjectSerializer::serializeCollection($format, 'multi', true);
        }
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($regex !== null) {
            $queryParams['regex'] = ObjectSerializer::toQueryValue($regex);
        }
        // query params
        if ($split_rects !== null) {
            $queryParams['splitRects'] = ObjectSerializer::toQueryValue($split_rects);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($llx !== null) {
            $queryParams['LLX'] = ObjectSerializer::toQueryValue($llx);
        }
        // query params
        if ($lly !== null) {
            $queryParams['LLY'] = ObjectSerializer::toQueryValue($lly);
        }
        // query params
        if ($urx !== null) {
            $queryParams['URX'] = ObjectSerializer::toQueryValue($urx);
        }
        // query params
        if ($ury !== null) {
            $queryParams['URY'] = ObjectSerializer::toQueryValue($ury);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageTextAnnotations
     *
     * Read document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextAnnotationsResponse
     */
    public function getPageTextAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageTextAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageTextAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageTextAnnotationsWithHttpInfo
     *
     * Read document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageTextAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationsResponse';
        $request = $this->getPageTextAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageTextAnnotationsAsync
     *
     * Read document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageTextAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageTextAnnotationsAsyncWithHttpInfo
     *
     * Read document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationsResponse';
        $request = $this->getPageTextAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageTextAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageTextAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageUnderlineAnnotations
     *
     * Read document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\UnderlineAnnotationsResponse
     */
    public function getPageUnderlineAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageUnderlineAnnotationsWithHttpInfo
     *
     * Read document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\UnderlineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationsResponse';
        $request = $this->getPageUnderlineAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\UnderlineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageUnderlineAnnotationsAsync
     *
     * Read document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageUnderlineAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageUnderlineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageUnderlineAnnotationsAsyncWithHttpInfo
     *
     * Read document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageUnderlineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationsResponse';
        $request = $this->getPageUnderlineAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageUnderlineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageUnderlineAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageUnderlineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageUnderlineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/underline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPages
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPagesResponse
     */
    public function getPages($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPagesWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPagesWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPagesWithHttpInfo
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->getPagesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagesAsync
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesAsync($name, $storage = null, $folder = null)
    {
        return $this->getPagesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagesAsyncWithHttpInfo
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->getPagesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPages'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPages'
            );
        }

        $resourcePath = '/pdf/{name}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPclInStorageToPdf
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPclInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getPclInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPclInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPclInStorageToPdfWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPclInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPclInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPclInStorageToPdfAsync
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPclInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getPclInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPclInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPclInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPclInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPclInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPclInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getPclInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/pcl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToDoc
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToDoc($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToDocWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToDocRequest($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToDocAsync
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToDocAsync($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToDocAsyncWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToDocAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToDocAsyncWithHttpInfo($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToDocRequest($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToDoc'
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToDocRequest($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToDoc'
            );
        }

        $resourcePath = '/pdf/{name}/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToEpub
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToEpub($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToEpubWithHttpInfo($name, $content_recognition_mode, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToEpubWithHttpInfo($name, $content_recognition_mode, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToEpubWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToEpubWithHttpInfo($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToEpubRequest($name, $content_recognition_mode, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToEpubAsync
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToEpubAsync($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToEpubAsyncWithHttpInfo($name, $content_recognition_mode, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToEpubAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToEpubAsyncWithHttpInfo($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToEpubRequest($name, $content_recognition_mode, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToEpub'
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToEpubRequest($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToEpub'
            );
        }

        $resourcePath = '/pdf/{name}/convert/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($content_recognition_mode !== null) {
            $queryParams['contentRecognitionMode'] = ObjectSerializer::toQueryValue($content_recognition_mode);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToHtml
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToHtml($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToHtmlWithHttpInfo($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToHtmlWithHttpInfo($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToHtmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToHtmlWithHttpInfo($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToHtmlRequest($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToHtmlAsync
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToHtmlAsync($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToHtmlAsyncWithHttpInfo($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToHtmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToHtmlAsyncWithHttpInfo($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToHtmlRequest($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToHtml'
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToHtmlRequest($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToHtml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($additional_margin_width_in_points !== null) {
            $queryParams['additionalMarginWidthInPoints'] = ObjectSerializer::toQueryValue($additional_margin_width_in_points);
        }
        // query params
        if ($compress_svg_graphics_if_any !== null) {
            $queryParams['compressSvgGraphicsIfAny'] = ObjectSerializer::toQueryValue($compress_svg_graphics_if_any);
        }
        // query params
        if ($convert_marked_content_to_layers !== null) {
            $queryParams['convertMarkedContentToLayers'] = ObjectSerializer::toQueryValue($convert_marked_content_to_layers);
        }
        // query params
        if ($default_font_name !== null) {
            $queryParams['defaultFontName'] = ObjectSerializer::toQueryValue($default_font_name);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($fixed_layout !== null) {
            $queryParams['fixedLayout'] = ObjectSerializer::toQueryValue($fixed_layout);
        }
        // query params
        if ($image_resolution !== null) {
            $queryParams['imageResolution'] = ObjectSerializer::toQueryValue($image_resolution);
        }
        // query params
        if ($minimal_line_width !== null) {
            $queryParams['minimalLineWidth'] = ObjectSerializer::toQueryValue($minimal_line_width);
        }
        // query params
        if ($prevent_glyphs_grouping !== null) {
            $queryParams['preventGlyphsGrouping'] = ObjectSerializer::toQueryValue($prevent_glyphs_grouping);
        }
        // query params
        if ($split_css_into_pages !== null) {
            $queryParams['splitCssIntoPages'] = ObjectSerializer::toQueryValue($split_css_into_pages);
        }
        // query params
        if ($split_into_pages !== null) {
            $queryParams['splitIntoPages'] = ObjectSerializer::toQueryValue($split_into_pages);
        }
        // query params
        if ($use_z_order !== null) {
            $queryParams['useZOrder'] = ObjectSerializer::toQueryValue($use_z_order);
        }
        // query params
        if ($antialiasing_processing !== null) {
            $queryParams['antialiasingProcessing'] = ObjectSerializer::toQueryValue($antialiasing_processing);
        }
        // query params
        if ($css_class_names_prefix !== null) {
            $queryParams['cssClassNamesPrefix'] = ObjectSerializer::toQueryValue($css_class_names_prefix);
        }
        // query params
        if (is_array($explicit_list_of_saved_pages)) {
            $explicit_list_of_saved_pages = ObjectSerializer::serializeCollection($explicit_list_of_saved_pages, 'multi', true);
        }
        if ($explicit_list_of_saved_pages !== null) {
            $queryParams['explicitListOfSavedPages'] = ObjectSerializer::toQueryValue($explicit_list_of_saved_pages);
        }
        // query params
        if ($font_encoding_strategy !== null) {
            $queryParams['fontEncodingStrategy'] = ObjectSerializer::toQueryValue($font_encoding_strategy);
        }
        // query params
        if ($font_saving_mode !== null) {
            $queryParams['fontSavingMode'] = ObjectSerializer::toQueryValue($font_saving_mode);
        }
        // query params
        if ($html_markup_generation_mode !== null) {
            $queryParams['htmlMarkupGenerationMode'] = ObjectSerializer::toQueryValue($html_markup_generation_mode);
        }
        // query params
        if ($letters_positioning_method !== null) {
            $queryParams['lettersPositioningMethod'] = ObjectSerializer::toQueryValue($letters_positioning_method);
        }
        // query params
        if ($pages_flow_type_depends_on_viewers_screen_size !== null) {
            $queryParams['pagesFlowTypeDependsOnViewersScreenSize'] = ObjectSerializer::toQueryValue($pages_flow_type_depends_on_viewers_screen_size);
        }
        // query params
        if ($parts_embedding_mode !== null) {
            $queryParams['partsEmbeddingMode'] = ObjectSerializer::toQueryValue($parts_embedding_mode);
        }
        // query params
        if ($raster_images_saving_mode !== null) {
            $queryParams['rasterImagesSavingMode'] = ObjectSerializer::toQueryValue($raster_images_saving_mode);
        }
        // query params
        if ($remove_empty_areas_on_top_and_bottom !== null) {
            $queryParams['removeEmptyAreasOnTopAndBottom'] = ObjectSerializer::toQueryValue($remove_empty_areas_on_top_and_bottom);
        }
        // query params
        if ($save_shadowed_texts_as_transparent_texts !== null) {
            $queryParams['saveShadowedTextsAsTransparentTexts'] = ObjectSerializer::toQueryValue($save_shadowed_texts_as_transparent_texts);
        }
        // query params
        if ($save_transparent_texts !== null) {
            $queryParams['saveTransparentTexts'] = ObjectSerializer::toQueryValue($save_transparent_texts);
        }
        // query params
        if ($special_folder_for_all_images !== null) {
            $queryParams['specialFolderForAllImages'] = ObjectSerializer::toQueryValue($special_folder_for_all_images);
        }
        // query params
        if ($special_folder_for_svg_images !== null) {
            $queryParams['specialFolderForSvgImages'] = ObjectSerializer::toQueryValue($special_folder_for_svg_images);
        }
        // query params
        if ($try_save_text_underlining_and_strikeouting_in_css !== null) {
            $queryParams['trySaveTextUnderliningAndStrikeoutingInCss'] = ObjectSerializer::toQueryValue($try_save_text_underlining_and_strikeouting_in_css);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToLaTeX
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToLaTeX($name, $pages_count = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToLaTeXWithHttpInfo($name, $pages_count, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToLaTeXWithHttpInfo($name, $pages_count, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToLaTeXWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToLaTeXWithHttpInfo($name, $pages_count = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToLaTeXRequest($name, $pages_count, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToLaTeXAsync
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToLaTeXAsync($name, $pages_count = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToLaTeXAsyncWithHttpInfo($name, $pages_count, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToLaTeXAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToLaTeXAsyncWithHttpInfo($name, $pages_count = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToLaTeXRequest($name, $pages_count, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToLaTeX'
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToLaTeXRequest($name, $pages_count = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToLaTeX'
            );
        }

        $resourcePath = '/pdf/{name}/convert/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pages_count !== null) {
            $queryParams['pagesCount'] = ObjectSerializer::toQueryValue($pages_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToMobiXml
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToMobiXml($name, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToMobiXmlWithHttpInfo($name, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToMobiXmlWithHttpInfo($name, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToMobiXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToMobiXmlWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToMobiXmlRequest($name, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToMobiXmlAsync
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToMobiXmlAsync($name, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToMobiXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToMobiXmlRequest($name, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToMobiXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToMobiXmlRequest($name, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToMobiXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/mobixml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToPdfA
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToPdfA($name, $type, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToPdfAWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPdfARequest($name, $type, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToPdfAAsync
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPdfAAsync($name, $type, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToPdfAAsyncWithHttpInfo($name, $type, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPdfAAsyncWithHttpInfo($name, $type, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPdfARequest($name, $type, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToPdfA'
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToPdfARequest($name, $type, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getPdfInStorageToPdfA'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToPptx
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToPptx($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToPptxWithHttpInfo($name, $separate_images, $slides_as_images, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToPptxWithHttpInfo($name, $separate_images, $slides_as_images, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToPptxWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToPptxWithHttpInfo($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPptxRequest($name, $separate_images, $slides_as_images, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToPptxAsync
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPptxAsync($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToPptxAsyncWithHttpInfo($name, $separate_images, $slides_as_images, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToPptxAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPptxAsyncWithHttpInfo($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPptxRequest($name, $separate_images, $slides_as_images, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToPptx'
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToPptxRequest($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToPptx'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pptx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($separate_images !== null) {
            $queryParams['separateImages'] = ObjectSerializer::toQueryValue($separate_images);
        }
        // query params
        if ($slides_as_images !== null) {
            $queryParams['slidesAsImages'] = ObjectSerializer::toQueryValue($slides_as_images);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToSvg
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToSvg($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToSvgWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToSvgAsync
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToSvgAsync($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToSvgAsyncWithHttpInfo($name, $compress_output_to_zip_archive, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToSvgAsyncWithHttpInfo($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToSvg'
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToSvg'
            );
        }

        $resourcePath = '/pdf/{name}/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($compress_output_to_zip_archive !== null) {
            $queryParams['compressOutputToZipArchive'] = ObjectSerializer::toQueryValue($compress_output_to_zip_archive);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToTiff
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToTiff($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToTiffWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToTiffWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToTiffWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToTiffWithHttpInfo($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToTiffRequest($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToTiffAsync
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToTiffAsync($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToTiffAsyncWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToTiffAsyncWithHttpInfo($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToTiffRequest($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToTiffRequest($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXls
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXls($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToXlsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXlsAsync
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsAsync($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToXlsAsyncWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsAsyncWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXls'
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXls'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXml
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXml($name, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToXmlWithHttpInfo($name, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToXmlWithHttpInfo($name, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXmlWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXmlRequest($name, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXmlAsync
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXmlAsync($name, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToXmlAsyncWithHttpInfo($name, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXmlAsyncWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXmlRequest($name, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXmlRequest($name, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXps
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXps($name, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToXpsWithHttpInfo($name, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToXpsWithHttpInfo($name, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToXpsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXpsWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXpsRequest($name, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXpsAsync
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXpsAsync($name, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToXpsAsyncWithHttpInfo($name, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXpsAsyncWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXpsRequest($name, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXps'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXpsRequest($name, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXps'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPolyLineAnnotation
     *
     * Read document page polyline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolyLineAnnotationResponse
     */
    public function getPolyLineAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPolyLineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPolyLineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPolyLineAnnotationWithHttpInfo
     *
     * Read document page polyline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolyLineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPolyLineAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationResponse';
        $request = $this->getPolyLineAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolyLineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPolyLineAnnotationAsync
     *
     * Read document page polyline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPolyLineAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getPolyLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPolyLineAnnotationAsyncWithHttpInfo
     *
     * Read document page polyline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPolyLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationResponse';
        $request = $this->getPolyLineAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPolyLineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPolyLineAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPolyLineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getPolyLineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polyline/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPolygonAnnotation
     *
     * Read document page polygon annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolygonAnnotationResponse
     */
    public function getPolygonAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPolygonAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPolygonAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPolygonAnnotationWithHttpInfo
     *
     * Read document page polygon annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolygonAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPolygonAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationResponse';
        $request = $this->getPolygonAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolygonAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPolygonAnnotationAsync
     *
     * Read document page polygon annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPolygonAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getPolygonAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPolygonAnnotationAsyncWithHttpInfo
     *
     * Read document page polygon annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPolygonAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationResponse';
        $request = $this->getPolygonAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPolygonAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPolygonAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPolygonAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getPolygonAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polygon/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPopupAnnotation
     *
     * Read document page popup annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationResponse
     */
    public function getPopupAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPopupAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPopupAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPopupAnnotationWithHttpInfo
     *
     * Read document page popup annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPopupAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationResponse';
        $request = $this->getPopupAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPopupAnnotationAsync
     *
     * Read document page popup annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPopupAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPopupAnnotationAsyncWithHttpInfo
     *
     * Read document page popup annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationResponse';
        $request = $this->getPopupAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPopupAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPopupAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getPopupAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/popup/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPsInStorageToPdf
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPsInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getPsInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPsInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPsInStorageToPdfWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPsInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPsInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPsInStorageToPdfAsync
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPsInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getPsInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPsInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPsInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPsInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPsInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getPsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/ps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSquareAnnotation
     *
     * Read document page square annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquareAnnotationResponse
     */
    public function getSquareAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getSquareAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getSquareAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getSquareAnnotationWithHttpInfo
     *
     * Read document page square annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquareAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSquareAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationResponse';
        $request = $this->getSquareAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquareAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSquareAnnotationAsync
     *
     * Read document page square annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSquareAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getSquareAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSquareAnnotationAsyncWithHttpInfo
     *
     * Read document page square annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSquareAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationResponse';
        $request = $this->getSquareAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSquareAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSquareAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSquareAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getSquareAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/square/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSquigglyAnnotation
     *
     * Read document page squiggly annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquigglyAnnotationResponse
     */
    public function getSquigglyAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getSquigglyAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getSquigglyAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getSquigglyAnnotationWithHttpInfo
     *
     * Read document page squiggly annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquigglyAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSquigglyAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationResponse';
        $request = $this->getSquigglyAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquigglyAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSquigglyAnnotationAsync
     *
     * Read document page squiggly annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSquigglyAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getSquigglyAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSquigglyAnnotationAsyncWithHttpInfo
     *
     * Read document page squiggly annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSquigglyAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationResponse';
        $request = $this->getSquigglyAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSquigglyAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSquigglyAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSquigglyAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getSquigglyAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/squiggly/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStrikeOutAnnotation
     *
     * Read document page StrikeOut annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StrikeOutAnnotationResponse
     */
    public function getStrikeOutAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getStrikeOutAnnotationWithHttpInfo
     *
     * Read document page StrikeOut annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StrikeOutAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationResponse';
        $request = $this->getStrikeOutAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StrikeOutAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStrikeOutAnnotationAsync
     *
     * Read document page StrikeOut annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStrikeOutAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getStrikeOutAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStrikeOutAnnotationAsyncWithHttpInfo
     *
     * Read document page StrikeOut annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStrikeOutAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationResponse';
        $request = $this->getStrikeOutAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStrikeOutAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStrikeOutAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getStrikeOutAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getStrikeOutAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/strikeout/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSvgInStorageToPdf
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getSvgInStorageToPdf($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        try
        {
            list($response) = $this->getSvgInStorageToPdfWithHttpInfo($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getSvgInStorageToPdfWithHttpInfo($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getSvgInStorageToPdfWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSvgInStorageToPdfWithHttpInfo($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getSvgInStorageToPdfRequest($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSvgInStorageToPdfAsync
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSvgInStorageToPdfAsync($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        return $this->getSvgInStorageToPdfAsyncWithHttpInfo($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSvgInStorageToPdfAsyncWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSvgInStorageToPdfAsyncWithHttpInfo($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getSvgInStorageToPdfRequest($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSvgInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSvgInStorageToPdfRequest($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getSvgInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($adjust_page_size !== null) {
            $queryParams['adjustPageSize'] = ObjectSerializer::toQueryValue($adjust_page_size);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getText
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextRectsResponse
     */
    public function getText($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getTextWithHttpInfo($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getTextWithHttpInfo($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getTextWithHttpInfo
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextRectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTextWithHttpInfo($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getTextRequest($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextRectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTextAsync
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAsync($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        return $this->getTextAsyncWithHttpInfo($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTextAsyncWithHttpInfo
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAsyncWithHttpInfo($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getTextRequest($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getText'
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTextRequest($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getText'
            );
        }
        // verify the required parameter 'llx' is set
        if ($llx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $llx when calling getText'
            );
        }
        // verify the required parameter 'lly' is set
        if ($lly === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lly when calling getText'
            );
        }
        // verify the required parameter 'urx' is set
        if ($urx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $urx when calling getText'
            );
        }
        // verify the required parameter 'ury' is set
        if ($ury === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ury when calling getText'
            );
        }

        $resourcePath = '/pdf/{name}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($format)) {
            $format = ObjectSerializer::serializeCollection($format, 'multi', true);
        }
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($regex !== null) {
            $queryParams['regex'] = ObjectSerializer::toQueryValue($regex);
        }
        // query params
        if ($split_rects !== null) {
            $queryParams['splitRects'] = ObjectSerializer::toQueryValue($split_rects);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($llx !== null) {
            $queryParams['LLX'] = ObjectSerializer::toQueryValue($llx);
        }
        // query params
        if ($lly !== null) {
            $queryParams['LLY'] = ObjectSerializer::toQueryValue($lly);
        }
        // query params
        if ($urx !== null) {
            $queryParams['URX'] = ObjectSerializer::toQueryValue($urx);
        }
        // query params
        if ($ury !== null) {
            $queryParams['URY'] = ObjectSerializer::toQueryValue($ury);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTextAnnotation
     *
     * Read document page text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextAnnotationResponse
     */
    public function getTextAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getTextAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getTextAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getTextAnnotationWithHttpInfo
     *
     * Read document page text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTextAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationResponse';
        $request = $this->getTextAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTextAnnotationAsync
     *
     * Read document page text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTextAnnotationAsyncWithHttpInfo
     *
     * Read document page text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationResponse';
        $request = $this->getTextAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTextAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTextAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getTextAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getTextAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/text/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUnderlineAnnotation
     *
     * Read document page underline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\UnderlineAnnotationResponse
     */
    public function getUnderlineAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getUnderlineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getUnderlineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getUnderlineAnnotationWithHttpInfo
     *
     * Read document page underline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\UnderlineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUnderlineAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationResponse';
        $request = $this->getUnderlineAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\UnderlineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUnderlineAnnotationAsync
     *
     * Read document page underline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnderlineAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getUnderlineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUnderlineAnnotationAsyncWithHttpInfo
     *
     * Read document page underline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnderlineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationResponse';
        $request = $this->getUnderlineAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUnderlineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUnderlineAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getUnderlineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getUnderlineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/underline/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVerifySignature
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SignatureVerifyResponse
     */
    public function getVerifySignature($name, $sign_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getVerifySignatureWithHttpInfo($name, $sign_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getVerifySignatureWithHttpInfo($name, $sign_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getVerifySignatureWithHttpInfo
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SignatureVerifyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVerifySignatureWithHttpInfo($name, $sign_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SignatureVerifyResponse';
        $request = $this->getVerifySignatureRequest($name, $sign_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SignatureVerifyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVerifySignatureAsync
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVerifySignatureAsync($name, $sign_name, $storage = null, $folder = null)
    {
        return $this->getVerifySignatureAsyncWithHttpInfo($name, $sign_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVerifySignatureAsyncWithHttpInfo
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVerifySignatureAsyncWithHttpInfo($name, $sign_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SignatureVerifyResponse';
        $request = $this->getVerifySignatureRequest($name, $sign_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVerifySignature'
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVerifySignatureRequest($name, $sign_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getVerifySignature'
            );
        }
        // verify the required parameter 'sign_name' is set
        if ($sign_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sign_name when calling getVerifySignature'
            );
        }

        $resourcePath = '/pdf/{name}/verifySignature';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sign_name !== null) {
            $queryParams['signName'] = ObjectSerializer::toQueryValue($sign_name);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebInStorageToPdf
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getWebInStorageToPdf($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        try
        {
            list($response) = $this->getWebInStorageToPdfWithHttpInfo($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getWebInStorageToPdfWithHttpInfo($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getWebInStorageToPdfWithHttpInfo
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebInStorageToPdfWithHttpInfo($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getWebInStorageToPdfRequest($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebInStorageToPdfAsync
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebInStorageToPdfAsync($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        return $this->getWebInStorageToPdfAsyncWithHttpInfo($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebInStorageToPdfAsyncWithHttpInfo
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebInStorageToPdfAsyncWithHttpInfo($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getWebInStorageToPdfRequest($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebInStorageToPdf'
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebInStorageToPdfRequest($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        // verify the required parameter 'url' is set
        if ($url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling getWebInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/web';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWordsPerPage
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\WordCountResponse
     */
    public function getWordsPerPage($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getWordsPerPageWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getWordsPerPageWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getWordsPerPageWithHttpInfo
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\WordCountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWordsPerPageWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\WordCountResponse';
        $request = $this->getWordsPerPageRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\WordCountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWordsPerPageAsync
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWordsPerPageAsync($name, $storage = null, $folder = null)
    {
        return $this->getWordsPerPageAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWordsPerPageAsyncWithHttpInfo
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWordsPerPageAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\WordCountResponse';
        $request = $this->getWordsPerPageRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWordsPerPage'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWordsPerPageRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getWordsPerPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/wordCount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXfaPdfInStorageToAcroForm
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXfaPdfInStorageToAcroForm($name, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getXfaPdfInStorageToAcroFormWithHttpInfo($name, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getXfaPdfInStorageToAcroFormWithHttpInfo($name, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getXfaPdfInStorageToAcroFormWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXfaPdfInStorageToAcroFormWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXfaPdfInStorageToAcroFormRequest($name, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXfaPdfInStorageToAcroFormAsync
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXfaPdfInStorageToAcroFormAsync($name, $folder = null, $storage = null)
    {
        return $this->getXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXfaPdfInStorageToAcroFormAsyncWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXfaPdfInStorageToAcroFormRequest($name, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXfaPdfInStorageToAcroForm'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXfaPdfInStorageToAcroFormRequest($name, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getXfaPdfInStorageToAcroForm'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xfatoacroform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXmlInStorageToPdf
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXmlInStorageToPdf($src_path, $xsl_file_path = null, $storage = null)
    {
        try
        {
            list($response) = $this->getXmlInStorageToPdfWithHttpInfo($src_path, $xsl_file_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getXmlInStorageToPdfWithHttpInfo($src_path, $xsl_file_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getXmlInStorageToPdfWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXmlInStorageToPdfWithHttpInfo($src_path, $xsl_file_path = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXmlInStorageToPdfRequest($src_path, $xsl_file_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXmlInStorageToPdfAsync
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXmlInStorageToPdfAsync($src_path, $xsl_file_path = null, $storage = null)
    {
        return $this->getXmlInStorageToPdfAsyncWithHttpInfo($src_path, $xsl_file_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXmlInStorageToPdfAsyncWithHttpInfo($src_path, $xsl_file_path = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXmlInStorageToPdfRequest($src_path, $xsl_file_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXmlInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXmlInStorageToPdfRequest($src_path, $xsl_file_path = null, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getXmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($xsl_file_path !== null) {
            $queryParams['xslFilePath'] = ObjectSerializer::toQueryValue($xsl_file_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXpsInStorageToPdf
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXpsInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getXpsInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getXpsInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getXpsInStorageToPdfWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXpsInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXpsInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXpsInStorageToPdfAsync
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXpsInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getXpsInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXpsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXpsInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXpsInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXpsInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXpsInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getXpsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXslFoInStorageToPdf
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXslFoInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getXslFoInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getXslFoInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getXslFoInStorageToPdfWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXslFoInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXslFoInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXslFoInStorageToPdfAsync
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXslFoInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getXslFoInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXslFoInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXslFoInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXslFoInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXslFoInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXslFoInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getXslFoInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/xslfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAppendDocument
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function postAppendDocument($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postAppendDocumentWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postAppendDocumentWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postAppendDocumentWithHttpInfo
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAppendDocumentWithHttpInfo($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->postAppendDocumentRequest($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAppendDocumentAsync
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAppendDocumentAsync($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        return $this->postAppendDocumentAsyncWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAppendDocumentAsyncWithHttpInfo
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAppendDocumentAsyncWithHttpInfo($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->postAppendDocumentRequest($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAppendDocument'
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAppendDocumentRequest($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postAppendDocument'
            );
        }

        $resourcePath = '/pdf/{name}/appendDocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($append_file !== null) {
            $queryParams['appendFile'] = ObjectSerializer::toQueryValue($append_file);
        }
        // query params
        if ($start_page !== null) {
            $queryParams['startPage'] = ObjectSerializer::toQueryValue($start_page);
        }
        // query params
        if ($end_page !== null) {
            $queryParams['endPage'] = ObjectSerializer::toQueryValue($end_page);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($append_document)) {
            $_tempBody = $append_document;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCreateField
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postCreateField($name, $page, $field = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postCreateFieldWithHttpInfo($name, $page, $field, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postCreateFieldWithHttpInfo($name, $page, $field, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postCreateFieldWithHttpInfo
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCreateFieldWithHttpInfo($name, $page, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postCreateFieldRequest($name, $page, $field, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCreateFieldAsync
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCreateFieldAsync($name, $page, $field = null, $storage = null, $folder = null)
    {
        return $this->postCreateFieldAsyncWithHttpInfo($name, $page, $field, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCreateFieldAsyncWithHttpInfo
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCreateFieldAsyncWithHttpInfo($name, $page, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postCreateFieldRequest($name, $page, $field, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCreateField'
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postCreateFieldRequest($name, $page, $field = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postCreateField'
            );
        }
        // verify the required parameter 'page' is set
        if ($page === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling postCreateField'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($field)) {
            $_tempBody = $field;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentTextReplace
     *
     * Document's replace text method.
     *
     * @param  string $name name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace text_replace (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextReplaceResponse
     */
    public function postDocumentTextReplace($name, $text_replace, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postDocumentTextReplaceWithHttpInfo
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postDocumentTextReplaceRequest($name, $text_replace, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentTextReplaceAsync
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextReplaceAsync($name, $text_replace, $storage = null, $folder = null)
    {
        return $this->postDocumentTextReplaceAsyncWithHttpInfo($name, $text_replace, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentTextReplaceAsyncWithHttpInfo
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextReplaceAsyncWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postDocumentTextReplaceRequest($name, $text_replace, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentTextReplace'
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentTextReplaceRequest($name, $text_replace, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentTextReplace'
            );
        }
        // verify the required parameter 'text_replace' is set
        if ($text_replace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace when calling postDocumentTextReplace'
            );
        }

        $resourcePath = '/pdf/{name}/text/replace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace)) {
            $_tempBody = $text_replace;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFlattenDocument
     *
     * Removes all fields from the document and place their values instead.
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postFlattenDocument($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postFlattenDocumentWithHttpInfo($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postFlattenDocumentWithHttpInfo($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postFlattenDocumentWithHttpInfo
     *
     * Removes all fields from the document and place their values instead.
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFlattenDocumentWithHttpInfo($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postFlattenDocumentRequest($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFlattenDocumentAsync
     *
     * Removes all fields from the document and place their values instead.
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFlattenDocumentAsync($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        return $this->postFlattenDocumentAsyncWithHttpInfo($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFlattenDocumentAsyncWithHttpInfo
     *
     * Removes all fields from the document and place their values instead.
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFlattenDocumentAsyncWithHttpInfo($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postFlattenDocumentRequest($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFlattenDocument'
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFlattenDocumentRequest($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postFlattenDocument'
            );
        }

        $resourcePath = '/pdf/{name}/flatten';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($update_appearances !== null) {
            $queryParams['updateAppearances'] = ObjectSerializer::toQueryValue($update_appearances);
        }
        // query params
        if ($call_events !== null) {
            $queryParams['callEvents'] = ObjectSerializer::toQueryValue($call_events);
        }
        // query params
        if ($hide_buttons !== null) {
            $queryParams['hideButtons'] = ObjectSerializer::toQueryValue($hide_buttons);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postInsertImage
     *
     * Insert image to document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postInsertImage($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        try
        {
            list($response) = $this->postInsertImageWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postInsertImageWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postInsertImageWithHttpInfo
     *
     * Insert image to document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postInsertImageWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postInsertImageRequest($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postInsertImageAsync
     *
     * Insert image to document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInsertImageAsync($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        return $this->postInsertImageAsyncWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postInsertImageAsyncWithHttpInfo
     *
     * Insert image to document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInsertImageAsyncWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postInsertImageRequest($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postInsertImage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postInsertImageRequest($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postInsertImage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postInsertImage'
            );
        }
        // verify the required parameter 'llx' is set
        if ($llx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $llx when calling postInsertImage'
            );
        }
        // verify the required parameter 'lly' is set
        if ($lly === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lly when calling postInsertImage'
            );
        }
        // verify the required parameter 'urx' is set
        if ($urx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $urx when calling postInsertImage'
            );
        }
        // verify the required parameter 'ury' is set
        if ($ury === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ury when calling postInsertImage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($llx !== null) {
            $queryParams['llx'] = ObjectSerializer::toQueryValue($llx);
        }
        // query params
        if ($lly !== null) {
            $queryParams['lly'] = ObjectSerializer::toQueryValue($lly);
        }
        // query params
        if ($urx !== null) {
            $queryParams['urx'] = ObjectSerializer::toQueryValue($urx);
        }
        // query params
        if ($ury !== null) {
            $queryParams['ury'] = ObjectSerializer::toQueryValue($ury);
        }
        // query params
        if ($image_file_path !== null) {
            $queryParams['imageFilePath'] = ObjectSerializer::toQueryValue($image_file_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // form params
        if ($image !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($image);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['image'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['image'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postMoveFile
     *
     * Move a specific file
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postMoveFile($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        try
        {
            list($response) = $this->postMoveFileWithHttpInfo($src, $dest, $version_id, $storage, $dest_storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postMoveFileWithHttpInfo($src, $dest, $version_id, $storage, $dest_storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postMoveFileWithHttpInfo
     *
     * Move a specific file
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMoveFileWithHttpInfo($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMoveFileRequest($src, $dest, $version_id, $storage, $dest_storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postMoveFileAsync
     *
     * Move a specific file
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMoveFileAsync($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        return $this->postMoveFileAsyncWithHttpInfo($src, $dest, $version_id, $storage, $dest_storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postMoveFileAsyncWithHttpInfo
     *
     * Move a specific file
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMoveFileAsyncWithHttpInfo($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMoveFileRequest($src, $dest, $version_id, $storage, $dest_storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postMoveFile'
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postMoveFileRequest($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        // verify the required parameter 'src' is set
        if ($src === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src when calling postMoveFile'
            );
        }
        // verify the required parameter 'dest' is set
        if ($dest === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dest when calling postMoveFile'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src !== null) {
            $queryParams['src'] = ObjectSerializer::toQueryValue($src);
        }
        // query params
        if ($dest !== null) {
            $queryParams['dest'] = ObjectSerializer::toQueryValue($dest);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($dest_storage !== null) {
            $queryParams['destStorage'] = ObjectSerializer::toQueryValue($dest_storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postMoveFolder
     *
     * Move a specific folder
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postMoveFolder($src, $dest, $storage = null, $dest_storage = null)
    {
        try
        {
            list($response) = $this->postMoveFolderWithHttpInfo($src, $dest, $storage, $dest_storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postMoveFolderWithHttpInfo($src, $dest, $storage, $dest_storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postMoveFolderWithHttpInfo
     *
     * Move a specific folder
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMoveFolderWithHttpInfo($src, $dest, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMoveFolderRequest($src, $dest, $storage, $dest_storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postMoveFolderAsync
     *
     * Move a specific folder
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMoveFolderAsync($src, $dest, $storage = null, $dest_storage = null)
    {
        return $this->postMoveFolderAsyncWithHttpInfo($src, $dest, $storage, $dest_storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postMoveFolderAsyncWithHttpInfo
     *
     * Move a specific folder
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMoveFolderAsyncWithHttpInfo($src, $dest, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMoveFolderRequest($src, $dest, $storage, $dest_storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postMoveFolder'
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postMoveFolderRequest($src, $dest, $storage = null, $dest_storage = null)
    {
        // verify the required parameter 'src' is set
        if ($src === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src when calling postMoveFolder'
            );
        }
        // verify the required parameter 'dest' is set
        if ($dest === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dest when calling postMoveFolder'
            );
        }

        $resourcePath = '/storage/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src !== null) {
            $queryParams['src'] = ObjectSerializer::toQueryValue($src);
        }
        // query params
        if ($dest !== null) {
            $queryParams['dest'] = ObjectSerializer::toQueryValue($dest);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($dest_storage !== null) {
            $queryParams['destStorage'] = ObjectSerializer::toQueryValue($dest_storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postMovePage
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postMovePage($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postMovePageWithHttpInfo($name, $page_number, $new_index, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postMovePageWithHttpInfo($name, $page_number, $new_index, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postMovePageWithHttpInfo
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMovePageWithHttpInfo($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMovePageRequest($name, $page_number, $new_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postMovePageAsync
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMovePageAsync($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        return $this->postMovePageAsyncWithHttpInfo($name, $page_number, $new_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postMovePageAsyncWithHttpInfo
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMovePageAsyncWithHttpInfo($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMovePageRequest($name, $page_number, $new_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postMovePage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postMovePageRequest($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postMovePage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postMovePage'
            );
        }
        // verify the required parameter 'new_index' is set
        if ($new_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_index when calling postMovePage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/movePage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_index !== null) {
            $queryParams['newIndex'] = ObjectSerializer::toQueryValue($new_index);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postOptimizeDocument
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postOptimizeDocument($name, $options = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postOptimizeDocumentWithHttpInfo($name, $options, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postOptimizeDocumentWithHttpInfo($name, $options, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postOptimizeDocumentWithHttpInfo
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postOptimizeDocumentWithHttpInfo($name, $options = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postOptimizeDocumentRequest($name, $options, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postOptimizeDocumentAsync
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOptimizeDocumentAsync($name, $options = null, $storage = null, $folder = null)
    {
        return $this->postOptimizeDocumentAsyncWithHttpInfo($name, $options, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postOptimizeDocumentAsyncWithHttpInfo
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOptimizeDocumentAsyncWithHttpInfo($name, $options = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postOptimizeDocumentRequest($name, $options, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postOptimizeDocument'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postOptimizeDocumentRequest($name, $options = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postOptimizeDocument'
            );
        }

        $resourcePath = '/pdf/{name}/optimize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($options)) {
            $_tempBody = $options;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageCaretAnnotations
     *
     * Add document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageCaretAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageCaretAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageCaretAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageCaretAnnotationsWithHttpInfo
     *
     * Add document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageCaretAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageCaretAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageCaretAnnotationsAsync
     *
     * Add document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageCaretAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageCaretAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageCaretAnnotationsAsyncWithHttpInfo
     *
     * Add document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageCaretAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageCaretAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageCaretAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageCaretAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageCaretAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageCaretAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageCaretAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/caret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageCircleAnnotations
     *
     * Add document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageCircleAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageCircleAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageCircleAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageCircleAnnotationsWithHttpInfo
     *
     * Add document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageCircleAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageCircleAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageCircleAnnotationsAsync
     *
     * Add document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageCircleAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageCircleAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageCircleAnnotationsAsyncWithHttpInfo
     *
     * Add document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageCircleAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageCircleAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageCircleAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageCircleAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageCircleAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageCircleAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageCircleAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/circle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageFreeTextAnnotations
     *
     * Add document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageFreeTextAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageFreeTextAnnotationsWithHttpInfo
     *
     * Add document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageFreeTextAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageFreeTextAnnotationsAsync
     *
     * Add document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageFreeTextAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageFreeTextAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageFreeTextAnnotationsAsyncWithHttpInfo
     *
     * Add document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageFreeTextAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageFreeTextAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageFreeTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageFreeTextAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageFreeTextAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageFreeTextAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageFreeTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/freetext';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageHighlightAnnotations
     *
     * Add document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageHighlightAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageHighlightAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageHighlightAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageHighlightAnnotationsWithHttpInfo
     *
     * Add document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageHighlightAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageHighlightAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageHighlightAnnotationsAsync
     *
     * Add document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageHighlightAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageHighlightAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageHighlightAnnotationsAsyncWithHttpInfo
     *
     * Add document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageHighlightAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageHighlightAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageHighlightAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageHighlightAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageHighlightAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageHighlightAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageHighlightAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/highlight';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageInkAnnotations
     *
     * Add document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageInkAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageInkAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageInkAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageInkAnnotationsWithHttpInfo
     *
     * Add document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageInkAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageInkAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageInkAnnotationsAsync
     *
     * Add document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageInkAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageInkAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageInkAnnotationsAsyncWithHttpInfo
     *
     * Add document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageInkAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageInkAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageInkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageInkAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageInkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageInkAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageInkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/ink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageLineAnnotations
     *
     * Add document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageLineAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageLineAnnotationsWithHttpInfo
     *
     * Add document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageLineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageLineAnnotationsAsync
     *
     * Add document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageLineAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageLineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageLineAnnotationsAsyncWithHttpInfo
     *
     * Add document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageLineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageLineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageLineAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageLineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageLineAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/line';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageLinkAnnotations
     *
     * Add document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageLinkAnnotations($name, $page_number, $links, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageLinkAnnotationsWithHttpInfo($name, $page_number, $links, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageLinkAnnotationsWithHttpInfo($name, $page_number, $links, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageLinkAnnotationsWithHttpInfo
     *
     * Add document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageLinkAnnotationsWithHttpInfo($name, $page_number, $links, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageLinkAnnotationsRequest($name, $page_number, $links, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageLinkAnnotationsAsync
     *
     * Add document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageLinkAnnotationsAsync($name, $page_number, $links, $storage = null, $folder = null)
    {
        return $this->postPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $links, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageLinkAnnotationsAsyncWithHttpInfo
     *
     * Add document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $links, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageLinkAnnotationsRequest($name, $page_number, $links, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageLinkAnnotationsRequest($name, $page_number, $links, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageLinkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageLinkAnnotations'
            );
        }
        // verify the required parameter 'links' is set
        if ($links === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $links when calling postPageLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($links)) {
            $_tempBody = $links;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagePolyLineAnnotations
     *
     * Add document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPagePolyLineAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPagePolyLineAnnotationsWithHttpInfo
     *
     * Add document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePolyLineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagePolyLineAnnotationsAsync
     *
     * Add document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePolyLineAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPagePolyLineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagePolyLineAnnotationsAsyncWithHttpInfo
     *
     * Add document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePolyLineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePolyLineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagePolyLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPagePolyLineAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPagePolyLineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPagePolyLineAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPagePolyLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/polyline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagePolygonAnnotations
     *
     * Add document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPagePolygonAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPagePolygonAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPagePolygonAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPagePolygonAnnotationsWithHttpInfo
     *
     * Add document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagePolygonAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePolygonAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagePolygonAnnotationsAsync
     *
     * Add document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePolygonAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPagePolygonAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagePolygonAnnotationsAsyncWithHttpInfo
     *
     * Add document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePolygonAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePolygonAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagePolygonAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPagePolygonAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPagePolygonAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPagePolygonAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPagePolygonAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/polygon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageSquareAnnotations
     *
     * Add document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageSquareAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageSquareAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageSquareAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageSquareAnnotationsWithHttpInfo
     *
     * Add document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageSquareAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSquareAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageSquareAnnotationsAsync
     *
     * Add document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSquareAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageSquareAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageSquareAnnotationsAsyncWithHttpInfo
     *
     * Add document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSquareAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSquareAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageSquareAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageSquareAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageSquareAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageSquareAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageSquareAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/square';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageSquigglyAnnotations
     *
     * Add document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageSquigglyAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageSquigglyAnnotationsWithHttpInfo
     *
     * Add document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSquigglyAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageSquigglyAnnotationsAsync
     *
     * Add document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSquigglyAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageSquigglyAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageSquigglyAnnotationsAsyncWithHttpInfo
     *
     * Add document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSquigglyAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSquigglyAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageSquigglyAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageSquigglyAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageSquigglyAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageSquigglyAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageSquigglyAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/squiggly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageStrikeOutAnnotations
     *
     * Add document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageStrikeOutAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageStrikeOutAnnotationsWithHttpInfo
     *
     * Add document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageStrikeOutAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageStrikeOutAnnotationsAsync
     *
     * Add document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageStrikeOutAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageStrikeOutAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageStrikeOutAnnotationsAsyncWithHttpInfo
     *
     * Add document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageStrikeOutAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageStrikeOutAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageStrikeOutAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageStrikeOutAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageStrikeOutAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageStrikeOutAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageStrikeOutAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/strikeout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageTextAnnotations
     *
     * Add document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageTextAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageTextAnnotationsWithHttpInfo
     *
     * Add document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageTextAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageTextAnnotationsAsync
     *
     * Add document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageTextAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageTextAnnotationsAsyncWithHttpInfo
     *
     * Add document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageTextAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageTextAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageTextAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageTextAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageTextReplace
     *
     * Page's replace text method.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request text_replace_list_request (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextReplaceResponse
     */
    public function postPageTextReplace($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageTextReplaceWithHttpInfo
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageTextReplaceAsync
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextReplaceAsync($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        return $this->postPageTextReplaceAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageTextReplaceAsyncWithHttpInfo
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextReplaceAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageTextReplace'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageTextReplace'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageTextReplace'
            );
        }
        // verify the required parameter 'text_replace_list_request' is set
        if ($text_replace_list_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace_list_request when calling postPageTextReplace'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text/replace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace_list_request)) {
            $_tempBody = $text_replace_list_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageUnderlineAnnotations
     *
     * Add document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageUnderlineAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageUnderlineAnnotationsWithHttpInfo
     *
     * Add document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageUnderlineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageUnderlineAnnotationsAsync
     *
     * Add document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageUnderlineAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageUnderlineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageUnderlineAnnotationsAsyncWithHttpInfo
     *
     * Add document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageUnderlineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageUnderlineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageUnderlineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageUnderlineAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageUnderlineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageUnderlineAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageUnderlineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/underline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPopupAnnotation
     *
     * Add document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPopupAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPopupAnnotationWithHttpInfo
     *
     * Add document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPopupAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPopupAnnotationAsync
     *
     * Add document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPopupAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->postPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPopupAnnotationAsyncWithHttpInfo
     *
     * Add document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPopupAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPopupAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPopupAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling postPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling postPopupAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/{annotationId}/popup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSignDocument
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postSignDocument($name, $signature = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postSignDocumentWithHttpInfo($name, $signature, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postSignDocumentWithHttpInfo($name, $signature, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postSignDocumentWithHttpInfo
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSignDocumentWithHttpInfo($name, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postSignDocumentRequest($name, $signature, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSignDocumentAsync
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignDocumentAsync($name, $signature = null, $storage = null, $folder = null)
    {
        return $this->postSignDocumentAsyncWithHttpInfo($name, $signature, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSignDocumentAsyncWithHttpInfo
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignDocumentAsyncWithHttpInfo($name, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postSignDocumentRequest($name, $signature, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSignDocument'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSignDocumentRequest($name, $signature = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSignDocument'
            );
        }

        $resourcePath = '/pdf/{name}/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($signature)) {
            $_tempBody = $signature;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSignPage
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postSignPage($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postSignPageWithHttpInfo($name, $page_number, $signature, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postSignPageWithHttpInfo($name, $page_number, $signature, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postSignPageWithHttpInfo
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSignPageWithHttpInfo($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postSignPageRequest($name, $page_number, $signature, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSignPageAsync
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignPageAsync($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        return $this->postSignPageAsyncWithHttpInfo($name, $page_number, $signature, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSignPageAsyncWithHttpInfo
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignPageAsyncWithHttpInfo($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postSignPageRequest($name, $page_number, $signature, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSignPage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSignPageRequest($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSignPage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postSignPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($signature)) {
            $_tempBody = $signature;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSplitDocument
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SplitResultResponse
     */
    public function postSplitDocument($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postSplitDocumentWithHttpInfo($name, $format, $from, $to, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postSplitDocumentWithHttpInfo($name, $format, $from, $to, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postSplitDocumentWithHttpInfo
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SplitResultResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSplitDocumentWithHttpInfo($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SplitResultResponse';
        $request = $this->postSplitDocumentRequest($name, $format, $from, $to, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SplitResultResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSplitDocumentAsync
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSplitDocumentAsync($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        return $this->postSplitDocumentAsyncWithHttpInfo($name, $format, $from, $to, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSplitDocumentAsyncWithHttpInfo
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSplitDocumentAsyncWithHttpInfo($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SplitResultResponse';
        $request = $this->postSplitDocumentRequest($name, $format, $from, $to, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSplitDocument'
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSplitDocumentRequest($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSplitDocument'
            );
        }

        $resourcePath = '/pdf/{name}/split';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddNewPage
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPagesResponse
     */
    public function putAddNewPage($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putAddNewPageWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putAddNewPageWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putAddNewPageWithHttpInfo
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddNewPageWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->putAddNewPageRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddNewPageAsync
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddNewPageAsync($name, $storage = null, $folder = null)
    {
        return $this->putAddNewPageAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddNewPageAsyncWithHttpInfo
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddNewPageAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->putAddNewPageRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddNewPage'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddNewPageRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddNewPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddText
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putAddText($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putAddTextWithHttpInfo($name, $page_number, $paragraph, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putAddTextWithHttpInfo($name, $page_number, $paragraph, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putAddTextWithHttpInfo
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddTextWithHttpInfo($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putAddTextRequest($name, $page_number, $paragraph, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddTextAsync
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddTextAsync($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        return $this->putAddTextAsyncWithHttpInfo($name, $page_number, $paragraph, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddTextAsyncWithHttpInfo
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddTextAsyncWithHttpInfo($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putAddTextRequest($name, $page_number, $paragraph, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddText'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddTextRequest($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putAddText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($paragraph)) {
            $_tempBody = $paragraph;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCaretAnnotation
     *
     * Replace document caret annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CaretAnnotationResponse
     */
    public function putCaretAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putCaretAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCaretAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCaretAnnotationWithHttpInfo
     *
     * Replace document caret annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CaretAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCaretAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationResponse';
        $request = $this->putCaretAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CaretAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCaretAnnotationAsync
     *
     * Replace document caret annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCaretAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putCaretAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCaretAnnotationAsyncWithHttpInfo
     *
     * Replace document caret annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCaretAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationResponse';
        $request = $this->putCaretAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCaretAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCaretAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCaretAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putCaretAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putCaretAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/caret/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCircleAnnotation
     *
     * Replace document circle annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CircleAnnotationResponse
     */
    public function putCircleAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putCircleAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCircleAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCircleAnnotationWithHttpInfo
     *
     * Replace document circle annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CircleAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCircleAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationResponse';
        $request = $this->putCircleAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CircleAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCircleAnnotationAsync
     *
     * Replace document circle annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCircleAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putCircleAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCircleAnnotationAsyncWithHttpInfo
     *
     * Replace document circle annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCircleAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationResponse';
        $request = $this->putCircleAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCircleAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCircleAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCircleAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putCircleAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putCircleAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/circle/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreate
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putCreate($path, $file, $version_id = null, $storage = null)
    {
        try
        {
            list($response) = $this->putCreateWithHttpInfo($path, $file, $version_id, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCreateWithHttpInfo($path, $file, $version_id, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCreateWithHttpInfo
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateWithHttpInfo($path, $file, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putCreateRequest($path, $file, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateAsync
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateAsync($path, $file, $version_id = null, $storage = null)
    {
        return $this->putCreateAsyncWithHttpInfo($path, $file, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateAsyncWithHttpInfo
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateAsyncWithHttpInfo($path, $file, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putCreateRequest($path, $file, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreate'
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateRequest($path, $file, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling putCreate'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling putCreate'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreateDocument
     *
     * Create empty document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function putCreateDocument($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putCreateDocumentWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCreateDocumentWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCreateDocumentWithHttpInfo
     *
     * Create empty document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateDocumentWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateDocumentAsync
     *
     * Create empty document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentAsync($name, $storage = null, $folder = null)
    {
        return $this->putCreateDocumentAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateDocumentAsyncWithHttpInfo
     *
     * Create empty document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreateDocument'
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateDocumentRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCreateDocument'
            );
        }

        $resourcePath = '/pdf/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreateFolder
     *
     * Create the folder
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putCreateFolder($path, $storage = null, $dest_storage = null)
    {
        try
        {
            list($response) = $this->putCreateFolderWithHttpInfo($path, $storage, $dest_storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCreateFolderWithHttpInfo($path, $storage, $dest_storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCreateFolderWithHttpInfo
     *
     * Create the folder
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateFolderWithHttpInfo($path, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putCreateFolderRequest($path, $storage, $dest_storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateFolderAsync
     *
     * Create the folder
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateFolderAsync($path, $storage = null, $dest_storage = null)
    {
        return $this->putCreateFolderAsyncWithHttpInfo($path, $storage, $dest_storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateFolderAsyncWithHttpInfo
     *
     * Create the folder
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateFolderAsyncWithHttpInfo($path, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putCreateFolderRequest($path, $storage, $dest_storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreateFolder'
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateFolderRequest($path, $storage = null, $dest_storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling putCreateFolder'
            );
        }

        $resourcePath = '/storage/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($dest_storage !== null) {
            $queryParams['destStorage'] = ObjectSerializer::toQueryValue($dest_storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putEpubInStorageToPdf
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putEpubInStorageToPdf($name, $src_path, $storage = null, $dst_folder = null)
    {
        try
        {
            list($response) = $this->putEpubInStorageToPdfWithHttpInfo($name, $src_path, $storage, $dst_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putEpubInStorageToPdfWithHttpInfo($name, $src_path, $storage, $dst_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putEpubInStorageToPdfWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putEpubInStorageToPdfWithHttpInfo($name, $src_path, $storage = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putEpubInStorageToPdfRequest($name, $src_path, $storage, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putEpubInStorageToPdfAsync
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putEpubInStorageToPdfAsync($name, $src_path, $storage = null, $dst_folder = null)
    {
        return $this->putEpubInStorageToPdfAsyncWithHttpInfo($name, $src_path, $storage, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putEpubInStorageToPdfAsyncWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putEpubInStorageToPdfAsyncWithHttpInfo($name, $src_path, $storage = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putEpubInStorageToPdfRequest($name, $src_path, $storage, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putEpubInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putEpubInStorageToPdfRequest($name, $src_path, $storage = null, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putEpubInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putEpubInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFieldsFlatten
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putFieldsFlatten($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putFieldsFlattenWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putFieldsFlattenWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putFieldsFlattenWithHttpInfo
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFieldsFlattenWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putFieldsFlattenRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFieldsFlattenAsync
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldsFlattenAsync($name, $storage = null, $folder = null)
    {
        return $this->putFieldsFlattenAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFieldsFlattenAsyncWithHttpInfo
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldsFlattenAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putFieldsFlattenRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFieldsFlatten'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFieldsFlattenRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putFieldsFlatten'
            );
        }

        $resourcePath = '/pdf/{name}/fields/flatten';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFreeTextAnnotation
     *
     * Replace document free text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FreeTextAnnotationResponse
     */
    public function putFreeTextAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putFreeTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putFreeTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putFreeTextAnnotationWithHttpInfo
     *
     * Replace document free text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FreeTextAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFreeTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationResponse';
        $request = $this->putFreeTextAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FreeTextAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFreeTextAnnotationAsync
     *
     * Replace document free text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFreeTextAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putFreeTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFreeTextAnnotationAsyncWithHttpInfo
     *
     * Replace document free text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFreeTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationResponse';
        $request = $this->putFreeTextAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFreeTextAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFreeTextAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putFreeTextAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putFreeTextAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putFreeTextAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/freetext/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putHighlightAnnotation
     *
     * Replace document highlight annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\HighlightAnnotationResponse
     */
    public function putHighlightAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putHighlightAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putHighlightAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putHighlightAnnotationWithHttpInfo
     *
     * Replace document highlight annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\HighlightAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putHighlightAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationResponse';
        $request = $this->putHighlightAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\HighlightAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putHighlightAnnotationAsync
     *
     * Replace document highlight annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHighlightAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putHighlightAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putHighlightAnnotationAsyncWithHttpInfo
     *
     * Replace document highlight annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHighlightAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationResponse';
        $request = $this->putHighlightAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putHighlightAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putHighlightAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putHighlightAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putHighlightAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putHighlightAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/highlight/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putHtmlInStorageToPdf
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putHtmlInStorageToPdf($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putHtmlInStorageToPdfWithHttpInfo($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putHtmlInStorageToPdfWithHttpInfo($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putHtmlInStorageToPdfWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putHtmlInStorageToPdfWithHttpInfo($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putHtmlInStorageToPdfRequest($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putHtmlInStorageToPdfAsync
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHtmlInStorageToPdfAsync($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        return $this->putHtmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putHtmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHtmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putHtmlInStorageToPdfRequest($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putHtmlInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putHtmlInStorageToPdfRequest($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putHtmlInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putHtmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($html_file_name !== null) {
            $queryParams['htmlFileName'] = ObjectSerializer::toQueryValue($html_file_name);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageExtractAsGif
     *
     * Extract document image in GIF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageExtractAsGif($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImageExtractAsGifWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageExtractAsGifWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageExtractAsGifWithHttpInfo
     *
     * Extract document image in GIF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageExtractAsGifWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsGifRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageExtractAsGifAsync
     *
     * Extract document image in GIF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsGifAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImageExtractAsGifAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageExtractAsGifAsyncWithHttpInfo
     *
     * Extract document image in GIF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsGifAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsGifRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageExtractAsGif'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageExtractAsGifRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageExtractAsGif'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putImageExtractAsGif'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageExtractAsJpeg
     *
     * Extract document image in JPEG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageExtractAsJpeg($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImageExtractAsJpegWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageExtractAsJpegWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageExtractAsJpegWithHttpInfo
     *
     * Extract document image in JPEG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageExtractAsJpegWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsJpegRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageExtractAsJpegAsync
     *
     * Extract document image in JPEG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsJpegAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImageExtractAsJpegAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageExtractAsJpegAsyncWithHttpInfo
     *
     * Extract document image in JPEG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsJpegAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsJpegRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageExtractAsJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageExtractAsJpegRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageExtractAsJpeg'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putImageExtractAsJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageExtractAsPng
     *
     * Extract document image in PNG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageExtractAsPng($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImageExtractAsPngWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageExtractAsPngWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageExtractAsPngWithHttpInfo
     *
     * Extract document image in PNG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageExtractAsPngWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsPngRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageExtractAsPngAsync
     *
     * Extract document image in PNG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsPngAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImageExtractAsPngAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageExtractAsPngAsyncWithHttpInfo
     *
     * Extract document image in PNG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsPngAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsPngRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageExtractAsPng'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageExtractAsPngRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageExtractAsPng'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putImageExtractAsPng'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageExtractAsTiff
     *
     * Extract document image in TIFF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageExtractAsTiff($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImageExtractAsTiffWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageExtractAsTiffWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageExtractAsTiffWithHttpInfo
     *
     * Extract document image in TIFF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageExtractAsTiffWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsTiffRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageExtractAsTiffAsync
     *
     * Extract document image in TIFF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsTiffAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImageExtractAsTiffAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageExtractAsTiffAsyncWithHttpInfo
     *
     * Extract document image in TIFF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsTiffAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsTiffRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageExtractAsTiff'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageExtractAsTiffRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageExtractAsTiff'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putImageExtractAsTiff'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageInStorageToPdf
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageInStorageToPdf($name, $image_templates, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putImageInStorageToPdfWithHttpInfo($name, $image_templates, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageInStorageToPdfWithHttpInfo($name, $image_templates, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageInStorageToPdfWithHttpInfo
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageInStorageToPdfWithHttpInfo($name, $image_templates, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageInStorageToPdfRequest($name, $image_templates, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageInStorageToPdfAsync
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageInStorageToPdfAsync($name, $image_templates, $dst_folder = null, $storage = null)
    {
        return $this->putImageInStorageToPdfAsyncWithHttpInfo($name, $image_templates, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageInStorageToPdfAsyncWithHttpInfo
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageInStorageToPdfAsyncWithHttpInfo($name, $image_templates, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageInStorageToPdfRequest($name, $image_templates, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageInStorageToPdfRequest($name, $image_templates, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageInStorageToPdf'
            );
        }
        // verify the required parameter 'image_templates' is set
        if ($image_templates === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_templates when calling putImageInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($image_templates)) {
            $_tempBody = $image_templates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsGif
     *
     * Extract document images in GIF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImagesExtractAsGif($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImagesExtractAsGifWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImagesExtractAsGifWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImagesExtractAsGifWithHttpInfo
     *
     * Extract document images in GIF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsGifWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsGifRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsGifAsync
     *
     * Extract document images in GIF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsGifAsync($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsGifAsyncWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsGifAsyncWithHttpInfo
     *
     * Extract document images in GIF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsGifAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsGifRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsGif'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsGifRequest($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsGif'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsGif'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsJpeg
     *
     * Extract document images in JPEG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImagesExtractAsJpeg($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImagesExtractAsJpegWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImagesExtractAsJpegWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImagesExtractAsJpegWithHttpInfo
     *
     * Extract document images in JPEG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsJpegWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsJpegRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsJpegAsync
     *
     * Extract document images in JPEG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsJpegAsync($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsJpegAsyncWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsJpegAsyncWithHttpInfo
     *
     * Extract document images in JPEG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsJpegAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsJpegRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsJpegRequest($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsJpeg'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsPng
     *
     * Extract document images in PNG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImagesExtractAsPng($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImagesExtractAsPngWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImagesExtractAsPngWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImagesExtractAsPngWithHttpInfo
     *
     * Extract document images in PNG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsPngWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsPngRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsPngAsync
     *
     * Extract document images in PNG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsPngAsync($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsPngAsyncWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsPngAsyncWithHttpInfo
     *
     * Extract document images in PNG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsPngAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsPngRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsPng'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsPngRequest($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsPng'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsPng'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsTiff
     *
     * Extract document images in TIFF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImagesExtractAsTiff($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImagesExtractAsTiffWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImagesExtractAsTiffWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImagesExtractAsTiffWithHttpInfo
     *
     * Extract document images in TIFF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsTiffWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsTiffRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsTiffAsync
     *
     * Extract document images in TIFF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsTiffAsync($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsTiffAsyncWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsTiffAsyncWithHttpInfo
     *
     * Extract document images in TIFF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsTiffAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsTiffRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsTiff'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsTiffRequest($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsTiff'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsTiff'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putInkAnnotation
     *
     * Replace document ink annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\InkAnnotationResponse
     */
    public function putInkAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putInkAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putInkAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putInkAnnotationWithHttpInfo
     *
     * Replace document ink annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\InkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putInkAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationResponse';
        $request = $this->putInkAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\InkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putInkAnnotationAsync
     *
     * Replace document ink annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInkAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putInkAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putInkAnnotationAsyncWithHttpInfo
     *
     * Replace document ink annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInkAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationResponse';
        $request = $this->putInkAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putInkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putInkAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putInkAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putInkAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putInkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/ink/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putLaTeXInStorageToPdf
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putLaTeXInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putLaTeXInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putLaTeXInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putLaTeXInStorageToPdfWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putLaTeXInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putLaTeXInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putLaTeXInStorageToPdfAsync
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLaTeXInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putLaTeXInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putLaTeXInStorageToPdfAsyncWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLaTeXInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putLaTeXInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putLaTeXInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putLaTeXInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putLaTeXInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putLaTeXInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putLineAnnotation
     *
     * Replace document line annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LineAnnotationResponse
     */
    public function putLineAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putLineAnnotationWithHttpInfo
     *
     * Replace document line annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationResponse';
        $request = $this->putLineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putLineAnnotationAsync
     *
     * Replace document line annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLineAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putLineAnnotationAsyncWithHttpInfo
     *
     * Replace document line annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationResponse';
        $request = $this->putLineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putLineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putLineAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putLineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putLineAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putLineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/line/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putLinkAnnotation
     *
     * Replace document page link annotations
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationResponse
     */
    public function putLinkAnnotation($name, $link_id, $link, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putLinkAnnotationWithHttpInfo($name, $link_id, $link, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putLinkAnnotationWithHttpInfo($name, $link_id, $link, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putLinkAnnotationWithHttpInfo
     *
     * Replace document page link annotations
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putLinkAnnotationWithHttpInfo($name, $link_id, $link, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->putLinkAnnotationRequest($name, $link_id, $link, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putLinkAnnotationAsync
     *
     * Replace document page link annotations
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLinkAnnotationAsync($name, $link_id, $link, $storage = null, $folder = null)
    {
        return $this->putLinkAnnotationAsyncWithHttpInfo($name, $link_id, $link, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putLinkAnnotationAsyncWithHttpInfo
     *
     * Replace document page link annotations
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLinkAnnotationAsyncWithHttpInfo($name, $link_id, $link, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->putLinkAnnotationRequest($name, $link_id, $link, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putLinkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putLinkAnnotationRequest($name, $link_id, $link, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putLinkAnnotation'
            );
        }
        // verify the required parameter 'link_id' is set
        if ($link_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_id when calling putLinkAnnotation'
            );
        }
        // verify the required parameter 'link' is set
        if ($link === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link when calling putLinkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/links/{linkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'linkId' . '}',
                ObjectSerializer::toPathValue($link_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($link)) {
            $_tempBody = $link;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMergeDocuments
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function putMergeDocuments($name, $merge_documents = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putMergeDocumentsWithHttpInfo($name, $merge_documents, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putMergeDocumentsWithHttpInfo($name, $merge_documents, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putMergeDocumentsWithHttpInfo
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMergeDocumentsWithHttpInfo($name, $merge_documents = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putMergeDocumentsRequest($name, $merge_documents, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putMergeDocumentsAsync
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMergeDocumentsAsync($name, $merge_documents = null, $storage = null, $folder = null)
    {
        return $this->putMergeDocumentsAsyncWithHttpInfo($name, $merge_documents, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMergeDocumentsAsyncWithHttpInfo
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMergeDocumentsAsyncWithHttpInfo($name, $merge_documents = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->putMergeDocumentsRequest($name, $merge_documents, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMergeDocuments'
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMergeDocumentsRequest($name, $merge_documents = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putMergeDocuments'
            );
        }

        $resourcePath = '/pdf/{name}/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($merge_documents)) {
            $_tempBody = $merge_documents;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMhtInStorageToPdf
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putMhtInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putMhtInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putMhtInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putMhtInStorageToPdfWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMhtInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putMhtInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putMhtInStorageToPdfAsync
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMhtInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putMhtInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMhtInStorageToPdfAsyncWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMhtInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putMhtInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMhtInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMhtInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putMhtInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putMhtInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/mht';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageAddStamp
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageAddStamp($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageAddStampWithHttpInfo
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageAddStampRequest($name, $page_number, $stamp, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageAddStampAsync
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageAddStampAsync($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        return $this->putPageAddStampAsyncWithHttpInfo($name, $page_number, $stamp, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageAddStampAsyncWithHttpInfo
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageAddStampAsyncWithHttpInfo($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageAddStampRequest($name, $page_number, $stamp, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageAddStamp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageAddStampRequest($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageAddStamp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageAddStamp'
            );
        }
        // verify the required parameter 'stamp' is set
        if ($stamp === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamp when calling putPageAddStamp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/stamp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($stamp)) {
            $_tempBody = $stamp;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToBmp
     *
     * Convert document page to bmp image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToBmp($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToBmpWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToBmpWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToBmpWithHttpInfo
     *
     * Convert document page to bmp image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToBmpWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToBmpRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToBmpAsync
     *
     * Convert document page to bmp image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToBmpAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToBmpAsyncWithHttpInfo
     *
     * Convert document page to bmp image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToBmpRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToBmp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToBmpRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToBmp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToBmp'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToBmp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/bmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToEmf
     *
     * Convert document page to emf image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToEmf($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToEmfWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToEmfWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToEmfWithHttpInfo
     *
     * Convert document page to emf image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToEmfWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToEmfRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToEmfAsync
     *
     * Convert document page to emf image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToEmfAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToEmfAsyncWithHttpInfo
     *
     * Convert document page to emf image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToEmfRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToEmf'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToEmfRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToEmf'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToEmf'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToEmf'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/emf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToGif
     *
     * Convert document page to gif image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToGif($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToGifWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToGifWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToGifWithHttpInfo
     *
     * Convert document page to gif image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToGifWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToGifRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToGifAsync
     *
     * Convert document page to gif image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToGifAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToGifAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToGifAsyncWithHttpInfo
     *
     * Convert document page to gif image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToGifAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToGifRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToGif'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToGifRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToGif'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToGif'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToGif'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToJpeg
     *
     * Convert document page to Jpeg image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToJpeg($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToJpegWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToJpegWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToJpegWithHttpInfo
     *
     * Convert document page to Jpeg image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToJpegWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToJpegRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToJpegAsync
     *
     * Convert document page to Jpeg image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToJpegAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToJpegAsyncWithHttpInfo
     *
     * Convert document page to Jpeg image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToJpegRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToJpegRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToJpeg'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToJpeg'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToPng
     *
     * Convert document page to png image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToPng($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToPngWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToPngWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToPngWithHttpInfo
     *
     * Convert document page to png image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToPngWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToPngRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToPngAsync
     *
     * Convert document page to png image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToPngAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToPngAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToPngAsyncWithHttpInfo
     *
     * Convert document page to png image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToPngAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToPngRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToPng'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToPngRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToPng'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToPng'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToPng'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToTiff
     *
     * Convert document page to Tiff image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToTiff($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToTiffWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToTiffWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToTiffWithHttpInfo
     *
     * Convert document page to Tiff image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToTiffWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToTiffRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToTiffAsync
     *
     * Convert document page to Tiff image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToTiffAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToTiffAsyncWithHttpInfo
     *
     * Convert document page to Tiff image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToTiffRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToTiffRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToTiff'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToTiff'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPclInStorageToPdf
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPclInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPclInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPclInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPclInStorageToPdfWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPclInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPclInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPclInStorageToPdfAsync
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPclInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putPclInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPclInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPclInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPclInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPclInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPclInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPclInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putPclInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/pcl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToDoc
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToDoc($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToDocWithHttpInfo
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToDocRequest($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToDocAsync
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToDocAsync($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToDocAsyncWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToDocAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToDocAsyncWithHttpInfo($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToDocRequest($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToDoc'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToDocRequest($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToDoc'
            );
        }

        $resourcePath = '/pdf/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToEpub
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToEpub($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToEpubWithHttpInfo($out_path, $content_recognition_mode, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToEpubWithHttpInfo($out_path, $content_recognition_mode, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToEpubWithHttpInfo
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToEpubWithHttpInfo($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToEpubRequest($out_path, $content_recognition_mode, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToEpubAsync
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToEpubAsync($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToEpubAsyncWithHttpInfo($out_path, $content_recognition_mode, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToEpubAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToEpubAsyncWithHttpInfo($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToEpubRequest($out_path, $content_recognition_mode, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToEpub'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToEpubRequest($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToEpub'
            );
        }

        $resourcePath = '/pdf/convert/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($content_recognition_mode !== null) {
            $queryParams['contentRecognitionMode'] = ObjectSerializer::toQueryValue($content_recognition_mode);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToHtml
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToHtml($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToHtmlWithHttpInfo($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToHtmlWithHttpInfo($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToHtmlWithHttpInfo
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToHtmlWithHttpInfo($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToHtmlRequest($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToHtmlAsync
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToHtmlAsync($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToHtmlAsyncWithHttpInfo($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToHtmlAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToHtmlAsyncWithHttpInfo($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToHtmlRequest($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToHtml'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToHtmlRequest($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToHtml'
            );
        }

        $resourcePath = '/pdf/convert/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($additional_margin_width_in_points !== null) {
            $queryParams['additionalMarginWidthInPoints'] = ObjectSerializer::toQueryValue($additional_margin_width_in_points);
        }
        // query params
        if ($compress_svg_graphics_if_any !== null) {
            $queryParams['compressSvgGraphicsIfAny'] = ObjectSerializer::toQueryValue($compress_svg_graphics_if_any);
        }
        // query params
        if ($convert_marked_content_to_layers !== null) {
            $queryParams['convertMarkedContentToLayers'] = ObjectSerializer::toQueryValue($convert_marked_content_to_layers);
        }
        // query params
        if ($default_font_name !== null) {
            $queryParams['defaultFontName'] = ObjectSerializer::toQueryValue($default_font_name);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($fixed_layout !== null) {
            $queryParams['fixedLayout'] = ObjectSerializer::toQueryValue($fixed_layout);
        }
        // query params
        if ($image_resolution !== null) {
            $queryParams['imageResolution'] = ObjectSerializer::toQueryValue($image_resolution);
        }
        // query params
        if ($minimal_line_width !== null) {
            $queryParams['minimalLineWidth'] = ObjectSerializer::toQueryValue($minimal_line_width);
        }
        // query params
        if ($prevent_glyphs_grouping !== null) {
            $queryParams['preventGlyphsGrouping'] = ObjectSerializer::toQueryValue($prevent_glyphs_grouping);
        }
        // query params
        if ($split_css_into_pages !== null) {
            $queryParams['splitCssIntoPages'] = ObjectSerializer::toQueryValue($split_css_into_pages);
        }
        // query params
        if ($split_into_pages !== null) {
            $queryParams['splitIntoPages'] = ObjectSerializer::toQueryValue($split_into_pages);
        }
        // query params
        if ($use_z_order !== null) {
            $queryParams['useZOrder'] = ObjectSerializer::toQueryValue($use_z_order);
        }
        // query params
        if ($antialiasing_processing !== null) {
            $queryParams['antialiasingProcessing'] = ObjectSerializer::toQueryValue($antialiasing_processing);
        }
        // query params
        if ($css_class_names_prefix !== null) {
            $queryParams['cssClassNamesPrefix'] = ObjectSerializer::toQueryValue($css_class_names_prefix);
        }
        // query params
        if (is_array($explicit_list_of_saved_pages)) {
            $explicit_list_of_saved_pages = ObjectSerializer::serializeCollection($explicit_list_of_saved_pages, 'multi', true);
        }
        if ($explicit_list_of_saved_pages !== null) {
            $queryParams['explicitListOfSavedPages'] = ObjectSerializer::toQueryValue($explicit_list_of_saved_pages);
        }
        // query params
        if ($font_encoding_strategy !== null) {
            $queryParams['fontEncodingStrategy'] = ObjectSerializer::toQueryValue($font_encoding_strategy);
        }
        // query params
        if ($font_saving_mode !== null) {
            $queryParams['fontSavingMode'] = ObjectSerializer::toQueryValue($font_saving_mode);
        }
        // query params
        if ($html_markup_generation_mode !== null) {
            $queryParams['htmlMarkupGenerationMode'] = ObjectSerializer::toQueryValue($html_markup_generation_mode);
        }
        // query params
        if ($letters_positioning_method !== null) {
            $queryParams['lettersPositioningMethod'] = ObjectSerializer::toQueryValue($letters_positioning_method);
        }
        // query params
        if ($pages_flow_type_depends_on_viewers_screen_size !== null) {
            $queryParams['pagesFlowTypeDependsOnViewersScreenSize'] = ObjectSerializer::toQueryValue($pages_flow_type_depends_on_viewers_screen_size);
        }
        // query params
        if ($parts_embedding_mode !== null) {
            $queryParams['partsEmbeddingMode'] = ObjectSerializer::toQueryValue($parts_embedding_mode);
        }
        // query params
        if ($raster_images_saving_mode !== null) {
            $queryParams['rasterImagesSavingMode'] = ObjectSerializer::toQueryValue($raster_images_saving_mode);
        }
        // query params
        if ($remove_empty_areas_on_top_and_bottom !== null) {
            $queryParams['removeEmptyAreasOnTopAndBottom'] = ObjectSerializer::toQueryValue($remove_empty_areas_on_top_and_bottom);
        }
        // query params
        if ($save_shadowed_texts_as_transparent_texts !== null) {
            $queryParams['saveShadowedTextsAsTransparentTexts'] = ObjectSerializer::toQueryValue($save_shadowed_texts_as_transparent_texts);
        }
        // query params
        if ($save_transparent_texts !== null) {
            $queryParams['saveTransparentTexts'] = ObjectSerializer::toQueryValue($save_transparent_texts);
        }
        // query params
        if ($special_folder_for_all_images !== null) {
            $queryParams['specialFolderForAllImages'] = ObjectSerializer::toQueryValue($special_folder_for_all_images);
        }
        // query params
        if ($special_folder_for_svg_images !== null) {
            $queryParams['specialFolderForSvgImages'] = ObjectSerializer::toQueryValue($special_folder_for_svg_images);
        }
        // query params
        if ($try_save_text_underlining_and_strikeouting_in_css !== null) {
            $queryParams['trySaveTextUnderliningAndStrikeoutingInCss'] = ObjectSerializer::toQueryValue($try_save_text_underlining_and_strikeouting_in_css);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToLaTeX
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToLaTeX($out_path, $pages_count = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToLaTeXWithHttpInfo($out_path, $pages_count, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToLaTeXWithHttpInfo($out_path, $pages_count, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToLaTeXWithHttpInfo
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToLaTeXWithHttpInfo($out_path, $pages_count = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToLaTeXRequest($out_path, $pages_count, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToLaTeXAsync
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToLaTeXAsync($out_path, $pages_count = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToLaTeXAsyncWithHttpInfo($out_path, $pages_count, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToLaTeXAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToLaTeXAsyncWithHttpInfo($out_path, $pages_count = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToLaTeXRequest($out_path, $pages_count, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToLaTeX'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToLaTeXRequest($out_path, $pages_count = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToLaTeX'
            );
        }

        $resourcePath = '/pdf/convert/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($pages_count !== null) {
            $queryParams['pagesCount'] = ObjectSerializer::toQueryValue($pages_count);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToMobiXml
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToMobiXml($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToMobiXmlWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToMobiXmlWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToMobiXmlWithHttpInfo
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToMobiXmlWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToMobiXmlRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToMobiXmlAsync
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToMobiXmlAsync($out_path, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToMobiXmlAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToMobiXmlAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToMobiXmlAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToMobiXmlRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToMobiXml'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToMobiXmlRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToMobiXml'
            );
        }

        $resourcePath = '/pdf/convert/mobixml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToPdfA
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToPdfA($out_path, $type, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToPdfAWithHttpInfo
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToPdfARequest($out_path, $type, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToPdfAAsync
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPdfAAsync($out_path, $type, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToPdfAAsyncWithHttpInfo($out_path, $type, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPdfAAsyncWithHttpInfo($out_path, $type, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToPdfARequest($out_path, $type, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToPdfA'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToPdfARequest($out_path, $type, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling putPdfInRequestToPdfA'
            );
        }

        $resourcePath = '/pdf/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToPptx
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToPptx($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToPptxWithHttpInfo($out_path, $separate_images, $slides_as_images, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToPptxWithHttpInfo($out_path, $separate_images, $slides_as_images, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToPptxWithHttpInfo
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToPptxWithHttpInfo($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToPptxRequest($out_path, $separate_images, $slides_as_images, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToPptxAsync
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPptxAsync($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToPptxAsyncWithHttpInfo($out_path, $separate_images, $slides_as_images, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToPptxAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPptxAsyncWithHttpInfo($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToPptxRequest($out_path, $separate_images, $slides_as_images, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToPptx'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToPptxRequest($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToPptx'
            );
        }

        $resourcePath = '/pdf/convert/pptx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($separate_images !== null) {
            $queryParams['separateImages'] = ObjectSerializer::toQueryValue($separate_images);
        }
        // query params
        if ($slides_as_images !== null) {
            $queryParams['slidesAsImages'] = ObjectSerializer::toQueryValue($slides_as_images);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToSvg
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToSvg($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToSvgWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToSvgWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToSvgWithHttpInfo
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToSvgWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToSvgRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToSvgAsync
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToSvgAsync($out_path, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToSvgAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToSvgAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToSvgRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToSvg'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToSvgRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToSvg'
            );
        }

        $resourcePath = '/pdf/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToTiff
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToTiff($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToTiffWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToTiffWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToTiffWithHttpInfo
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToTiffWithHttpInfo($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToTiffRequest($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToTiffAsync
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToTiffAsync($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToTiffAsyncWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToTiffAsyncWithHttpInfo($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToTiffRequest($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToTiff'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToTiffRequest($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToTiff'
            );
        }

        $resourcePath = '/pdf/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXls
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToXls($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToXlsWithHttpInfo
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXlsAsync
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsAsync($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToXlsAsyncWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsAsyncWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXls'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXls'
            );
        }

        $resourcePath = '/pdf/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXml
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToXml($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToXmlWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToXmlWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToXmlWithHttpInfo
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXmlWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXmlRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXmlAsync
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXmlAsync($out_path, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToXmlAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXmlAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXmlAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXmlRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXml'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXmlRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXml'
            );
        }

        $resourcePath = '/pdf/convert/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXps
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToXps($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToXpsWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToXpsWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToXpsWithHttpInfo
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXpsWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXpsRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXpsAsync
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXpsAsync($out_path, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToXpsAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXpsAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXpsRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXps'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXpsRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXps'
            );
        }

        $resourcePath = '/pdf/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToDoc
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToDoc($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToDocWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToDocAsync
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToDocAsync($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToDocAsyncWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToDocAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToDocAsyncWithHttpInfo($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToDoc'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToDoc'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToDoc'
            );
        }

        $resourcePath = '/pdf/{name}/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToEpub
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToEpub($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToEpubWithHttpInfo($name, $out_path, $content_recognition_mode, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToEpubWithHttpInfo($name, $out_path, $content_recognition_mode, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToEpubWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToEpubWithHttpInfo($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToEpubRequest($name, $out_path, $content_recognition_mode, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToEpubAsync
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToEpubAsync($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToEpubAsyncWithHttpInfo($name, $out_path, $content_recognition_mode, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToEpubAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToEpubAsyncWithHttpInfo($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToEpubRequest($name, $out_path, $content_recognition_mode, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToEpub'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToEpubRequest($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToEpub'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToEpub'
            );
        }

        $resourcePath = '/pdf/{name}/convert/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($content_recognition_mode !== null) {
            $queryParams['contentRecognitionMode'] = ObjectSerializer::toQueryValue($content_recognition_mode);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToHtml
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToHtml($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToHtmlWithHttpInfo($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToHtmlWithHttpInfo($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToHtmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToHtmlWithHttpInfo($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToHtmlRequest($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToHtmlAsync
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToHtmlAsync($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToHtmlAsyncWithHttpInfo($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToHtmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToHtmlAsyncWithHttpInfo($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToHtmlRequest($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToHtml'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToHtmlRequest($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToHtml'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToHtml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($additional_margin_width_in_points !== null) {
            $queryParams['additionalMarginWidthInPoints'] = ObjectSerializer::toQueryValue($additional_margin_width_in_points);
        }
        // query params
        if ($compress_svg_graphics_if_any !== null) {
            $queryParams['compressSvgGraphicsIfAny'] = ObjectSerializer::toQueryValue($compress_svg_graphics_if_any);
        }
        // query params
        if ($convert_marked_content_to_layers !== null) {
            $queryParams['convertMarkedContentToLayers'] = ObjectSerializer::toQueryValue($convert_marked_content_to_layers);
        }
        // query params
        if ($default_font_name !== null) {
            $queryParams['defaultFontName'] = ObjectSerializer::toQueryValue($default_font_name);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($fixed_layout !== null) {
            $queryParams['fixedLayout'] = ObjectSerializer::toQueryValue($fixed_layout);
        }
        // query params
        if ($image_resolution !== null) {
            $queryParams['imageResolution'] = ObjectSerializer::toQueryValue($image_resolution);
        }
        // query params
        if ($minimal_line_width !== null) {
            $queryParams['minimalLineWidth'] = ObjectSerializer::toQueryValue($minimal_line_width);
        }
        // query params
        if ($prevent_glyphs_grouping !== null) {
            $queryParams['preventGlyphsGrouping'] = ObjectSerializer::toQueryValue($prevent_glyphs_grouping);
        }
        // query params
        if ($split_css_into_pages !== null) {
            $queryParams['splitCssIntoPages'] = ObjectSerializer::toQueryValue($split_css_into_pages);
        }
        // query params
        if ($split_into_pages !== null) {
            $queryParams['splitIntoPages'] = ObjectSerializer::toQueryValue($split_into_pages);
        }
        // query params
        if ($use_z_order !== null) {
            $queryParams['useZOrder'] = ObjectSerializer::toQueryValue($use_z_order);
        }
        // query params
        if ($antialiasing_processing !== null) {
            $queryParams['antialiasingProcessing'] = ObjectSerializer::toQueryValue($antialiasing_processing);
        }
        // query params
        if ($css_class_names_prefix !== null) {
            $queryParams['cssClassNamesPrefix'] = ObjectSerializer::toQueryValue($css_class_names_prefix);
        }
        // query params
        if (is_array($explicit_list_of_saved_pages)) {
            $explicit_list_of_saved_pages = ObjectSerializer::serializeCollection($explicit_list_of_saved_pages, 'multi', true);
        }
        if ($explicit_list_of_saved_pages !== null) {
            $queryParams['explicitListOfSavedPages'] = ObjectSerializer::toQueryValue($explicit_list_of_saved_pages);
        }
        // query params
        if ($font_encoding_strategy !== null) {
            $queryParams['fontEncodingStrategy'] = ObjectSerializer::toQueryValue($font_encoding_strategy);
        }
        // query params
        if ($font_saving_mode !== null) {
            $queryParams['fontSavingMode'] = ObjectSerializer::toQueryValue($font_saving_mode);
        }
        // query params
        if ($html_markup_generation_mode !== null) {
            $queryParams['htmlMarkupGenerationMode'] = ObjectSerializer::toQueryValue($html_markup_generation_mode);
        }
        // query params
        if ($letters_positioning_method !== null) {
            $queryParams['lettersPositioningMethod'] = ObjectSerializer::toQueryValue($letters_positioning_method);
        }
        // query params
        if ($pages_flow_type_depends_on_viewers_screen_size !== null) {
            $queryParams['pagesFlowTypeDependsOnViewersScreenSize'] = ObjectSerializer::toQueryValue($pages_flow_type_depends_on_viewers_screen_size);
        }
        // query params
        if ($parts_embedding_mode !== null) {
            $queryParams['partsEmbeddingMode'] = ObjectSerializer::toQueryValue($parts_embedding_mode);
        }
        // query params
        if ($raster_images_saving_mode !== null) {
            $queryParams['rasterImagesSavingMode'] = ObjectSerializer::toQueryValue($raster_images_saving_mode);
        }
        // query params
        if ($remove_empty_areas_on_top_and_bottom !== null) {
            $queryParams['removeEmptyAreasOnTopAndBottom'] = ObjectSerializer::toQueryValue($remove_empty_areas_on_top_and_bottom);
        }
        // query params
        if ($save_shadowed_texts_as_transparent_texts !== null) {
            $queryParams['saveShadowedTextsAsTransparentTexts'] = ObjectSerializer::toQueryValue($save_shadowed_texts_as_transparent_texts);
        }
        // query params
        if ($save_transparent_texts !== null) {
            $queryParams['saveTransparentTexts'] = ObjectSerializer::toQueryValue($save_transparent_texts);
        }
        // query params
        if ($special_folder_for_all_images !== null) {
            $queryParams['specialFolderForAllImages'] = ObjectSerializer::toQueryValue($special_folder_for_all_images);
        }
        // query params
        if ($special_folder_for_svg_images !== null) {
            $queryParams['specialFolderForSvgImages'] = ObjectSerializer::toQueryValue($special_folder_for_svg_images);
        }
        // query params
        if ($try_save_text_underlining_and_strikeouting_in_css !== null) {
            $queryParams['trySaveTextUnderliningAndStrikeoutingInCss'] = ObjectSerializer::toQueryValue($try_save_text_underlining_and_strikeouting_in_css);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToLaTeX
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToLaTeX($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToLaTeXWithHttpInfo($name, $out_path, $pages_count, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToLaTeXWithHttpInfo($name, $out_path, $pages_count, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToLaTeXWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToLaTeXWithHttpInfo($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToLaTeXRequest($name, $out_path, $pages_count, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToLaTeXAsync
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToLaTeXAsync($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToLaTeXAsyncWithHttpInfo($name, $out_path, $pages_count, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToLaTeXAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToLaTeXAsyncWithHttpInfo($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToLaTeXRequest($name, $out_path, $pages_count, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToLaTeX'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToLaTeXRequest($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToLaTeX'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToLaTeX'
            );
        }

        $resourcePath = '/pdf/{name}/convert/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($pages_count !== null) {
            $queryParams['pagesCount'] = ObjectSerializer::toQueryValue($pages_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToMobiXml
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToMobiXml($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToMobiXmlWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToMobiXmlWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToMobiXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToMobiXmlWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToMobiXmlRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToMobiXmlAsync
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToMobiXmlAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToMobiXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToMobiXmlRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToMobiXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToMobiXmlRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToMobiXml'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToMobiXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/mobixml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToPdfA
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToPdfA($name, $out_path, $type, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToPdfAWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToPdfARequest($name, $out_path, $type, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToPdfAAsync
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPdfAAsync($name, $out_path, $type, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToPdfAAsyncWithHttpInfo($name, $out_path, $type, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPdfAAsyncWithHttpInfo($name, $out_path, $type, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToPdfARequest($name, $out_path, $type, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToPdfA'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToPdfARequest($name, $out_path, $type, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling putPdfInStorageToPdfA'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToPptx
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToPptx($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToPptxWithHttpInfo($name, $out_path, $separate_images, $slides_as_images, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToPptxWithHttpInfo($name, $out_path, $separate_images, $slides_as_images, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToPptxWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToPptxWithHttpInfo($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToPptxRequest($name, $out_path, $separate_images, $slides_as_images, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToPptxAsync
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPptxAsync($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToPptxAsyncWithHttpInfo($name, $out_path, $separate_images, $slides_as_images, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToPptxAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPptxAsyncWithHttpInfo($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToPptxRequest($name, $out_path, $separate_images, $slides_as_images, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToPptx'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToPptxRequest($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToPptx'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToPptx'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pptx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($separate_images !== null) {
            $queryParams['separateImages'] = ObjectSerializer::toQueryValue($separate_images);
        }
        // query params
        if ($slides_as_images !== null) {
            $queryParams['slidesAsImages'] = ObjectSerializer::toQueryValue($slides_as_images);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToSvg
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToSvg($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToSvgWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToSvgWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToSvgWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToSvgWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToSvgRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToSvgAsync
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToSvgAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToSvgAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToSvgAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToSvgRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToSvg'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToSvgRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToSvg'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToSvg'
            );
        }

        $resourcePath = '/pdf/{name}/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToTiff
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToTiff($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToTiffWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToTiffRequest($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToTiffAsync
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToTiffAsync($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToTiffAsyncWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToTiffAsyncWithHttpInfo($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToTiffRequest($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToTiffRequest($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToTiff'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXls
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToXls($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToXlsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXlsAsync
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsAsync($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToXlsAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXls'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXls'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXls'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXml
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToXml($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToXmlWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToXmlWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXmlWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXmlRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXmlAsync
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXmlAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToXmlAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXmlAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXmlRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXmlRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXml'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXps
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToXps($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToXpsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXpsRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXpsAsync
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXpsAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToXpsAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXpsAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXpsRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXps'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXpsRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXps'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXps'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPolyLineAnnotation
     *
     * Replace document polyline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolyLineAnnotationResponse
     */
    public function putPolyLineAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPolyLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPolyLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPolyLineAnnotationWithHttpInfo
     *
     * Replace document polyline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolyLineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPolyLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationResponse';
        $request = $this->putPolyLineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolyLineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPolyLineAnnotationAsync
     *
     * Replace document polyline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPolyLineAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putPolyLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPolyLineAnnotationAsyncWithHttpInfo
     *
     * Replace document polyline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPolyLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationResponse';
        $request = $this->putPolyLineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPolyLineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPolyLineAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPolyLineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putPolyLineAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putPolyLineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polyline/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPolygonAnnotation
     *
     * Replace document polygon annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolygonAnnotationResponse
     */
    public function putPolygonAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPolygonAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPolygonAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPolygonAnnotationWithHttpInfo
     *
     * Replace document polygon annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolygonAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPolygonAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationResponse';
        $request = $this->putPolygonAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolygonAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPolygonAnnotationAsync
     *
     * Replace document polygon annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPolygonAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putPolygonAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPolygonAnnotationAsyncWithHttpInfo
     *
     * Replace document polygon annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPolygonAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationResponse';
        $request = $this->putPolygonAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPolygonAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPolygonAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPolygonAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putPolygonAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putPolygonAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polygon/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPopupAnnotation
     *
     * Replace document popup annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationResponse
     */
    public function putPopupAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPopupAnnotationWithHttpInfo
     *
     * Replace document popup annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationResponse';
        $request = $this->putPopupAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPopupAnnotationAsync
     *
     * Replace document popup annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPopupAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPopupAnnotationAsyncWithHttpInfo
     *
     * Replace document popup annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationResponse';
        $request = $this->putPopupAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPopupAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPopupAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putPopupAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/popup/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPrivileges
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPrivileges($name, $privileges = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPrivilegesWithHttpInfo($name, $privileges, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPrivilegesWithHttpInfo($name, $privileges, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPrivilegesWithHttpInfo
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPrivilegesWithHttpInfo($name, $privileges = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPrivilegesRequest($name, $privileges, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPrivilegesAsync
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPrivilegesAsync($name, $privileges = null, $storage = null, $folder = null)
    {
        return $this->putPrivilegesAsyncWithHttpInfo($name, $privileges, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPrivilegesAsyncWithHttpInfo
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPrivilegesAsyncWithHttpInfo($name, $privileges = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPrivilegesRequest($name, $privileges, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPrivileges'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPrivilegesRequest($name, $privileges = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPrivileges'
            );
        }

        $resourcePath = '/pdf/{name}/privileges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($privileges)) {
            $_tempBody = $privileges;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPsInStorageToPdf
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPsInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPsInStorageToPdfWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPsInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPsInStorageToPdfAsync
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPsInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putPsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPsInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPsInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPsInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPsInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putPsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/ps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putReplaceImage
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImageResponse
     */
    public function putReplaceImage($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        try
        {
            list($response) = $this->putReplaceImageWithHttpInfo($name, $image_id, $image_file_path, $storage, $folder, $image);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putReplaceImageWithHttpInfo($name, $image_id, $image_file_path, $storage, $folder, $image);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putReplaceImageWithHttpInfo
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putReplaceImageWithHttpInfo($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->putReplaceImageRequest($name, $image_id, $image_file_path, $storage, $folder, $image);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putReplaceImageAsync
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putReplaceImageAsync($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        return $this->putReplaceImageAsyncWithHttpInfo($name, $image_id, $image_file_path, $storage, $folder, $image)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putReplaceImageAsyncWithHttpInfo
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putReplaceImageAsyncWithHttpInfo($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->putReplaceImageRequest($name, $image_id, $image_file_path, $storage, $folder, $image);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putReplaceImage'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putReplaceImageRequest($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putReplaceImage'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putReplaceImage'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_file_path !== null) {
            $queryParams['imageFilePath'] = ObjectSerializer::toQueryValue($image_file_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // form params
        if ($image !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($image);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['image'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['image'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSearchableDocument
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putSearchableDocument($name, $storage = null, $folder = null, $lang = null)
    {
        try
        {
            list($response) = $this->putSearchableDocumentWithHttpInfo($name, $storage, $folder, $lang);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSearchableDocumentWithHttpInfo($name, $storage, $folder, $lang);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSearchableDocumentWithHttpInfo
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSearchableDocumentWithHttpInfo($name, $storage = null, $folder = null, $lang = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSearchableDocumentRequest($name, $storage, $folder, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSearchableDocumentAsync
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSearchableDocumentAsync($name, $storage = null, $folder = null, $lang = null)
    {
        return $this->putSearchableDocumentAsyncWithHttpInfo($name, $storage, $folder, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSearchableDocumentAsyncWithHttpInfo
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSearchableDocumentAsyncWithHttpInfo($name, $storage = null, $folder = null, $lang = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSearchableDocumentRequest($name, $storage, $folder, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSearchableDocument'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSearchableDocumentRequest($name, $storage = null, $folder = null, $lang = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSearchableDocument'
            );
        }

        $resourcePath = '/pdf/{name}/ocr';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSetProperty
     *
     * Add/update document property.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $value value (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertyResponse
     */
    public function putSetProperty($name, $property_name, $value, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putSetPropertyWithHttpInfo($name, $property_name, $value, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSetPropertyWithHttpInfo($name, $property_name, $value, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSetPropertyWithHttpInfo
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $value (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSetPropertyWithHttpInfo($name, $property_name, $value, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->putSetPropertyRequest($name, $property_name, $value, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSetPropertyAsync
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $value (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSetPropertyAsync($name, $property_name, $value, $storage = null, $folder = null)
    {
        return $this->putSetPropertyAsyncWithHttpInfo($name, $property_name, $value, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSetPropertyAsyncWithHttpInfo
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $value (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSetPropertyAsyncWithHttpInfo($name, $property_name, $value, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->putSetPropertyRequest($name, $property_name, $value, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSetProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $value (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSetPropertyRequest($name, $property_name, $value, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSetProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling putSetProperty'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling putSetProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSquareAnnotation
     *
     * Replace document square annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquareAnnotationResponse
     */
    public function putSquareAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putSquareAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSquareAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSquareAnnotationWithHttpInfo
     *
     * Replace document square annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquareAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSquareAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationResponse';
        $request = $this->putSquareAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquareAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSquareAnnotationAsync
     *
     * Replace document square annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSquareAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putSquareAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSquareAnnotationAsyncWithHttpInfo
     *
     * Replace document square annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSquareAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationResponse';
        $request = $this->putSquareAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSquareAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSquareAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSquareAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putSquareAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putSquareAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/square/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSquigglyAnnotation
     *
     * Replace document squiggly annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquigglyAnnotationResponse
     */
    public function putSquigglyAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putSquigglyAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSquigglyAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSquigglyAnnotationWithHttpInfo
     *
     * Replace document squiggly annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquigglyAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSquigglyAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationResponse';
        $request = $this->putSquigglyAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquigglyAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSquigglyAnnotationAsync
     *
     * Replace document squiggly annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSquigglyAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putSquigglyAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSquigglyAnnotationAsyncWithHttpInfo
     *
     * Replace document squiggly annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSquigglyAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationResponse';
        $request = $this->putSquigglyAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSquigglyAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSquigglyAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSquigglyAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putSquigglyAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putSquigglyAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/squiggly/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStrikeOutAnnotation
     *
     * Replace document StrikeOut annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StrikeOutAnnotationResponse
     */
    public function putStrikeOutAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putStrikeOutAnnotationWithHttpInfo
     *
     * Replace document StrikeOut annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StrikeOutAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationResponse';
        $request = $this->putStrikeOutAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StrikeOutAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putStrikeOutAnnotationAsync
     *
     * Replace document StrikeOut annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStrikeOutAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putStrikeOutAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStrikeOutAnnotationAsyncWithHttpInfo
     *
     * Replace document StrikeOut annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStrikeOutAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationResponse';
        $request = $this->putStrikeOutAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStrikeOutAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStrikeOutAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putStrikeOutAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putStrikeOutAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putStrikeOutAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/strikeout/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSvgInStorageToPdf
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putSvgInStorageToPdf($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putSvgInStorageToPdfWithHttpInfo($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSvgInStorageToPdfWithHttpInfo($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSvgInStorageToPdfWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSvgInStorageToPdfWithHttpInfo($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSvgInStorageToPdfRequest($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSvgInStorageToPdfAsync
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSvgInStorageToPdfAsync($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        return $this->putSvgInStorageToPdfAsyncWithHttpInfo($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSvgInStorageToPdfAsyncWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSvgInStorageToPdfAsyncWithHttpInfo($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSvgInStorageToPdfRequest($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSvgInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSvgInStorageToPdfRequest($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSvgInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putSvgInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($adjust_page_size !== null) {
            $queryParams['adjustPageSize'] = ObjectSerializer::toQueryValue($adjust_page_size);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTextAnnotation
     *
     * Replace document text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextAnnotationResponse
     */
    public function putTextAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putTextAnnotationWithHttpInfo
     *
     * Replace document text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationResponse';
        $request = $this->putTextAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putTextAnnotationAsync
     *
     * Replace document text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTextAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTextAnnotationAsyncWithHttpInfo
     *
     * Replace document text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationResponse';
        $request = $this->putTextAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTextAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTextAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putTextAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putTextAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putTextAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/text/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUnderlineAnnotation
     *
     * Replace document underline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\UnderlineAnnotationResponse
     */
    public function putUnderlineAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putUnderlineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putUnderlineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putUnderlineAnnotationWithHttpInfo
     *
     * Replace document underline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\UnderlineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUnderlineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationResponse';
        $request = $this->putUnderlineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\UnderlineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUnderlineAnnotationAsync
     *
     * Replace document underline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUnderlineAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putUnderlineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUnderlineAnnotationAsyncWithHttpInfo
     *
     * Replace document underline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUnderlineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationResponse';
        $request = $this->putUnderlineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUnderlineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUnderlineAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUnderlineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putUnderlineAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putUnderlineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/underline/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUpdateField
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldResponse
     */
    public function putUpdateField($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putUpdateFieldWithHttpInfo($name, $field_name, $field, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putUpdateFieldWithHttpInfo($name, $field_name, $field, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putUpdateFieldWithHttpInfo
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUpdateFieldWithHttpInfo($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->putUpdateFieldRequest($name, $field_name, $field, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUpdateFieldAsync
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldAsync($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        return $this->putUpdateFieldAsyncWithHttpInfo($name, $field_name, $field, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUpdateFieldAsyncWithHttpInfo
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldAsyncWithHttpInfo($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->putUpdateFieldRequest($name, $field_name, $field, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUpdateField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUpdateFieldRequest($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUpdateField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling putUpdateField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($field)) {
            $_tempBody = $field;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUpdateFields
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldsResponse
     */
    public function putUpdateFields($name, $fields = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putUpdateFieldsWithHttpInfo($name, $fields, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putUpdateFieldsWithHttpInfo($name, $fields, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putUpdateFieldsWithHttpInfo
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUpdateFieldsWithHttpInfo($name, $fields = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->putUpdateFieldsRequest($name, $fields, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUpdateFieldsAsync
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldsAsync($name, $fields = null, $storage = null, $folder = null)
    {
        return $this->putUpdateFieldsAsyncWithHttpInfo($name, $fields, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUpdateFieldsAsyncWithHttpInfo
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldsAsyncWithHttpInfo($name, $fields = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->putUpdateFieldsRequest($name, $fields, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUpdateFields'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUpdateFieldsRequest($name, $fields = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUpdateFields'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($fields)) {
            $_tempBody = $fields;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putWebInStorageToPdf
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putWebInStorageToPdf($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putWebInStorageToPdfWithHttpInfo($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putWebInStorageToPdfWithHttpInfo($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putWebInStorageToPdfWithHttpInfo
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putWebInStorageToPdfWithHttpInfo($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putWebInStorageToPdfRequest($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putWebInStorageToPdfAsync
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putWebInStorageToPdfAsync($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        return $this->putWebInStorageToPdfAsyncWithHttpInfo($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putWebInStorageToPdfAsyncWithHttpInfo
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putWebInStorageToPdfAsyncWithHttpInfo($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putWebInStorageToPdfRequest($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putWebInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putWebInStorageToPdfRequest($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putWebInStorageToPdf'
            );
        }
        // verify the required parameter 'url' is set
        if ($url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling putWebInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/web';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXfaPdfInRequestToAcroForm
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXfaPdfInRequestToAcroForm($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putXfaPdfInRequestToAcroFormWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXfaPdfInRequestToAcroFormWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXfaPdfInRequestToAcroFormWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXfaPdfInRequestToAcroFormWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXfaPdfInRequestToAcroFormRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXfaPdfInRequestToAcroFormAsync
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInRequestToAcroFormAsync($out_path, $storage = null, $file = null)
    {
        return $this->putXfaPdfInRequestToAcroFormAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXfaPdfInRequestToAcroFormAsyncWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInRequestToAcroFormAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXfaPdfInRequestToAcroFormRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXfaPdfInRequestToAcroForm'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXfaPdfInRequestToAcroFormRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putXfaPdfInRequestToAcroForm'
            );
        }

        $resourcePath = '/pdf/convert/xfatoacroform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXfaPdfInStorageToAcroForm
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXfaPdfInStorageToAcroForm($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putXfaPdfInStorageToAcroFormWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXfaPdfInStorageToAcroFormWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXfaPdfInStorageToAcroFormWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXfaPdfInStorageToAcroFormWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXfaPdfInStorageToAcroFormRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXfaPdfInStorageToAcroFormAsync
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInStorageToAcroFormAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXfaPdfInStorageToAcroFormAsyncWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXfaPdfInStorageToAcroFormRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXfaPdfInStorageToAcroForm'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXfaPdfInStorageToAcroFormRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXfaPdfInStorageToAcroForm'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putXfaPdfInStorageToAcroForm'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xfatoacroform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXmlInStorageToPdf
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXmlInStorageToPdf($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putXmlInStorageToPdfWithHttpInfo($name, $src_path, $xsl_file_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXmlInStorageToPdfWithHttpInfo($name, $src_path, $xsl_file_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXmlInStorageToPdfWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXmlInStorageToPdfWithHttpInfo($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXmlInStorageToPdfRequest($name, $src_path, $xsl_file_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXmlInStorageToPdfAsync
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXmlInStorageToPdfAsync($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        return $this->putXmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $xsl_file_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXmlInStorageToPdfRequest($name, $src_path, $xsl_file_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXmlInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXmlInStorageToPdfRequest($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXmlInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putXmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($xsl_file_path !== null) {
            $queryParams['xslFilePath'] = ObjectSerializer::toQueryValue($xsl_file_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXpsInStorageToPdf
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXpsInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putXpsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXpsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXpsInStorageToPdfWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXpsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXpsInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXpsInStorageToPdfAsync
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXpsInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putXpsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXpsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXpsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXpsInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXpsInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXpsInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXpsInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putXpsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXslFoInStorageToPdf
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXslFoInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putXslFoInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXslFoInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXslFoInStorageToPdfWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXslFoInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXslFoInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXslFoInStorageToPdfAsync
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXslFoInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putXslFoInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXslFoInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXslFoInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXslFoInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXslFoInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXslFoInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXslFoInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putXslFoInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/xslfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }
        
        //PDFCLOUD-418
        $options['connect_timeout'] = 5 * 60;
        
        return $options;
    }

    //ASPOSE_PDF_CLOUD
    /*
     * Gets a request token from server
     */
    private function _requestToken()
    {
        $requestUrl = $this->config->getHost() . "/oauth2/token";
        $requestUrl = str_replace('/v2.0', '', $requestUrl);
        $postData = "grant_type=client_credentials" . "&client_id=" . $this->config->getAppSid() . "&client_secret=" . $this->config->getAppKey();
        $response = $this->client->send(new Request('POST', $requestUrl, [], $postData));
        $result = json_decode($response->getBody()->getContents(), true);
        $this->config->setAccessToken($result["access_token"]);
        $this->config->setRefreshToken($result["refresh_token"]);
    }
    /*
     * Refresh token
     */
    private function _refreshToken()
    {
        $requestUrl = $this->config->getHost() . "/oauth2/token";
        $requestUrl = str_replace('/v2.0', '', $requestUrl);
        $postData = "grant_type=refresh_token&refresh_token=" . $this->config->getRefreshToken();
        $response = $this->client->send(new Request('POST', $requestUrl, [], $postData));
        $result = json_decode($response->getBody()->getContents(), true);
        $this->config->setAccessToken($result["access_token"]);
        $this->config->setRefreshToken($result["refresh_token"]);
    }
    //ASPOSE_PDF_CLOUD
}
