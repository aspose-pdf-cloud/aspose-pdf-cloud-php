<?php
/**
 *
 *   Copyright (c) 2019 Aspose.PDF Cloud
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */


/**
 * PdfApi
 * PHP version 5
 *
 * @category Class
 * @package  Aspose\PDF
 * @author   Aspose PDF Cloud
 * @link     https://github.com/aspose-pdf-cloud/aspose-pdf-cloud-php
 */

namespace Aspose\PDF\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Aspose\PDF\ApiException;
use Aspose\PDF\Configuration;
use Aspose\PDF\HeaderSelector;
use Aspose\PDF\ObjectSerializer;

class PdfApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteAnnotation
     *
     * Delete document annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteAnnotationWithHttpInfo
     *
     * Delete document annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAnnotationAsync
     *
     * Delete document annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->deleteAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAnnotationAsyncWithHttpInfo
     *
     * Delete document annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling deleteAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocumentAnnotations
     *
     * Delete all annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteDocumentAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteDocumentAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteDocumentAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteDocumentAnnotationsWithHttpInfo
     *
     * Delete all annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDocumentAnnotationsAsync
     *
     * Delete all annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->deleteDocumentAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentAnnotationsAsyncWithHttpInfo
     *
     * Delete all annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocumentAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDocumentAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteDocumentAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocumentLinkAnnotations
     *
     * Delete all link annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteDocumentLinkAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteDocumentLinkAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteDocumentLinkAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteDocumentLinkAnnotationsWithHttpInfo
     *
     * Delete all link annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentLinkAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentLinkAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDocumentLinkAnnotationsAsync
     *
     * Delete all link annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentLinkAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->deleteDocumentLinkAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentLinkAnnotationsAsyncWithHttpInfo
     *
     * Delete all link annotations from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentLinkAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentLinkAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocumentLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDocumentLinkAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteDocumentLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocumentStamps
     *
     * Delete all stamps from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteDocumentStamps($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteDocumentStampsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteDocumentStampsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteDocumentStampsWithHttpInfo
     *
     * Delete all stamps from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentStampsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentStampsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDocumentStampsAsync
     *
     * Delete all stamps from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentStampsAsync($name, $storage = null, $folder = null)
    {
        return $this->deleteDocumentStampsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentStampsAsyncWithHttpInfo
     *
     * Delete all stamps from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentStampsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentStampsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocumentStamps'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDocumentStampsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteDocumentStamps'
            );
        }

        $resourcePath = '/pdf/{name}/stamps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocumentTables
     *
     * Delete all tables from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteDocumentTables($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteDocumentTablesWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteDocumentTablesWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteDocumentTablesWithHttpInfo
     *
     * Delete all tables from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentTablesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentTablesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDocumentTablesAsync
     *
     * Delete all tables from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentTablesAsync($name, $storage = null, $folder = null)
    {
        return $this->deleteDocumentTablesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentTablesAsyncWithHttpInfo
     *
     * Delete all tables from the document
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentTablesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteDocumentTablesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocumentTables'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDocumentTablesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteDocumentTables'
            );
        }

        $resourcePath = '/pdf/{name}/tables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteField
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteField($name, $field_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteFieldWithHttpInfo($name, $field_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteFieldWithHttpInfo($name, $field_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteFieldWithHttpInfo
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFieldWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFieldRequest($name, $field_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFieldAsync
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsync($name, $field_name, $storage = null, $folder = null)
    {
        return $this->deleteFieldAsyncWithHttpInfo($name, $field_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFieldAsyncWithHttpInfo
     *
     * Delete document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsyncWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFieldRequest($name, $field_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFieldRequest($name, $field_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling deleteField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFile
     *
     * Remove a specific file
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteFile($path, $version_id = null, $storage = null)
    {
        try
        {
            list($response) = $this->deleteFileWithHttpInfo($path, $version_id, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteFileWithHttpInfo($path, $version_id, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * Remove a specific file
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFileRequest($path, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileAsync
     *
     * Remove a specific file
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsync($path, $version_id = null, $storage = null)
    {
        return $this->deleteFileAsyncWithHttpInfo($path, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAsyncWithHttpInfo
     *
     * Remove a specific file
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsyncWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFileRequest($path, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFile'
     *
     * @param  string $path Path of the file including file name and extension e.g. /Folder1/file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFileRequest($path, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling deleteFile'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFolder
     *
     * Remove a specific folder
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteFolder($path, $storage = null, $recursive = 'false')
    {
        try
        {
            list($response) = $this->deleteFolderWithHttpInfo($path, $storage, $recursive);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteFolderWithHttpInfo($path, $storage, $recursive);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteFolderWithHttpInfo
     *
     * Remove a specific folder
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFolderWithHttpInfo($path, $storage = null, $recursive = 'false')
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFolderRequest($path, $storage, $recursive);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFolderAsync
     *
     * Remove a specific folder
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsync($path, $storage = null, $recursive = 'false')
    {
        return $this->deleteFolderAsyncWithHttpInfo($path, $storage, $recursive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFolderAsyncWithHttpInfo
     *
     * Remove a specific folder
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsyncWithHttpInfo($path, $storage = null, $recursive = 'false')
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteFolderRequest($path, $storage, $recursive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFolder'
     *
     * @param  string $path Folder path e.g. /Folder1 (required)
     * @param  string $storage User&#39;s storage name (optional)
     * @param  bool $recursive Remove recursivelly inner folder/files. If false and folder contains data than exception is raised. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFolderRequest($path, $storage = null, $recursive = 'false')
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling deleteFolder'
            );
        }

        $resourcePath = '/storage/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($recursive !== null) {
            $queryParams['recursive'] = ObjectSerializer::toQueryValue($recursive);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteImage
     *
     * Delete image from document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteImage($name, $image_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteImageWithHttpInfo($name, $image_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteImageWithHttpInfo($name, $image_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteImageWithHttpInfo
     *
     * Delete image from document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteImageWithHttpInfo($name, $image_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteImageRequest($name, $image_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteImageAsync
     *
     * Delete image from document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteImageAsync($name, $image_id, $storage = null, $folder = null)
    {
        return $this->deleteImageAsyncWithHttpInfo($name, $image_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteImageAsyncWithHttpInfo
     *
     * Delete image from document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteImageAsyncWithHttpInfo($name, $image_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteImageRequest($name, $image_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteImage'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteImageRequest($name, $image_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteImage'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling deleteImage'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLinkAnnotation
     *
     * Delete document page link annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteLinkAnnotation($name, $link_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteLinkAnnotationWithHttpInfo($name, $link_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteLinkAnnotationWithHttpInfo($name, $link_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteLinkAnnotationWithHttpInfo
     *
     * Delete document page link annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLinkAnnotationWithHttpInfo($name, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteLinkAnnotationRequest($name, $link_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteLinkAnnotationAsync
     *
     * Delete document page link annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLinkAnnotationAsync($name, $link_id, $storage = null, $folder = null)
    {
        return $this->deleteLinkAnnotationAsyncWithHttpInfo($name, $link_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLinkAnnotationAsyncWithHttpInfo
     *
     * Delete document page link annotation by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLinkAnnotationAsyncWithHttpInfo($name, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteLinkAnnotationRequest($name, $link_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteLinkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteLinkAnnotationRequest($name, $link_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteLinkAnnotation'
            );
        }
        // verify the required parameter 'link_id' is set
        if ($link_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_id when calling deleteLinkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/links/{linkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'linkId' . '}',
                ObjectSerializer::toPathValue($link_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePage
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deletePage($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePageWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePageWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePageWithHttpInfo
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageAsync
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageAsyncWithHttpInfo
     *
     * Delete document page by its number.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePageAnnotations
     *
     * Delete all annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deletePageAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePageAnnotationsWithHttpInfo
     *
     * Delete all annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageAnnotationsAsync
     *
     * Delete all annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageAnnotationsAsyncWithHttpInfo
     *
     * Delete all annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePageAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePageAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePageAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePageLinkAnnotations
     *
     * Delete all link annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deletePageLinkAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePageLinkAnnotationsWithHttpInfo
     *
     * Delete all link annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageLinkAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageLinkAnnotationsAsync
     *
     * Delete all link annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageLinkAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageLinkAnnotationsAsyncWithHttpInfo
     *
     * Delete all link annotations from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePageLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageLinkAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePageLinkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePageLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePageStamps
     *
     * Delete all stamps from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deletePageStamps($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePageStampsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePageStampsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePageStampsWithHttpInfo
     *
     * Delete all stamps from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageStampsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageStampsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageStampsAsync
     *
     * Delete all stamps from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageStampsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageStampsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageStampsAsyncWithHttpInfo
     *
     * Delete all stamps from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageStampsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageStampsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePageStamps'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageStampsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePageStamps'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePageStamps'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/stamps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePageTables
     *
     * Delete all tables from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deletePageTables($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePageTablesWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePageTablesWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePageTablesWithHttpInfo
     *
     * Delete all tables from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePageTablesWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageTablesRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePageTablesAsync
     *
     * Delete all tables from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageTablesAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->deletePageTablesAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePageTablesAsyncWithHttpInfo
     *
     * Delete all tables from the page
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePageTablesAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePageTablesRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePageTables'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePageTablesRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePageTables'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling deletePageTables'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/tables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProperties
     *
     * Delete custom document properties.
     *
     * @param  string $name name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteProperties($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePropertiesWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePropertiesWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePropertiesWithHttpInfo
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePropertiesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePropertiesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePropertiesAsync
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertiesAsync($name, $storage = null, $folder = null)
    {
        return $this->deletePropertiesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePropertiesAsyncWithHttpInfo
     *
     * Delete custom document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertiesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePropertiesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProperties'
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePropertiesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteProperties'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProperty
     *
     * Delete document property.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteProperty($name, $property_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deletePropertyWithHttpInfo($name, $property_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deletePropertyWithHttpInfo($name, $property_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deletePropertyWithHttpInfo
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePropertyWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePropertyRequest($name, $property_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePropertyAsync
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertyAsync($name, $property_name, $storage = null, $folder = null)
    {
        return $this->deletePropertyAsyncWithHttpInfo($name, $property_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePropertyAsyncWithHttpInfo
     *
     * Delete document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePropertyAsyncWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deletePropertyRequest($name, $property_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePropertyRequest($name, $property_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling deleteProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStamp
     *
     * Delete document stamp by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $stamp_id The stamp ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteStamp($name, $stamp_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteStampWithHttpInfo($name, $stamp_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteStampWithHttpInfo($name, $stamp_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteStampWithHttpInfo
     *
     * Delete document stamp by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $stamp_id The stamp ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStampWithHttpInfo($name, $stamp_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteStampRequest($name, $stamp_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStampAsync
     *
     * Delete document stamp by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $stamp_id The stamp ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStampAsync($name, $stamp_id, $storage = null, $folder = null)
    {
        return $this->deleteStampAsyncWithHttpInfo($name, $stamp_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStampAsyncWithHttpInfo
     *
     * Delete document stamp by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $stamp_id The stamp ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStampAsyncWithHttpInfo($name, $stamp_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteStampRequest($name, $stamp_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStamp'
     *
     * @param  string $name The document name. (required)
     * @param  string $stamp_id The stamp ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteStampRequest($name, $stamp_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteStamp'
            );
        }
        // verify the required parameter 'stamp_id' is set
        if ($stamp_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamp_id when calling deleteStamp'
            );
        }

        $resourcePath = '/pdf/{name}/stamps/{stampId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($stamp_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stampId' . '}',
                ObjectSerializer::toPathValue($stamp_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTable
     *
     * Delete document table by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function deleteTable($name, $table_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->deleteTableWithHttpInfo($name, $table_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->deleteTableWithHttpInfo($name, $table_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation deleteTableWithHttpInfo
     *
     * Delete document table by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTableWithHttpInfo($name, $table_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteTableRequest($name, $table_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTableAsync
     *
     * Delete document table by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableAsync($name, $table_id, $storage = null, $folder = null)
    {
        return $this->deleteTableAsyncWithHttpInfo($name, $table_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTableAsyncWithHttpInfo
     *
     * Delete document table by ID
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableAsyncWithHttpInfo($name, $table_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->deleteTableRequest($name, $table_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTable'
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTableRequest($name, $table_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteTable'
            );
        }
        // verify the required parameter 'table_id' is set
        if ($table_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table_id when calling deleteTable'
            );
        }

        $resourcePath = '/pdf/{name}/tables/{tableId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($table_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($table_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCaretAnnotation
     *
     * Read document page caret annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CaretAnnotationResponse
     */
    public function getCaretAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getCaretAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getCaretAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getCaretAnnotationWithHttpInfo
     *
     * Read document page caret annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CaretAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCaretAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationResponse';
        $request = $this->getCaretAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CaretAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCaretAnnotationAsync
     *
     * Read document page caret annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCaretAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getCaretAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCaretAnnotationAsyncWithHttpInfo
     *
     * Read document page caret annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCaretAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationResponse';
        $request = $this->getCaretAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCaretAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCaretAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getCaretAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getCaretAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/caret/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCircleAnnotation
     *
     * Read document page circle annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CircleAnnotationResponse
     */
    public function getCircleAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getCircleAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getCircleAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getCircleAnnotationWithHttpInfo
     *
     * Read document page circle annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CircleAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCircleAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationResponse';
        $request = $this->getCircleAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CircleAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCircleAnnotationAsync
     *
     * Read document page circle annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCircleAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getCircleAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCircleAnnotationAsyncWithHttpInfo
     *
     * Read document page circle annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCircleAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationResponse';
        $request = $this->getCircleAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCircleAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCircleAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getCircleAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getCircleAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/circle/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDiscUsage
     *
     * Check the disk usage of the current account
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DiscUsageResponse
     */
    public function getDiscUsage($storage = null)
    {
        try
        {
            list($response) = $this->getDiscUsageWithHttpInfo($storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDiscUsageWithHttpInfo($storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDiscUsageWithHttpInfo
     *
     * Check the disk usage of the current account
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DiscUsageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDiscUsageWithHttpInfo($storage = null)
    {
        $returnType = '\Aspose\PDF\Model\DiscUsageResponse';
        $request = $this->getDiscUsageRequest($storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DiscUsageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDiscUsageAsync
     *
     * Check the disk usage of the current account
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDiscUsageAsync($storage = null)
    {
        return $this->getDiscUsageAsyncWithHttpInfo($storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDiscUsageAsyncWithHttpInfo
     *
     * Check the disk usage of the current account
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDiscUsageAsyncWithHttpInfo($storage = null)
    {
        $returnType = '\Aspose\PDF\Model\DiscUsageResponse';
        $request = $this->getDiscUsageRequest($storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDiscUsage'
     *
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDiscUsageRequest($storage = null)
    {

        $resourcePath = '/storage/disc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocument
     *
     * Read common document info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function getDocument($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentWithHttpInfo
     *
     * Read common document info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->getDocumentRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAsync
     *
     * Read common document info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAsyncWithHttpInfo
     *
     * Read common document info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->getDocumentRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocument'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocument'
            );
        }

        $resourcePath = '/pdf/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAnnotations
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AnnotationsInfoResponse
     */
    public function getDocumentAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentAnnotationsWithHttpInfo
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AnnotationsInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsInfoResponse';
        $request = $this->getDocumentAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AnnotationsInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAnnotationsAsync
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAnnotationsAsyncWithHttpInfo
     *
     * Read documant page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsInfoResponse';
        $request = $this->getDocumentAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAttachmentByIndex
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AttachmentResponse
     */
    public function getDocumentAttachmentByIndex($name, $attachment_index, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentAttachmentByIndexWithHttpInfo
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AttachmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentResponse';
        $request = $this->getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AttachmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAttachmentByIndexAsync
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentByIndexAsync($name, $attachment_index, $storage = null, $folder = null)
    {
        return $this->getDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAttachmentByIndexAsyncWithHttpInfo
     *
     * Read document attachment info by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentResponse';
        $request = $this->getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAttachmentByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAttachmentByIndexRequest($name, $attachment_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAttachmentByIndex'
            );
        }
        // verify the required parameter 'attachment_index' is set
        if ($attachment_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_index when calling getDocumentAttachmentByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/attachments/{attachmentIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($attachment_index !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentIndex' . '}',
                ObjectSerializer::toPathValue($attachment_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentAttachments
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AttachmentsResponse
     */
    public function getDocumentAttachments($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentAttachmentsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentAttachmentsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentAttachmentsWithHttpInfo
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AttachmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentAttachmentsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentsResponse';
        $request = $this->getDocumentAttachmentsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AttachmentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentAttachmentsAsync
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentAttachmentsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAttachmentsAsyncWithHttpInfo
     *
     * Read document attachments info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAttachmentsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AttachmentsResponse';
        $request = $this->getDocumentAttachmentsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentAttachments'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentAttachmentsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentAttachments'
            );
        }

        $resourcePath = '/pdf/{name}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentCaretAnnotations
     *
     * Read document caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CaretAnnotationsResponse
     */
    public function getDocumentCaretAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentCaretAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentCaretAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentCaretAnnotationsWithHttpInfo
     *
     * Read document caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CaretAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentCaretAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationsResponse';
        $request = $this->getDocumentCaretAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CaretAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentCaretAnnotationsAsync
     *
     * Read document caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentCaretAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentCaretAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentCaretAnnotationsAsyncWithHttpInfo
     *
     * Read document caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentCaretAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationsResponse';
        $request = $this->getDocumentCaretAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentCaretAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentCaretAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentCaretAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/caret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentCircleAnnotations
     *
     * Read document circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CircleAnnotationsResponse
     */
    public function getDocumentCircleAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentCircleAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentCircleAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentCircleAnnotationsWithHttpInfo
     *
     * Read document circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CircleAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentCircleAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationsResponse';
        $request = $this->getDocumentCircleAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CircleAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentCircleAnnotationsAsync
     *
     * Read document circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentCircleAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentCircleAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentCircleAnnotationsAsyncWithHttpInfo
     *
     * Read document circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentCircleAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationsResponse';
        $request = $this->getDocumentCircleAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentCircleAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentCircleAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentCircleAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/circle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentFileAttachmentAnnotations
     *
     * Read document FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FileAttachmentAnnotationsResponse
     */
    public function getDocumentFileAttachmentAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentFileAttachmentAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentFileAttachmentAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentFileAttachmentAnnotationsWithHttpInfo
     *
     * Read document FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FileAttachmentAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentFileAttachmentAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FileAttachmentAnnotationsResponse';
        $request = $this->getDocumentFileAttachmentAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FileAttachmentAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentFileAttachmentAnnotationsAsync
     *
     * Read document FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFileAttachmentAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentFileAttachmentAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentFileAttachmentAnnotationsAsyncWithHttpInfo
     *
     * Read document FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFileAttachmentAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FileAttachmentAnnotationsResponse';
        $request = $this->getDocumentFileAttachmentAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentFileAttachmentAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentFileAttachmentAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentFileAttachmentAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/fileattachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentFreeTextAnnotations
     *
     * Read document free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FreeTextAnnotationsResponse
     */
    public function getDocumentFreeTextAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentFreeTextAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentFreeTextAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentFreeTextAnnotationsWithHttpInfo
     *
     * Read document free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FreeTextAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentFreeTextAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationsResponse';
        $request = $this->getDocumentFreeTextAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FreeTextAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentFreeTextAnnotationsAsync
     *
     * Read document free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFreeTextAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentFreeTextAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentFreeTextAnnotationsAsyncWithHttpInfo
     *
     * Read document free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFreeTextAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationsResponse';
        $request = $this->getDocumentFreeTextAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentFreeTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentFreeTextAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentFreeTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/freetext';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentHighlightAnnotations
     *
     * Read document highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\HighlightAnnotationsResponse
     */
    public function getDocumentHighlightAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentHighlightAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentHighlightAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentHighlightAnnotationsWithHttpInfo
     *
     * Read document highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\HighlightAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentHighlightAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationsResponse';
        $request = $this->getDocumentHighlightAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\HighlightAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentHighlightAnnotationsAsync
     *
     * Read document highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentHighlightAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentHighlightAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentHighlightAnnotationsAsyncWithHttpInfo
     *
     * Read document highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentHighlightAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationsResponse';
        $request = $this->getDocumentHighlightAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentHighlightAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentHighlightAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentHighlightAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/highlight';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentInkAnnotations
     *
     * Read document ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\InkAnnotationsResponse
     */
    public function getDocumentInkAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentInkAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentInkAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentInkAnnotationsWithHttpInfo
     *
     * Read document ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\InkAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentInkAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationsResponse';
        $request = $this->getDocumentInkAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\InkAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentInkAnnotationsAsync
     *
     * Read document ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentInkAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentInkAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentInkAnnotationsAsyncWithHttpInfo
     *
     * Read document ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentInkAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationsResponse';
        $request = $this->getDocumentInkAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentInkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentInkAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentInkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/ink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentLineAnnotations
     *
     * Read document line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LineAnnotationsResponse
     */
    public function getDocumentLineAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentLineAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentLineAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentLineAnnotationsWithHttpInfo
     *
     * Read document line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentLineAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationsResponse';
        $request = $this->getDocumentLineAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentLineAnnotationsAsync
     *
     * Read document line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentLineAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentLineAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentLineAnnotationsAsyncWithHttpInfo
     *
     * Read document line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentLineAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationsResponse';
        $request = $this->getDocumentLineAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentLineAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/line';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentMovieAnnotations
     *
     * Read document movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\MovieAnnotationsResponse
     */
    public function getDocumentMovieAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentMovieAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentMovieAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentMovieAnnotationsWithHttpInfo
     *
     * Read document movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\MovieAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentMovieAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\MovieAnnotationsResponse';
        $request = $this->getDocumentMovieAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\MovieAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentMovieAnnotationsAsync
     *
     * Read document movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentMovieAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentMovieAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentMovieAnnotationsAsyncWithHttpInfo
     *
     * Read document movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentMovieAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\MovieAnnotationsResponse';
        $request = $this->getDocumentMovieAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentMovieAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentMovieAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentMovieAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/movie';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentPolyLineAnnotations
     *
     * Read document polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolyLineAnnotationsResponse
     */
    public function getDocumentPolyLineAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPolyLineAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPolyLineAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPolyLineAnnotationsWithHttpInfo
     *
     * Read document polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolyLineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPolyLineAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationsResponse';
        $request = $this->getDocumentPolyLineAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolyLineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPolyLineAnnotationsAsync
     *
     * Read document polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPolyLineAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPolyLineAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPolyLineAnnotationsAsyncWithHttpInfo
     *
     * Read document polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPolyLineAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationsResponse';
        $request = $this->getDocumentPolyLineAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentPolyLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPolyLineAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentPolyLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polyline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentPolygonAnnotations
     *
     * Read document polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolygonAnnotationsResponse
     */
    public function getDocumentPolygonAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPolygonAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPolygonAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPolygonAnnotationsWithHttpInfo
     *
     * Read document polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolygonAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPolygonAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationsResponse';
        $request = $this->getDocumentPolygonAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolygonAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPolygonAnnotationsAsync
     *
     * Read document polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPolygonAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPolygonAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPolygonAnnotationsAsyncWithHttpInfo
     *
     * Read document polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPolygonAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationsResponse';
        $request = $this->getDocumentPolygonAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentPolygonAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPolygonAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentPolygonAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polygon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentPopupAnnotations
     *
     * Read document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationsResponse
     */
    public function getDocumentPopupAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPopupAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPopupAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPopupAnnotationsWithHttpInfo
     *
     * Read document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPopupAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getDocumentPopupAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPopupAnnotationsAsync
     *
     * Read document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPopupAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPopupAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPopupAnnotationsAsyncWithHttpInfo
     *
     * Read document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPopupAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getDocumentPopupAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentPopupAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPopupAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentPopupAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/popup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentPopupAnnotationsByParent
     *
     * Read document popup annotations by parent id.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationsResponse
     */
    public function getDocumentPopupAnnotationsByParent($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPopupAnnotationsByParentWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPopupAnnotationsByParentWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPopupAnnotationsByParentWithHttpInfo
     *
     * Read document popup annotations by parent id.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPopupAnnotationsByParentWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getDocumentPopupAnnotationsByParentRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPopupAnnotationsByParentAsync
     *
     * Read document popup annotations by parent id.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPopupAnnotationsByParentAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getDocumentPopupAnnotationsByParentAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPopupAnnotationsByParentAsyncWithHttpInfo
     *
     * Read document popup annotations by parent id.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPopupAnnotationsByParentAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getDocumentPopupAnnotationsByParentRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentPopupAnnotationsByParent'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPopupAnnotationsByParentRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentPopupAnnotationsByParent'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getDocumentPopupAnnotationsByParent'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/{annotationId}/popup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentProperties
     *
     * Read document properties.
     *
     * @param  string $name name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertiesResponse
     */
    public function getDocumentProperties($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPropertiesWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPropertiesWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPropertiesWithHttpInfo
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertiesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPropertiesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertiesResponse';
        $request = $this->getDocumentPropertiesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertiesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPropertiesAsync
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentPropertiesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPropertiesAsyncWithHttpInfo
     *
     * Read document properties.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertiesResponse';
        $request = $this->getDocumentPropertiesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentProperties'
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPropertiesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentProperties'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentProperty
     *
     * Read document property by name.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertyResponse
     */
    public function getDocumentProperty($name, $property_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentPropertyWithHttpInfo($name, $property_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentPropertyWithHttpInfo($name, $property_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentPropertyWithHttpInfo
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentPropertyWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->getDocumentPropertyRequest($name, $property_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentPropertyAsync
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyAsync($name, $property_name, $storage = null, $folder = null)
    {
        return $this->getDocumentPropertyAsyncWithHttpInfo($name, $property_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentPropertyAsyncWithHttpInfo
     *
     * Read document property by name.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyAsyncWithHttpInfo($name, $property_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->getDocumentPropertyRequest($name, $property_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentPropertyRequest($name, $property_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling getDocumentProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentRedactionAnnotations
     *
     * Read document redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\RedactionAnnotationsResponse
     */
    public function getDocumentRedactionAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentRedactionAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentRedactionAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentRedactionAnnotationsWithHttpInfo
     *
     * Read document redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\RedactionAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentRedactionAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\RedactionAnnotationsResponse';
        $request = $this->getDocumentRedactionAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\RedactionAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentRedactionAnnotationsAsync
     *
     * Read document redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentRedactionAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentRedactionAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentRedactionAnnotationsAsyncWithHttpInfo
     *
     * Read document redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentRedactionAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\RedactionAnnotationsResponse';
        $request = $this->getDocumentRedactionAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentRedactionAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentRedactionAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentRedactionAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/redaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentScreenAnnotations
     *
     * Read document screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ScreenAnnotationsResponse
     */
    public function getDocumentScreenAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentScreenAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentScreenAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentScreenAnnotationsWithHttpInfo
     *
     * Read document screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ScreenAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentScreenAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ScreenAnnotationsResponse';
        $request = $this->getDocumentScreenAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ScreenAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentScreenAnnotationsAsync
     *
     * Read document screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentScreenAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentScreenAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentScreenAnnotationsAsyncWithHttpInfo
     *
     * Read document screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentScreenAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ScreenAnnotationsResponse';
        $request = $this->getDocumentScreenAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentScreenAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentScreenAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentScreenAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/screen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentSoundAnnotations
     *
     * Read document sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SoundAnnotationsResponse
     */
    public function getDocumentSoundAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentSoundAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentSoundAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentSoundAnnotationsWithHttpInfo
     *
     * Read document sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SoundAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentSoundAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SoundAnnotationsResponse';
        $request = $this->getDocumentSoundAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SoundAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentSoundAnnotationsAsync
     *
     * Read document sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSoundAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentSoundAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentSoundAnnotationsAsyncWithHttpInfo
     *
     * Read document sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSoundAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SoundAnnotationsResponse';
        $request = $this->getDocumentSoundAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentSoundAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentSoundAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentSoundAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/sound';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentSquareAnnotations
     *
     * Read document square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquareAnnotationsResponse
     */
    public function getDocumentSquareAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentSquareAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentSquareAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentSquareAnnotationsWithHttpInfo
     *
     * Read document square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquareAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentSquareAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationsResponse';
        $request = $this->getDocumentSquareAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquareAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentSquareAnnotationsAsync
     *
     * Read document square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSquareAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentSquareAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentSquareAnnotationsAsyncWithHttpInfo
     *
     * Read document square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSquareAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationsResponse';
        $request = $this->getDocumentSquareAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentSquareAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentSquareAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentSquareAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/square';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentSquigglyAnnotations
     *
     * Read document squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquigglyAnnotationsResponse
     */
    public function getDocumentSquigglyAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentSquigglyAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentSquigglyAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentSquigglyAnnotationsWithHttpInfo
     *
     * Read document squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquigglyAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentSquigglyAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationsResponse';
        $request = $this->getDocumentSquigglyAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquigglyAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentSquigglyAnnotationsAsync
     *
     * Read document squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSquigglyAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentSquigglyAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentSquigglyAnnotationsAsyncWithHttpInfo
     *
     * Read document squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSquigglyAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationsResponse';
        $request = $this->getDocumentSquigglyAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentSquigglyAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentSquigglyAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentSquigglyAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/squiggly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentStampAnnotations
     *
     * Read document stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StampAnnotationsResponse
     */
    public function getDocumentStampAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentStampAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentStampAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentStampAnnotationsWithHttpInfo
     *
     * Read document stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StampAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentStampAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampAnnotationsResponse';
        $request = $this->getDocumentStampAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StampAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentStampAnnotationsAsync
     *
     * Read document stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStampAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentStampAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentStampAnnotationsAsyncWithHttpInfo
     *
     * Read document stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStampAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampAnnotationsResponse';
        $request = $this->getDocumentStampAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentStampAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentStampAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentStampAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/stamp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentStamps
     *
     * Read document stamps.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StampsInfoResponse
     */
    public function getDocumentStamps($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentStampsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentStampsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentStampsWithHttpInfo
     *
     * Read document stamps.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StampsInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentStampsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampsInfoResponse';
        $request = $this->getDocumentStampsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StampsInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentStampsAsync
     *
     * Read document stamps.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStampsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentStampsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentStampsAsyncWithHttpInfo
     *
     * Read document stamps.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStampsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampsInfoResponse';
        $request = $this->getDocumentStampsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentStamps'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentStampsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentStamps'
            );
        }

        $resourcePath = '/pdf/{name}/stamps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentStrikeOutAnnotations
     *
     * Read document StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StrikeOutAnnotationsResponse
     */
    public function getDocumentStrikeOutAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentStrikeOutAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentStrikeOutAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentStrikeOutAnnotationsWithHttpInfo
     *
     * Read document StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StrikeOutAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentStrikeOutAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationsResponse';
        $request = $this->getDocumentStrikeOutAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StrikeOutAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentStrikeOutAnnotationsAsync
     *
     * Read document StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStrikeOutAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentStrikeOutAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentStrikeOutAnnotationsAsyncWithHttpInfo
     *
     * Read document StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStrikeOutAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationsResponse';
        $request = $this->getDocumentStrikeOutAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentStrikeOutAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentStrikeOutAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentStrikeOutAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/strikeout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentTables
     *
     * Read document tables.
     *
     * @param  string $name name (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TablesRecognizedResponse
     */
    public function getDocumentTables($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentTablesWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentTablesWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentTablesWithHttpInfo
     *
     * Read document tables.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TablesRecognizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentTablesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TablesRecognizedResponse';
        $request = $this->getDocumentTablesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TablesRecognizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentTablesAsync
     *
     * Read document tables.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentTablesAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentTablesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentTablesAsyncWithHttpInfo
     *
     * Read document tables.
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentTablesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TablesRecognizedResponse';
        $request = $this->getDocumentTablesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentTables'
     *
     * @param  string $name (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentTablesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentTables'
            );
        }

        $resourcePath = '/pdf/{name}/tables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentTextAnnotations
     *
     * Read document text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextAnnotationsResponse
     */
    public function getDocumentTextAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentTextAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentTextAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentTextAnnotationsWithHttpInfo
     *
     * Read document text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentTextAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationsResponse';
        $request = $this->getDocumentTextAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentTextAnnotationsAsync
     *
     * Read document text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentTextAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentTextAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentTextAnnotationsAsyncWithHttpInfo
     *
     * Read document text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentTextAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationsResponse';
        $request = $this->getDocumentTextAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentTextAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentUnderlineAnnotations
     *
     * Read document underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\UnderlineAnnotationsResponse
     */
    public function getDocumentUnderlineAnnotations($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDocumentUnderlineAnnotationsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDocumentUnderlineAnnotationsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDocumentUnderlineAnnotationsWithHttpInfo
     *
     * Read document underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\UnderlineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentUnderlineAnnotationsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationsResponse';
        $request = $this->getDocumentUnderlineAnnotationsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\UnderlineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentUnderlineAnnotationsAsync
     *
     * Read document underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentUnderlineAnnotationsAsync($name, $storage = null, $folder = null)
    {
        return $this->getDocumentUnderlineAnnotationsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentUnderlineAnnotationsAsyncWithHttpInfo
     *
     * Read document underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentUnderlineAnnotationsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationsResponse';
        $request = $this->getDocumentUnderlineAnnotationsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentUnderlineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDocumentUnderlineAnnotationsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDocumentUnderlineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/underline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownload
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDownload($path, $version_id = null, $storage = null)
    {
        try
        {
            list($response) = $this->getDownloadWithHttpInfo($path, $version_id, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDownloadWithHttpInfo($path, $version_id, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDownloadWithHttpInfo
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadRequest($path, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadAsync
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadAsync($path, $version_id = null, $storage = null)
    {
        return $this->getDownloadAsyncWithHttpInfo($path, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadAsyncWithHttpInfo
     *
     * Download a specific file
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadAsyncWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadRequest($path, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownload'
     *
     * @param  string $path Path of the file including the file name and extension e.g. /file.ext (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadRequest($path, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getDownload'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndex
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDownloadDocumentAttachmentByIndex($name, $attachment_index, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexWithHttpInfo
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadDocumentAttachmentByIndexWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexAsync
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadDocumentAttachmentByIndexAsync($name, $attachment_index, $storage = null, $folder = null)
    {
        return $this->getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo
     *
     * Download document attachment content by its index.
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadDocumentAttachmentByIndexAsyncWithHttpInfo($name, $attachment_index, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadDocumentAttachmentByIndex'
     *
     * @param  string $name The document name. (required)
     * @param  int $attachment_index The attachment index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadDocumentAttachmentByIndexRequest($name, $attachment_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getDownloadDocumentAttachmentByIndex'
            );
        }
        // verify the required parameter 'attachment_index' is set
        if ($attachment_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_index when calling getDownloadDocumentAttachmentByIndex'
            );
        }

        $resourcePath = '/pdf/{name}/attachments/{attachmentIndex}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($attachment_index !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentIndex' . '}',
                ObjectSerializer::toPathValue($attachment_index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpubInStorageToPdf
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getEpubInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getEpubInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getEpubInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getEpubInStorageToPdfWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEpubInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getEpubInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEpubInStorageToPdfAsync
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpubInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getEpubInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpubInStorageToPdfAsyncWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpubInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getEpubInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEpubInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEpubInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getEpubInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getField
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldResponse
     */
    public function getField($name, $field_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getFieldWithHttpInfo($name, $field_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getFieldWithHttpInfo($name, $field_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getFieldWithHttpInfo
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->getFieldRequest($name, $field_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldAsync
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsync($name, $field_name, $storage = null, $folder = null)
    {
        return $this->getFieldAsyncWithHttpInfo($name, $field_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldAsyncWithHttpInfo
     *
     * Get document field by name.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsyncWithHttpInfo($name, $field_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->getFieldRequest($name, $field_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The field name/ (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFieldRequest($name, $field_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFields
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldsResponse
     */
    public function getFields($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getFieldsWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getFieldsWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getFieldsWithHttpInfo
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldsWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->getFieldsRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldsAsync
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsync($name, $storage = null, $folder = null)
    {
        return $this->getFieldsAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldsAsyncWithHttpInfo
     *
     * Get document fields.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->getFieldsRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFields'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFieldsRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFields'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileAttachmentAnnotation
     *
     * Read document page FileAttachment annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FileAttachmentAnnotationResponse
     */
    public function getFileAttachmentAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getFileAttachmentAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getFileAttachmentAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getFileAttachmentAnnotationWithHttpInfo
     *
     * Read document page FileAttachment annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FileAttachmentAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileAttachmentAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FileAttachmentAnnotationResponse';
        $request = $this->getFileAttachmentAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FileAttachmentAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileAttachmentAnnotationAsync
     *
     * Read document page FileAttachment annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAttachmentAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getFileAttachmentAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileAttachmentAnnotationAsyncWithHttpInfo
     *
     * Read document page FileAttachment annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAttachmentAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FileAttachmentAnnotationResponse';
        $request = $this->getFileAttachmentAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileAttachmentAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFileAttachmentAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFileAttachmentAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getFileAttachmentAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/fileattachment/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileAttachmentAnnotationData
     *
     * Read document page FileAttachment annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getFileAttachmentAnnotationData($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getFileAttachmentAnnotationDataWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getFileAttachmentAnnotationDataWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getFileAttachmentAnnotationDataWithHttpInfo
     *
     * Read document page FileAttachment annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileAttachmentAnnotationDataWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getFileAttachmentAnnotationDataRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileAttachmentAnnotationDataAsync
     *
     * Read document page FileAttachment annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAttachmentAnnotationDataAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getFileAttachmentAnnotationDataAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileAttachmentAnnotationDataAsyncWithHttpInfo
     *
     * Read document page FileAttachment annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAttachmentAnnotationDataAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getFileAttachmentAnnotationDataRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileAttachmentAnnotationData'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFileAttachmentAnnotationDataRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFileAttachmentAnnotationData'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getFileAttachmentAnnotationData'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/fileattachment/{annotationId}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFreeTextAnnotation
     *
     * Read document page free text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FreeTextAnnotationResponse
     */
    public function getFreeTextAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getFreeTextAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getFreeTextAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getFreeTextAnnotationWithHttpInfo
     *
     * Read document page free text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FreeTextAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFreeTextAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationResponse';
        $request = $this->getFreeTextAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FreeTextAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFreeTextAnnotationAsync
     *
     * Read document page free text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFreeTextAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getFreeTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFreeTextAnnotationAsyncWithHttpInfo
     *
     * Read document page free text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFreeTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationResponse';
        $request = $this->getFreeTextAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFreeTextAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFreeTextAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getFreeTextAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getFreeTextAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/freetext/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHighlightAnnotation
     *
     * Read document page highlight annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\HighlightAnnotationResponse
     */
    public function getHighlightAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getHighlightAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getHighlightAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getHighlightAnnotationWithHttpInfo
     *
     * Read document page highlight annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\HighlightAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHighlightAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationResponse';
        $request = $this->getHighlightAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\HighlightAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHighlightAnnotationAsync
     *
     * Read document page highlight annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHighlightAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getHighlightAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHighlightAnnotationAsyncWithHttpInfo
     *
     * Read document page highlight annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHighlightAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationResponse';
        $request = $this->getHighlightAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHighlightAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHighlightAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getHighlightAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getHighlightAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/highlight/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHtmlInStorageToPdf
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getHtmlInStorageToPdf($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        try
        {
            list($response) = $this->getHtmlInStorageToPdfWithHttpInfo($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getHtmlInStorageToPdfWithHttpInfo($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getHtmlInStorageToPdfWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHtmlInStorageToPdfWithHttpInfo($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getHtmlInStorageToPdfRequest($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHtmlInStorageToPdfAsync
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHtmlInStorageToPdfAsync($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        return $this->getHtmlInStorageToPdfAsyncWithHttpInfo($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHtmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHtmlInStorageToPdfAsyncWithHttpInfo($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getHtmlInStorageToPdfRequest($src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHtmlInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHtmlInStorageToPdfRequest($src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getHtmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($html_file_name !== null) {
            $queryParams['htmlFileName'] = ObjectSerializer::toQueryValue($html_file_name);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImage
     *
     * Read document image by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImageResponse
     */
    public function getImage($name, $image_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageWithHttpInfo($name, $image_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageWithHttpInfo($name, $image_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageWithHttpInfo
     *
     * Read document image by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageWithHttpInfo($name, $image_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->getImageRequest($name, $image_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageAsync
     *
     * Read document image by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageAsync($name, $image_id, $storage = null, $folder = null)
    {
        return $this->getImageAsyncWithHttpInfo($name, $image_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageAsyncWithHttpInfo
     *
     * Read document image by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageAsyncWithHttpInfo($name, $image_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->getImageRequest($name, $image_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImage'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageRequest($name, $image_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImage'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImage'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImageExtractAsGif
     *
     * Extract document image in GIF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImageExtractAsGif($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageExtractAsGifWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageExtractAsGifWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageExtractAsGifWithHttpInfo
     *
     * Extract document image in GIF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageExtractAsGifWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsGifRequest($name, $image_id, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageExtractAsGifAsync
     *
     * Extract document image in GIF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsGifAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        return $this->getImageExtractAsGifAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageExtractAsGifAsyncWithHttpInfo
     *
     * Extract document image in GIF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsGifAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsGifRequest($name, $image_id, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImageExtractAsGif'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageExtractAsGifRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImageExtractAsGif'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImageExtractAsGif'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImageExtractAsJpeg
     *
     * Extract document image in JPEG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImageExtractAsJpeg($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageExtractAsJpegWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageExtractAsJpegWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageExtractAsJpegWithHttpInfo
     *
     * Extract document image in JPEG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageExtractAsJpegWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsJpegRequest($name, $image_id, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageExtractAsJpegAsync
     *
     * Extract document image in JPEG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsJpegAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        return $this->getImageExtractAsJpegAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageExtractAsJpegAsyncWithHttpInfo
     *
     * Extract document image in JPEG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsJpegAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsJpegRequest($name, $image_id, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImageExtractAsJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageExtractAsJpegRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImageExtractAsJpeg'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImageExtractAsJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImageExtractAsPng
     *
     * Extract document image in PNG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImageExtractAsPng($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageExtractAsPngWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageExtractAsPngWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageExtractAsPngWithHttpInfo
     *
     * Extract document image in PNG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageExtractAsPngWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsPngRequest($name, $image_id, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageExtractAsPngAsync
     *
     * Extract document image in PNG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsPngAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        return $this->getImageExtractAsPngAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageExtractAsPngAsyncWithHttpInfo
     *
     * Extract document image in PNG format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsPngAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsPngRequest($name, $image_id, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImageExtractAsPng'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageExtractAsPngRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImageExtractAsPng'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImageExtractAsPng'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImageExtractAsTiff
     *
     * Extract document image in TIFF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getImageExtractAsTiff($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImageExtractAsTiffWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImageExtractAsTiffWithHttpInfo($name, $image_id, $width, $height, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImageExtractAsTiffWithHttpInfo
     *
     * Extract document image in TIFF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageExtractAsTiffWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsTiffRequest($name, $image_id, $width, $height, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImageExtractAsTiffAsync
     *
     * Extract document image in TIFF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsTiffAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        return $this->getImageExtractAsTiffAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageExtractAsTiffAsyncWithHttpInfo
     *
     * Extract document image in TIFF format
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageExtractAsTiffAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getImageExtractAsTiffRequest($name, $image_id, $width, $height, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImageExtractAsTiff'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImageExtractAsTiffRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImageExtractAsTiff'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling getImageExtractAsTiff'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImages
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImagesResponse
     */
    public function getImages($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getImagesWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getImagesWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getImagesWithHttpInfo
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImagesWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImagesResponse';
        $request = $this->getImagesRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getImagesAsync
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getImagesAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImagesAsyncWithHttpInfo
     *
     * Read document images.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ImagesResponse';
        $request = $this->getImagesRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImages'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getImagesRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getImages'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getImages'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInkAnnotation
     *
     * Read document page ink annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\InkAnnotationResponse
     */
    public function getInkAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getInkAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getInkAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getInkAnnotationWithHttpInfo
     *
     * Read document page ink annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\InkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInkAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationResponse';
        $request = $this->getInkAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\InkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInkAnnotationAsync
     *
     * Read document page ink annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInkAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getInkAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInkAnnotationAsyncWithHttpInfo
     *
     * Read document page ink annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInkAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationResponse';
        $request = $this->getInkAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInkAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getInkAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getInkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/ink/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIsExist
     *
     * Check if a specific file or folder exists
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FileExistResponse
     */
    public function getIsExist($path, $version_id = null, $storage = null)
    {
        try
        {
            list($response) = $this->getIsExistWithHttpInfo($path, $version_id, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getIsExistWithHttpInfo($path, $version_id, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getIsExistWithHttpInfo
     *
     * Check if a specific file or folder exists
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FileExistResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIsExistWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FileExistResponse';
        $request = $this->getIsExistRequest($path, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FileExistResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIsExistAsync
     *
     * Check if a specific file or folder exists
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIsExistAsync($path, $version_id = null, $storage = null)
    {
        return $this->getIsExistAsyncWithHttpInfo($path, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIsExistAsyncWithHttpInfo
     *
     * Check if a specific file or folder exists
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIsExistAsyncWithHttpInfo($path, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FileExistResponse';
        $request = $this->getIsExistRequest($path, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIsExist'
     *
     * @param  string $path File or folder path e.g. /file.ext or /Folder1 (required)
     * @param  string $version_id File&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIsExistRequest($path, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getIsExist'
            );
        }

        $resourcePath = '/storage/exist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIsStorageExist
     *
     * Check if storage exists
     *
     * @param  string $name Storage name (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StorageExistResponse
     */
    public function getIsStorageExist($name)
    {
        try
        {
            list($response) = $this->getIsStorageExistWithHttpInfo($name);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getIsStorageExistWithHttpInfo($name);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getIsStorageExistWithHttpInfo
     *
     * Check if storage exists
     *
     * @param  string $name Storage name (required)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StorageExistResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIsStorageExistWithHttpInfo($name)
    {
        $returnType = '\Aspose\PDF\Model\StorageExistResponse';
        $request = $this->getIsStorageExistRequest($name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StorageExistResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIsStorageExistAsync
     *
     * Check if storage exists
     *
     * @param  string $name Storage name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIsStorageExistAsync($name)
    {
        return $this->getIsStorageExistAsyncWithHttpInfo($name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIsStorageExistAsyncWithHttpInfo
     *
     * Check if storage exists
     *
     * @param  string $name Storage name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIsStorageExistAsyncWithHttpInfo($name)
    {
        $returnType = '\Aspose\PDF\Model\StorageExistResponse';
        $request = $this->getIsStorageExistRequest($name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIsStorageExist'
     *
     * @param  string $name Storage name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIsStorageExistRequest($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getIsStorageExist'
            );
        }

        $resourcePath = '/storage/{name}/exist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLaTeXInStorageToPdf
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getLaTeXInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getLaTeXInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getLaTeXInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getLaTeXInStorageToPdfWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLaTeXInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getLaTeXInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLaTeXInStorageToPdfAsync
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLaTeXInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getLaTeXInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLaTeXInStorageToPdfAsyncWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLaTeXInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getLaTeXInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLaTeXInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLaTeXInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getLaTeXInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLineAnnotation
     *
     * Read document page line annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LineAnnotationResponse
     */
    public function getLineAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getLineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getLineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getLineAnnotationWithHttpInfo
     *
     * Read document page line annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLineAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationResponse';
        $request = $this->getLineAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLineAnnotationAsync
     *
     * Read document page line annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLineAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLineAnnotationAsyncWithHttpInfo
     *
     * Read document page line annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationResponse';
        $request = $this->getLineAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLineAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getLineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getLineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/line/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLinkAnnotation
     *
     * Read document link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationResponse
     */
    public function getLinkAnnotation($name, $link_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getLinkAnnotationWithHttpInfo($name, $link_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getLinkAnnotationWithHttpInfo($name, $link_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getLinkAnnotationWithHttpInfo
     *
     * Read document link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLinkAnnotationWithHttpInfo($name, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getLinkAnnotationRequest($name, $link_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLinkAnnotationAsync
     *
     * Read document link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkAnnotationAsync($name, $link_id, $storage = null, $folder = null)
    {
        return $this->getLinkAnnotationAsyncWithHttpInfo($name, $link_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLinkAnnotationAsyncWithHttpInfo
     *
     * Read document link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLinkAnnotationAsyncWithHttpInfo($name, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getLinkAnnotationRequest($name, $link_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLinkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLinkAnnotationRequest($name, $link_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getLinkAnnotation'
            );
        }
        // verify the required parameter 'link_id' is set
        if ($link_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_id when calling getLinkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/links/{linkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'linkId' . '}',
                ObjectSerializer::toPathValue($link_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getListFileVersions
     *
     * Get the file's versions list
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FileVersionsResponse
     */
    public function getListFileVersions($path, $storage = null)
    {
        try
        {
            list($response) = $this->getListFileVersionsWithHttpInfo($path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getListFileVersionsWithHttpInfo($path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getListFileVersionsWithHttpInfo
     *
     * Get the file's versions list
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FileVersionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListFileVersionsWithHttpInfo($path, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FileVersionsResponse';
        $request = $this->getListFileVersionsRequest($path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FileVersionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getListFileVersionsAsync
     *
     * Get the file's versions list
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListFileVersionsAsync($path, $storage = null)
    {
        return $this->getListFileVersionsAsyncWithHttpInfo($path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListFileVersionsAsyncWithHttpInfo
     *
     * Get the file's versions list
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListFileVersionsAsyncWithHttpInfo($path, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FileVersionsResponse';
        $request = $this->getListFileVersionsRequest($path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getListFileVersions'
     *
     * @param  string $path File path e.g. /file.ext or /Folder1/file.ext (required)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getListFileVersionsRequest($path, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getListFileVersions'
            );
        }

        $resourcePath = '/storage/version';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getListFiles
     *
     * Get the file listing of a specific folder
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FilesResponse
     */
    public function getListFiles($path = '/', $storage = null)
    {
        try
        {
            list($response) = $this->getListFilesWithHttpInfo($path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getListFilesWithHttpInfo($path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getListFilesWithHttpInfo
     *
     * Get the file listing of a specific folder
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FilesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListFilesWithHttpInfo($path = '/', $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FilesResponse';
        $request = $this->getListFilesRequest($path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FilesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getListFilesAsync
     *
     * Get the file listing of a specific folder
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListFilesAsync($path = '/', $storage = null)
    {
        return $this->getListFilesAsyncWithHttpInfo($path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListFilesAsyncWithHttpInfo
     *
     * Get the file listing of a specific folder
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListFilesAsyncWithHttpInfo($path = '/', $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\FilesResponse';
        $request = $this->getListFilesRequest($path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getListFiles'
     *
     * @param  string $path Start with name of storage e.g. root folder &#39;/&#39;or some folder &#39;/folder1/..&#39; (optional, default to /)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getListFilesRequest($path = '/', $storage = null)
    {

        $resourcePath = '/storage/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMhtInStorageToPdf
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getMhtInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getMhtInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getMhtInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getMhtInStorageToPdfWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMhtInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getMhtInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMhtInStorageToPdfAsync
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMhtInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getMhtInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMhtInStorageToPdfAsyncWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMhtInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getMhtInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMhtInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMhtInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getMhtInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/mht';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMovieAnnotation
     *
     * Read document page movie annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\MovieAnnotationResponse
     */
    public function getMovieAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getMovieAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getMovieAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getMovieAnnotationWithHttpInfo
     *
     * Read document page movie annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\MovieAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMovieAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\MovieAnnotationResponse';
        $request = $this->getMovieAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\MovieAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMovieAnnotationAsync
     *
     * Read document page movie annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMovieAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getMovieAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMovieAnnotationAsyncWithHttpInfo
     *
     * Read document page movie annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMovieAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\MovieAnnotationResponse';
        $request = $this->getMovieAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMovieAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMovieAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getMovieAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getMovieAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/movie/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPage
     *
     * Read document page info.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPageResponse
     */
    public function getPage($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageWithHttpInfo
     *
     * Read document page info.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPageResponse';
        $request = $this->getPageRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAsync
     *
     * Read document page info.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAsyncWithHttpInfo
     *
     * Read document page info.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPageResponse';
        $request = $this->getPageRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageAnnotations
     *
     * Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AnnotationsInfoResponse
     */
    public function getPageAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageAnnotationsWithHttpInfo
     *
     * Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AnnotationsInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsInfoResponse';
        $request = $this->getPageAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AnnotationsInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageAnnotationsAsync
     *
     * Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageAnnotationsAsyncWithHttpInfo
     *
     * Read document page annotations. Returns only FreeTextAnnotations, TextAnnotations, other annotations will implemented next releases.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AnnotationsInfoResponse';
        $request = $this->getPageAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageCaretAnnotations
     *
     * Read document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CaretAnnotationsResponse
     */
    public function getPageCaretAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageCaretAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageCaretAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageCaretAnnotationsWithHttpInfo
     *
     * Read document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CaretAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageCaretAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationsResponse';
        $request = $this->getPageCaretAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CaretAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageCaretAnnotationsAsync
     *
     * Read document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageCaretAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageCaretAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageCaretAnnotationsAsyncWithHttpInfo
     *
     * Read document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageCaretAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationsResponse';
        $request = $this->getPageCaretAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageCaretAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageCaretAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageCaretAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageCaretAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/caret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageCircleAnnotations
     *
     * Read document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CircleAnnotationsResponse
     */
    public function getPageCircleAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageCircleAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageCircleAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageCircleAnnotationsWithHttpInfo
     *
     * Read document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CircleAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageCircleAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationsResponse';
        $request = $this->getPageCircleAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CircleAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageCircleAnnotationsAsync
     *
     * Read document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageCircleAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageCircleAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageCircleAnnotationsAsyncWithHttpInfo
     *
     * Read document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageCircleAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationsResponse';
        $request = $this->getPageCircleAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageCircleAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageCircleAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageCircleAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageCircleAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/circle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToBmp
     *
     * Convert document page to Bmp image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToBmp($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToBmpWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToBmpWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToBmpWithHttpInfo
     *
     * Convert document page to Bmp image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToBmpWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToBmpRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToBmpAsync
     *
     * Convert document page to Bmp image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToBmpAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToBmpAsyncWithHttpInfo
     *
     * Convert document page to Bmp image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToBmpRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToBmp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToBmpRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToBmp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToBmp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/bmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToEmf
     *
     * Convert document page to Emf image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToEmf($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToEmfWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToEmfWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToEmfWithHttpInfo
     *
     * Convert document page to Emf image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToEmfWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToEmfRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToEmfAsync
     *
     * Convert document page to Emf image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToEmfAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToEmfAsyncWithHttpInfo
     *
     * Convert document page to Emf image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToEmfRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToEmf'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToEmfRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToEmf'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToEmf'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/emf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToGif
     *
     * Convert document page to Gif image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToGif($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToGifWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToGifWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToGifWithHttpInfo
     *
     * Convert document page to Gif image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToGifWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToGifRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToGifAsync
     *
     * Convert document page to Gif image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToGifAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToGifAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToGifAsyncWithHttpInfo
     *
     * Convert document page to Gif image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToGifAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToGifRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToGif'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToGifRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToGif'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToGif'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToJpeg
     *
     * Convert document page to Jpeg image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToJpeg($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToJpegWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToJpegWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToJpegWithHttpInfo
     *
     * Convert document page to Jpeg image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToJpegWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToJpegRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToJpegAsync
     *
     * Convert document page to Jpeg image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToJpegAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToJpegAsyncWithHttpInfo
     *
     * Convert document page to Jpeg image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToJpegRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToJpegRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToJpeg'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToPng
     *
     * Convert document page to Png image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToPng($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToPngWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToPngWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToPngWithHttpInfo
     *
     * Convert document page to Png image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToPngWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToPngRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToPngAsync
     *
     * Convert document page to Png image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToPngAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToPngAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToPngAsyncWithHttpInfo
     *
     * Convert document page to Png image and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToPngAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToPngRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToPng'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToPngRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToPng'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToPng'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageConvertToTiff
     *
     * Convert document page to Tiff image  and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPageConvertToTiff($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageConvertToTiffWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageConvertToTiffWithHttpInfo($name, $page_number, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageConvertToTiffWithHttpInfo
     *
     * Convert document page to Tiff image  and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageConvertToTiffWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToTiffRequest($name, $page_number, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageConvertToTiffAsync
     *
     * Convert document page to Tiff image  and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToTiffAsync($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->getPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageConvertToTiffAsyncWithHttpInfo
     *
     * Convert document page to Tiff image  and return resulting file in response.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPageConvertToTiffRequest($name, $page_number, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageConvertToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageConvertToTiffRequest($name, $page_number, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageConvertToTiff'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageConvertToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageFileAttachmentAnnotations
     *
     * Read document page FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FileAttachmentAnnotationsResponse
     */
    public function getPageFileAttachmentAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageFileAttachmentAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageFileAttachmentAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageFileAttachmentAnnotationsWithHttpInfo
     *
     * Read document page FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FileAttachmentAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageFileAttachmentAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FileAttachmentAnnotationsResponse';
        $request = $this->getPageFileAttachmentAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FileAttachmentAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageFileAttachmentAnnotationsAsync
     *
     * Read document page FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageFileAttachmentAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageFileAttachmentAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageFileAttachmentAnnotationsAsyncWithHttpInfo
     *
     * Read document page FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageFileAttachmentAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FileAttachmentAnnotationsResponse';
        $request = $this->getPageFileAttachmentAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageFileAttachmentAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageFileAttachmentAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageFileAttachmentAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageFileAttachmentAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/fileattachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageFreeTextAnnotations
     *
     * Read document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FreeTextAnnotationsResponse
     */
    public function getPageFreeTextAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageFreeTextAnnotationsWithHttpInfo
     *
     * Read document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FreeTextAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationsResponse';
        $request = $this->getPageFreeTextAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FreeTextAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageFreeTextAnnotationsAsync
     *
     * Read document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageFreeTextAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageFreeTextAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageFreeTextAnnotationsAsyncWithHttpInfo
     *
     * Read document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageFreeTextAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationsResponse';
        $request = $this->getPageFreeTextAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageFreeTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageFreeTextAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageFreeTextAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageFreeTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/freetext';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageHighlightAnnotations
     *
     * Read document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\HighlightAnnotationsResponse
     */
    public function getPageHighlightAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageHighlightAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageHighlightAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageHighlightAnnotationsWithHttpInfo
     *
     * Read document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\HighlightAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageHighlightAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationsResponse';
        $request = $this->getPageHighlightAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\HighlightAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageHighlightAnnotationsAsync
     *
     * Read document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageHighlightAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageHighlightAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageHighlightAnnotationsAsyncWithHttpInfo
     *
     * Read document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageHighlightAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationsResponse';
        $request = $this->getPageHighlightAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageHighlightAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageHighlightAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageHighlightAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageHighlightAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/highlight';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageInkAnnotations
     *
     * Read document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\InkAnnotationsResponse
     */
    public function getPageInkAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageInkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageInkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageInkAnnotationsWithHttpInfo
     *
     * Read document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\InkAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageInkAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationsResponse';
        $request = $this->getPageInkAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\InkAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageInkAnnotationsAsync
     *
     * Read document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageInkAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageInkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageInkAnnotationsAsyncWithHttpInfo
     *
     * Read document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageInkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationsResponse';
        $request = $this->getPageInkAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageInkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageInkAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageInkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageInkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/ink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLineAnnotations
     *
     * Read document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LineAnnotationsResponse
     */
    public function getPageLineAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageLineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageLineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageLineAnnotationsWithHttpInfo
     *
     * Read document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLineAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationsResponse';
        $request = $this->getPageLineAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLineAnnotationsAsync
     *
     * Read document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLineAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageLineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLineAnnotationsAsyncWithHttpInfo
     *
     * Read document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationsResponse';
        $request = $this->getPageLineAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLineAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/line';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLinkAnnotation
     *
     * Read document page link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationResponse
     */
    public function getPageLinkAnnotation($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageLinkAnnotationWithHttpInfo($name, $page_number, $link_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageLinkAnnotationWithHttpInfo($name, $page_number, $link_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageLinkAnnotationWithHttpInfo
     *
     * Read document page link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLinkAnnotationWithHttpInfo($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getPageLinkAnnotationRequest($name, $page_number, $link_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLinkAnnotationAsync
     *
     * Read document page link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationAsync($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        return $this->getPageLinkAnnotationAsyncWithHttpInfo($name, $page_number, $link_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLinkAnnotationAsyncWithHttpInfo
     *
     * Read document page link annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationAsyncWithHttpInfo($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->getPageLinkAnnotationRequest($name, $page_number, $link_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLinkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $link_id The link ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLinkAnnotationRequest($name, $page_number, $link_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLinkAnnotation'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLinkAnnotation'
            );
        }
        // verify the required parameter 'link_id' is set
        if ($link_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_id when calling getPageLinkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links/{linkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }
        // path params
        if ($link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'linkId' . '}',
                ObjectSerializer::toPathValue($link_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageLinkAnnotations
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationsResponse
     */
    public function getPageLinkAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageLinkAnnotationsWithHttpInfo
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageLinkAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationsResponse';
        $request = $this->getPageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageLinkAnnotationsAsync
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageLinkAnnotationsAsyncWithHttpInfo
     *
     * Read document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationsResponse';
        $request = $this->getPageLinkAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageLinkAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageLinkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageMovieAnnotations
     *
     * Read document page movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\MovieAnnotationsResponse
     */
    public function getPageMovieAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageMovieAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageMovieAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageMovieAnnotationsWithHttpInfo
     *
     * Read document page movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\MovieAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageMovieAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\MovieAnnotationsResponse';
        $request = $this->getPageMovieAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\MovieAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageMovieAnnotationsAsync
     *
     * Read document page movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageMovieAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageMovieAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageMovieAnnotationsAsyncWithHttpInfo
     *
     * Read document page movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageMovieAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\MovieAnnotationsResponse';
        $request = $this->getPageMovieAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageMovieAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageMovieAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageMovieAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageMovieAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/movie';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagePolyLineAnnotations
     *
     * Read document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolyLineAnnotationsResponse
     */
    public function getPagePolyLineAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPagePolyLineAnnotationsWithHttpInfo
     *
     * Read document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolyLineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationsResponse';
        $request = $this->getPagePolyLineAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolyLineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagePolyLineAnnotationsAsync
     *
     * Read document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePolyLineAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPagePolyLineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagePolyLineAnnotationsAsyncWithHttpInfo
     *
     * Read document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePolyLineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationsResponse';
        $request = $this->getPagePolyLineAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagePolyLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagePolyLineAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPagePolyLineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPagePolyLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/polyline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagePolygonAnnotations
     *
     * Read document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolygonAnnotationsResponse
     */
    public function getPagePolygonAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPagePolygonAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPagePolygonAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPagePolygonAnnotationsWithHttpInfo
     *
     * Read document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolygonAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagePolygonAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationsResponse';
        $request = $this->getPagePolygonAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolygonAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagePolygonAnnotationsAsync
     *
     * Read document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePolygonAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPagePolygonAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagePolygonAnnotationsAsyncWithHttpInfo
     *
     * Read document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePolygonAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationsResponse';
        $request = $this->getPagePolygonAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagePolygonAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagePolygonAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPagePolygonAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPagePolygonAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/polygon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagePopupAnnotations
     *
     * Read document page popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationsResponse
     */
    public function getPagePopupAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPagePopupAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPagePopupAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPagePopupAnnotationsWithHttpInfo
     *
     * Read document page popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagePopupAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getPagePopupAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagePopupAnnotationsAsync
     *
     * Read document page popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePopupAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPagePopupAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagePopupAnnotationsAsyncWithHttpInfo
     *
     * Read document page popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagePopupAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationsResponse';
        $request = $this->getPagePopupAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagePopupAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagePopupAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPagePopupAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPagePopupAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/popup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageRedactionAnnotations
     *
     * Read document page redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\RedactionAnnotationsResponse
     */
    public function getPageRedactionAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageRedactionAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageRedactionAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageRedactionAnnotationsWithHttpInfo
     *
     * Read document page redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\RedactionAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageRedactionAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\RedactionAnnotationsResponse';
        $request = $this->getPageRedactionAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\RedactionAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageRedactionAnnotationsAsync
     *
     * Read document page redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageRedactionAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageRedactionAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageRedactionAnnotationsAsyncWithHttpInfo
     *
     * Read document page redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageRedactionAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\RedactionAnnotationsResponse';
        $request = $this->getPageRedactionAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageRedactionAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageRedactionAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageRedactionAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageRedactionAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/redaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageScreenAnnotations
     *
     * Read document page screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ScreenAnnotationsResponse
     */
    public function getPageScreenAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageScreenAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageScreenAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageScreenAnnotationsWithHttpInfo
     *
     * Read document page screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ScreenAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageScreenAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ScreenAnnotationsResponse';
        $request = $this->getPageScreenAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ScreenAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageScreenAnnotationsAsync
     *
     * Read document page screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageScreenAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageScreenAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageScreenAnnotationsAsyncWithHttpInfo
     *
     * Read document page screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageScreenAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ScreenAnnotationsResponse';
        $request = $this->getPageScreenAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageScreenAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageScreenAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageScreenAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageScreenAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/screen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageSoundAnnotations
     *
     * Read document page sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SoundAnnotationsResponse
     */
    public function getPageSoundAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageSoundAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageSoundAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageSoundAnnotationsWithHttpInfo
     *
     * Read document page sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SoundAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageSoundAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SoundAnnotationsResponse';
        $request = $this->getPageSoundAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SoundAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageSoundAnnotationsAsync
     *
     * Read document page sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSoundAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageSoundAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageSoundAnnotationsAsyncWithHttpInfo
     *
     * Read document page sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSoundAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SoundAnnotationsResponse';
        $request = $this->getPageSoundAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageSoundAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageSoundAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageSoundAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageSoundAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/sound';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageSquareAnnotations
     *
     * Read document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquareAnnotationsResponse
     */
    public function getPageSquareAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageSquareAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageSquareAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageSquareAnnotationsWithHttpInfo
     *
     * Read document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquareAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageSquareAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationsResponse';
        $request = $this->getPageSquareAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquareAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageSquareAnnotationsAsync
     *
     * Read document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSquareAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageSquareAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageSquareAnnotationsAsyncWithHttpInfo
     *
     * Read document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSquareAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationsResponse';
        $request = $this->getPageSquareAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageSquareAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageSquareAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageSquareAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageSquareAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/square';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageSquigglyAnnotations
     *
     * Read document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquigglyAnnotationsResponse
     */
    public function getPageSquigglyAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageSquigglyAnnotationsWithHttpInfo
     *
     * Read document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquigglyAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationsResponse';
        $request = $this->getPageSquigglyAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquigglyAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageSquigglyAnnotationsAsync
     *
     * Read document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSquigglyAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageSquigglyAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageSquigglyAnnotationsAsyncWithHttpInfo
     *
     * Read document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageSquigglyAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationsResponse';
        $request = $this->getPageSquigglyAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageSquigglyAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageSquigglyAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageSquigglyAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageSquigglyAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/squiggly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageStampAnnotations
     *
     * Read document page stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StampAnnotationsResponse
     */
    public function getPageStampAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageStampAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageStampAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageStampAnnotationsWithHttpInfo
     *
     * Read document page stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StampAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageStampAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampAnnotationsResponse';
        $request = $this->getPageStampAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StampAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageStampAnnotationsAsync
     *
     * Read document page stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageStampAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageStampAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageStampAnnotationsAsyncWithHttpInfo
     *
     * Read document page stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageStampAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampAnnotationsResponse';
        $request = $this->getPageStampAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageStampAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageStampAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageStampAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageStampAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/stamp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageStamps
     *
     * Read page document stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StampsInfoResponse
     */
    public function getPageStamps($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageStampsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageStampsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageStampsWithHttpInfo
     *
     * Read page document stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StampsInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageStampsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampsInfoResponse';
        $request = $this->getPageStampsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StampsInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageStampsAsync
     *
     * Read page document stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageStampsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageStampsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageStampsAsyncWithHttpInfo
     *
     * Read page document stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageStampsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampsInfoResponse';
        $request = $this->getPageStampsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageStamps'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageStampsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageStamps'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageStamps'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/stamps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageStrikeOutAnnotations
     *
     * Read document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StrikeOutAnnotationsResponse
     */
    public function getPageStrikeOutAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageStrikeOutAnnotationsWithHttpInfo
     *
     * Read document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StrikeOutAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationsResponse';
        $request = $this->getPageStrikeOutAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StrikeOutAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageStrikeOutAnnotationsAsync
     *
     * Read document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageStrikeOutAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageStrikeOutAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageStrikeOutAnnotationsAsyncWithHttpInfo
     *
     * Read document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageStrikeOutAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationsResponse';
        $request = $this->getPageStrikeOutAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageStrikeOutAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageStrikeOutAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageStrikeOutAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageStrikeOutAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/strikeout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageTables
     *
     * Read document page tables.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TablesRecognizedResponse
     */
    public function getPageTables($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageTablesWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageTablesWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageTablesWithHttpInfo
     *
     * Read document page tables.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TablesRecognizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageTablesWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TablesRecognizedResponse';
        $request = $this->getPageTablesRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TablesRecognizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageTablesAsync
     *
     * Read document page tables.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTablesAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageTablesAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageTablesAsyncWithHttpInfo
     *
     * Read document page tables.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTablesAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TablesRecognizedResponse';
        $request = $this->getPageTablesRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageTables'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageTablesRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageTables'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageTables'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/tables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageText
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextRectsResponse
     */
    public function getPageText($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPageTextWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageTextWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageTextWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextRectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageTextWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getPageTextRequest($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextRectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageTextAsync
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAsync($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        return $this->getPageTextAsyncWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageTextAsyncWithHttpInfo
     *
     * Read page text items.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAsyncWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getPageTextRequest($name, $page_number, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageText'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageTextRequest($name, $page_number, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageText'
            );
        }
        // verify the required parameter 'llx' is set
        if ($llx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $llx when calling getPageText'
            );
        }
        // verify the required parameter 'lly' is set
        if ($lly === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lly when calling getPageText'
            );
        }
        // verify the required parameter 'urx' is set
        if ($urx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $urx when calling getPageText'
            );
        }
        // verify the required parameter 'ury' is set
        if ($ury === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ury when calling getPageText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($format)) {
            $format = ObjectSerializer::serializeCollection($format, 'multi', true);
        }
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($regex !== null) {
            $queryParams['regex'] = ObjectSerializer::toQueryValue($regex);
        }
        // query params
        if ($split_rects !== null) {
            $queryParams['splitRects'] = ObjectSerializer::toQueryValue($split_rects);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($llx !== null) {
            $queryParams['LLX'] = ObjectSerializer::toQueryValue($llx);
        }
        // query params
        if ($lly !== null) {
            $queryParams['LLY'] = ObjectSerializer::toQueryValue($lly);
        }
        // query params
        if ($urx !== null) {
            $queryParams['URX'] = ObjectSerializer::toQueryValue($urx);
        }
        // query params
        if ($ury !== null) {
            $queryParams['URY'] = ObjectSerializer::toQueryValue($ury);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageTextAnnotations
     *
     * Read document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextAnnotationsResponse
     */
    public function getPageTextAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageTextAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageTextAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageTextAnnotationsWithHttpInfo
     *
     * Read document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageTextAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationsResponse';
        $request = $this->getPageTextAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageTextAnnotationsAsync
     *
     * Read document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageTextAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageTextAnnotationsAsyncWithHttpInfo
     *
     * Read document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageTextAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationsResponse';
        $request = $this->getPageTextAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageTextAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageTextAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPageUnderlineAnnotations
     *
     * Read document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\UnderlineAnnotationsResponse
     */
    public function getPageUnderlineAnnotations($name, $page_number, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPageUnderlineAnnotationsWithHttpInfo
     *
     * Read document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\UnderlineAnnotationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationsResponse';
        $request = $this->getPageUnderlineAnnotationsRequest($name, $page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\UnderlineAnnotationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPageUnderlineAnnotationsAsync
     *
     * Read document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageUnderlineAnnotationsAsync($name, $page_number, $storage = null, $folder = null)
    {
        return $this->getPageUnderlineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPageUnderlineAnnotationsAsyncWithHttpInfo
     *
     * Read document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPageUnderlineAnnotationsAsyncWithHttpInfo($name, $page_number, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationsResponse';
        $request = $this->getPageUnderlineAnnotationsRequest($name, $page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPageUnderlineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPageUnderlineAnnotationsRequest($name, $page_number, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPageUnderlineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling getPageUnderlineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/underline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPages
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPagesResponse
     */
    public function getPages($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPagesWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPagesWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPagesWithHttpInfo
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagesWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->getPagesRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagesAsync
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesAsync($name, $storage = null, $folder = null)
    {
        return $this->getPagesAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagesAsyncWithHttpInfo
     *
     * Read document pages info.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->getPagesRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPages'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPagesRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPages'
            );
        }

        $resourcePath = '/pdf/{name}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPclInStorageToPdf
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPclInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getPclInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPclInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPclInStorageToPdfWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPclInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPclInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPclInStorageToPdfAsync
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPclInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getPclInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPclInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPclInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPclInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPclInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPclInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getPclInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/pcl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToDoc
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToDoc($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToDocWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToDocWithHttpInfo($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToDocRequest($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToDocAsync
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToDocAsync($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToDocAsyncWithHttpInfo($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToDocAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToDocAsyncWithHttpInfo($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToDocRequest($name, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToDoc'
     *
     * @param  string $name The document name. (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToDocRequest($name, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToDoc'
            );
        }

        $resourcePath = '/pdf/{name}/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToEpub
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToEpub($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToEpubWithHttpInfo($name, $content_recognition_mode, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToEpubWithHttpInfo($name, $content_recognition_mode, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToEpubWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToEpubWithHttpInfo($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToEpubRequest($name, $content_recognition_mode, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToEpubAsync
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToEpubAsync($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToEpubAsyncWithHttpInfo($name, $content_recognition_mode, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToEpubAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToEpubAsyncWithHttpInfo($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToEpubRequest($name, $content_recognition_mode, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToEpub'
     *
     * @param  string $name The document name. (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToEpubRequest($name, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToEpub'
            );
        }

        $resourcePath = '/pdf/{name}/convert/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($content_recognition_mode !== null) {
            $queryParams['contentRecognitionMode'] = ObjectSerializer::toQueryValue($content_recognition_mode);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToHtml
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToHtml($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToHtmlWithHttpInfo($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToHtmlWithHttpInfo($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToHtmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToHtmlWithHttpInfo($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToHtmlRequest($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToHtmlAsync
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToHtmlAsync($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToHtmlAsyncWithHttpInfo($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToHtmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToHtmlAsyncWithHttpInfo($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToHtmlRequest($name, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToHtml'
     *
     * @param  string $name The document name. (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToHtmlRequest($name, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToHtml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($additional_margin_width_in_points !== null) {
            $queryParams['additionalMarginWidthInPoints'] = ObjectSerializer::toQueryValue($additional_margin_width_in_points);
        }
        // query params
        if ($compress_svg_graphics_if_any !== null) {
            $queryParams['compressSvgGraphicsIfAny'] = ObjectSerializer::toQueryValue($compress_svg_graphics_if_any);
        }
        // query params
        if ($convert_marked_content_to_layers !== null) {
            $queryParams['convertMarkedContentToLayers'] = ObjectSerializer::toQueryValue($convert_marked_content_to_layers);
        }
        // query params
        if ($default_font_name !== null) {
            $queryParams['defaultFontName'] = ObjectSerializer::toQueryValue($default_font_name);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($fixed_layout !== null) {
            $queryParams['fixedLayout'] = ObjectSerializer::toQueryValue($fixed_layout);
        }
        // query params
        if ($image_resolution !== null) {
            $queryParams['imageResolution'] = ObjectSerializer::toQueryValue($image_resolution);
        }
        // query params
        if ($minimal_line_width !== null) {
            $queryParams['minimalLineWidth'] = ObjectSerializer::toQueryValue($minimal_line_width);
        }
        // query params
        if ($prevent_glyphs_grouping !== null) {
            $queryParams['preventGlyphsGrouping'] = ObjectSerializer::toQueryValue($prevent_glyphs_grouping);
        }
        // query params
        if ($split_css_into_pages !== null) {
            $queryParams['splitCssIntoPages'] = ObjectSerializer::toQueryValue($split_css_into_pages);
        }
        // query params
        if ($split_into_pages !== null) {
            $queryParams['splitIntoPages'] = ObjectSerializer::toQueryValue($split_into_pages);
        }
        // query params
        if ($use_z_order !== null) {
            $queryParams['useZOrder'] = ObjectSerializer::toQueryValue($use_z_order);
        }
        // query params
        if ($antialiasing_processing !== null) {
            $queryParams['antialiasingProcessing'] = ObjectSerializer::toQueryValue($antialiasing_processing);
        }
        // query params
        if ($css_class_names_prefix !== null) {
            $queryParams['cssClassNamesPrefix'] = ObjectSerializer::toQueryValue($css_class_names_prefix);
        }
        // query params
        if (is_array($explicit_list_of_saved_pages)) {
            $explicit_list_of_saved_pages = ObjectSerializer::serializeCollection($explicit_list_of_saved_pages, 'multi', true);
        }
        if ($explicit_list_of_saved_pages !== null) {
            $queryParams['explicitListOfSavedPages'] = ObjectSerializer::toQueryValue($explicit_list_of_saved_pages);
        }
        // query params
        if ($font_encoding_strategy !== null) {
            $queryParams['fontEncodingStrategy'] = ObjectSerializer::toQueryValue($font_encoding_strategy);
        }
        // query params
        if ($font_saving_mode !== null) {
            $queryParams['fontSavingMode'] = ObjectSerializer::toQueryValue($font_saving_mode);
        }
        // query params
        if ($html_markup_generation_mode !== null) {
            $queryParams['htmlMarkupGenerationMode'] = ObjectSerializer::toQueryValue($html_markup_generation_mode);
        }
        // query params
        if ($letters_positioning_method !== null) {
            $queryParams['lettersPositioningMethod'] = ObjectSerializer::toQueryValue($letters_positioning_method);
        }
        // query params
        if ($pages_flow_type_depends_on_viewers_screen_size !== null) {
            $queryParams['pagesFlowTypeDependsOnViewersScreenSize'] = ObjectSerializer::toQueryValue($pages_flow_type_depends_on_viewers_screen_size);
        }
        // query params
        if ($parts_embedding_mode !== null) {
            $queryParams['partsEmbeddingMode'] = ObjectSerializer::toQueryValue($parts_embedding_mode);
        }
        // query params
        if ($raster_images_saving_mode !== null) {
            $queryParams['rasterImagesSavingMode'] = ObjectSerializer::toQueryValue($raster_images_saving_mode);
        }
        // query params
        if ($remove_empty_areas_on_top_and_bottom !== null) {
            $queryParams['removeEmptyAreasOnTopAndBottom'] = ObjectSerializer::toQueryValue($remove_empty_areas_on_top_and_bottom);
        }
        // query params
        if ($save_shadowed_texts_as_transparent_texts !== null) {
            $queryParams['saveShadowedTextsAsTransparentTexts'] = ObjectSerializer::toQueryValue($save_shadowed_texts_as_transparent_texts);
        }
        // query params
        if ($save_transparent_texts !== null) {
            $queryParams['saveTransparentTexts'] = ObjectSerializer::toQueryValue($save_transparent_texts);
        }
        // query params
        if ($special_folder_for_all_images !== null) {
            $queryParams['specialFolderForAllImages'] = ObjectSerializer::toQueryValue($special_folder_for_all_images);
        }
        // query params
        if ($special_folder_for_svg_images !== null) {
            $queryParams['specialFolderForSvgImages'] = ObjectSerializer::toQueryValue($special_folder_for_svg_images);
        }
        // query params
        if ($try_save_text_underlining_and_strikeouting_in_css !== null) {
            $queryParams['trySaveTextUnderliningAndStrikeoutingInCss'] = ObjectSerializer::toQueryValue($try_save_text_underlining_and_strikeouting_in_css);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToLaTeX
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToLaTeX($name, $pages_count = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToLaTeXWithHttpInfo($name, $pages_count, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToLaTeXWithHttpInfo($name, $pages_count, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToLaTeXWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToLaTeXWithHttpInfo($name, $pages_count = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToLaTeXRequest($name, $pages_count, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToLaTeXAsync
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToLaTeXAsync($name, $pages_count = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToLaTeXAsyncWithHttpInfo($name, $pages_count, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToLaTeXAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToLaTeXAsyncWithHttpInfo($name, $pages_count = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToLaTeXRequest($name, $pages_count, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToLaTeX'
     *
     * @param  string $name The document name. (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToLaTeXRequest($name, $pages_count = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToLaTeX'
            );
        }

        $resourcePath = '/pdf/{name}/convert/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pages_count !== null) {
            $queryParams['pagesCount'] = ObjectSerializer::toQueryValue($pages_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToMobiXml
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToMobiXml($name, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToMobiXmlWithHttpInfo($name, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToMobiXmlWithHttpInfo($name, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToMobiXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToMobiXmlWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToMobiXmlRequest($name, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToMobiXmlAsync
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToMobiXmlAsync($name, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToMobiXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToMobiXmlRequest($name, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToMobiXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToMobiXmlRequest($name, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToMobiXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/mobixml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToPdfA
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToPdfA($name, $type, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToPdfAWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToPdfAWithHttpInfo($name, $type, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPdfARequest($name, $type, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToPdfAAsync
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPdfAAsync($name, $type, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToPdfAAsyncWithHttpInfo($name, $type, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPdfAAsyncWithHttpInfo($name, $type, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPdfARequest($name, $type, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToPdfA'
     *
     * @param  string $name The document name. (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToPdfARequest($name, $type, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getPdfInStorageToPdfA'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToPptx
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToPptx($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToPptxWithHttpInfo($name, $separate_images, $slides_as_images, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToPptxWithHttpInfo($name, $separate_images, $slides_as_images, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToPptxWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToPptxWithHttpInfo($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPptxRequest($name, $separate_images, $slides_as_images, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToPptxAsync
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPptxAsync($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToPptxAsyncWithHttpInfo($name, $separate_images, $slides_as_images, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToPptxAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToPptxAsyncWithHttpInfo($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToPptxRequest($name, $separate_images, $slides_as_images, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToPptx'
     *
     * @param  string $name The document name. (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToPptxRequest($name, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToPptx'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pptx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($separate_images !== null) {
            $queryParams['separateImages'] = ObjectSerializer::toQueryValue($separate_images);
        }
        // query params
        if ($slides_as_images !== null) {
            $queryParams['slidesAsImages'] = ObjectSerializer::toQueryValue($slides_as_images);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToSvg
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToSvg($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToSvgWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToSvgWithHttpInfo($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToSvgAsync
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToSvgAsync($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToSvgAsyncWithHttpInfo($name, $compress_output_to_zip_archive, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToSvgAsyncWithHttpInfo($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToSvg'
     *
     * @param  string $name The document name. (required)
     * @param  bool $compress_output_to_zip_archive Specifies whether output will be created as one zip-archive. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToSvgRequest($name, $compress_output_to_zip_archive = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToSvg'
            );
        }

        $resourcePath = '/pdf/{name}/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($compress_output_to_zip_archive !== null) {
            $queryParams['compressOutputToZipArchive'] = ObjectSerializer::toQueryValue($compress_output_to_zip_archive);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToTiff
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToTiff($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToTiffWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToTiffWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToTiffWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToTiffWithHttpInfo($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToTiffRequest($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToTiffAsync
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToTiffAsync($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToTiffAsyncWithHttpInfo($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToTiffAsyncWithHttpInfo($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToTiffRequest($name, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToTiffRequest($name, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXls
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXls($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToXlsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXlsWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXlsAsync
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsAsync($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToXlsAsyncWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsAsyncWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXls'
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXlsRequest($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXls'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXlsx
     *
     * Converts PDF document (located on storage) to XLSX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXlsx($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToXlsxWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToXlsxWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToXlsxWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLSX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXlsxWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsxRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXlsxAsync
     *
     * Converts PDF document (located on storage) to XLSX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsxAsync($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToXlsxAsyncWithHttpInfo($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXlsxAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLSX format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXlsxAsyncWithHttpInfo($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXlsxRequest($name, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXlsx'
     *
     * @param  string $name The document name. (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXlsxRequest($name, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXlsx'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xlsx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXml
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXml($name, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToXmlWithHttpInfo($name, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToXmlWithHttpInfo($name, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXmlWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXmlRequest($name, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXmlAsync
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXmlAsync($name, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToXmlAsyncWithHttpInfo($name, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXmlAsyncWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXmlRequest($name, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXmlRequest($name, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInStorageToXps
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPdfInStorageToXps($name, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getPdfInStorageToXpsWithHttpInfo($name, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPdfInStorageToXpsWithHttpInfo($name, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPdfInStorageToXpsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInStorageToXpsWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXpsRequest($name, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPdfInStorageToXpsAsync
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXpsAsync($name, $folder = null, $storage = null)
    {
        return $this->getPdfInStorageToXpsAsyncWithHttpInfo($name, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInStorageToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and returns resulting file in response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInStorageToXpsAsyncWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPdfInStorageToXpsRequest($name, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInStorageToXps'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPdfInStorageToXpsRequest($name, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPdfInStorageToXps'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPolyLineAnnotation
     *
     * Read document page polyline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolyLineAnnotationResponse
     */
    public function getPolyLineAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPolyLineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPolyLineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPolyLineAnnotationWithHttpInfo
     *
     * Read document page polyline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolyLineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPolyLineAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationResponse';
        $request = $this->getPolyLineAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolyLineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPolyLineAnnotationAsync
     *
     * Read document page polyline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPolyLineAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getPolyLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPolyLineAnnotationAsyncWithHttpInfo
     *
     * Read document page polyline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPolyLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationResponse';
        $request = $this->getPolyLineAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPolyLineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPolyLineAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPolyLineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getPolyLineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polyline/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPolygonAnnotation
     *
     * Read document page polygon annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolygonAnnotationResponse
     */
    public function getPolygonAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPolygonAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPolygonAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPolygonAnnotationWithHttpInfo
     *
     * Read document page polygon annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolygonAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPolygonAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationResponse';
        $request = $this->getPolygonAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolygonAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPolygonAnnotationAsync
     *
     * Read document page polygon annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPolygonAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getPolygonAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPolygonAnnotationAsyncWithHttpInfo
     *
     * Read document page polygon annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPolygonAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationResponse';
        $request = $this->getPolygonAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPolygonAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPolygonAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPolygonAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getPolygonAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polygon/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPopupAnnotation
     *
     * Read document page popup annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationResponse
     */
    public function getPopupAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getPopupAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPopupAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPopupAnnotationWithHttpInfo
     *
     * Read document page popup annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPopupAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationResponse';
        $request = $this->getPopupAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPopupAnnotationAsync
     *
     * Read document page popup annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPopupAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPopupAnnotationAsyncWithHttpInfo
     *
     * Read document page popup annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationResponse';
        $request = $this->getPopupAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPopupAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPopupAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getPopupAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/popup/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPsInStorageToPdf
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getPsInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getPsInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getPsInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getPsInStorageToPdfWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPsInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPsInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPsInStorageToPdfAsync
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPsInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getPsInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPsInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getPsInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPsInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPsInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getPsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/ps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRedactionAnnotation
     *
     * Read document page redaction annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\RedactionAnnotationResponse
     */
    public function getRedactionAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getRedactionAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getRedactionAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getRedactionAnnotationWithHttpInfo
     *
     * Read document page redaction annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\RedactionAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRedactionAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\RedactionAnnotationResponse';
        $request = $this->getRedactionAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\RedactionAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRedactionAnnotationAsync
     *
     * Read document page redaction annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRedactionAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getRedactionAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRedactionAnnotationAsyncWithHttpInfo
     *
     * Read document page redaction annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRedactionAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\RedactionAnnotationResponse';
        $request = $this->getRedactionAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRedactionAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRedactionAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getRedactionAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getRedactionAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/redaction/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getScreenAnnotation
     *
     * Read document page screen annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ScreenAnnotationResponse
     */
    public function getScreenAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getScreenAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getScreenAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getScreenAnnotationWithHttpInfo
     *
     * Read document page screen annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ScreenAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getScreenAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ScreenAnnotationResponse';
        $request = $this->getScreenAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ScreenAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getScreenAnnotationAsync
     *
     * Read document page screen annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getScreenAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getScreenAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getScreenAnnotationAsyncWithHttpInfo
     *
     * Read document page screen annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getScreenAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ScreenAnnotationResponse';
        $request = $this->getScreenAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getScreenAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getScreenAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getScreenAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getScreenAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/screen/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getScreenAnnotationData
     *
     * Read document page screen annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getScreenAnnotationData($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getScreenAnnotationDataWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getScreenAnnotationDataWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getScreenAnnotationDataWithHttpInfo
     *
     * Read document page screen annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getScreenAnnotationDataWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getScreenAnnotationDataRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getScreenAnnotationDataAsync
     *
     * Read document page screen annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getScreenAnnotationDataAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getScreenAnnotationDataAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getScreenAnnotationDataAsyncWithHttpInfo
     *
     * Read document page screen annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getScreenAnnotationDataAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getScreenAnnotationDataRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getScreenAnnotationData'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getScreenAnnotationDataRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getScreenAnnotationData'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getScreenAnnotationData'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/screen/{annotationId}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSoundAnnotation
     *
     * Read document page sound annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SoundAnnotationResponse
     */
    public function getSoundAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getSoundAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getSoundAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getSoundAnnotationWithHttpInfo
     *
     * Read document page sound annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SoundAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSoundAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SoundAnnotationResponse';
        $request = $this->getSoundAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SoundAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSoundAnnotationAsync
     *
     * Read document page sound annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSoundAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getSoundAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSoundAnnotationAsyncWithHttpInfo
     *
     * Read document page sound annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSoundAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SoundAnnotationResponse';
        $request = $this->getSoundAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSoundAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSoundAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSoundAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getSoundAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/sound/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSoundAnnotationData
     *
     * Read document page sound annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getSoundAnnotationData($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getSoundAnnotationDataWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getSoundAnnotationDataWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getSoundAnnotationDataWithHttpInfo
     *
     * Read document page sound annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSoundAnnotationDataWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getSoundAnnotationDataRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSoundAnnotationDataAsync
     *
     * Read document page sound annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSoundAnnotationDataAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getSoundAnnotationDataAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSoundAnnotationDataAsyncWithHttpInfo
     *
     * Read document page sound annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSoundAnnotationDataAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getSoundAnnotationDataRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSoundAnnotationData'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSoundAnnotationDataRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSoundAnnotationData'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getSoundAnnotationData'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/sound/{annotationId}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSquareAnnotation
     *
     * Read document page square annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquareAnnotationResponse
     */
    public function getSquareAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getSquareAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getSquareAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getSquareAnnotationWithHttpInfo
     *
     * Read document page square annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquareAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSquareAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationResponse';
        $request = $this->getSquareAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquareAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSquareAnnotationAsync
     *
     * Read document page square annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSquareAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getSquareAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSquareAnnotationAsyncWithHttpInfo
     *
     * Read document page square annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSquareAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationResponse';
        $request = $this->getSquareAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSquareAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSquareAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSquareAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getSquareAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/square/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSquigglyAnnotation
     *
     * Read document page squiggly annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquigglyAnnotationResponse
     */
    public function getSquigglyAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getSquigglyAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getSquigglyAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getSquigglyAnnotationWithHttpInfo
     *
     * Read document page squiggly annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquigglyAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSquigglyAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationResponse';
        $request = $this->getSquigglyAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquigglyAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSquigglyAnnotationAsync
     *
     * Read document page squiggly annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSquigglyAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getSquigglyAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSquigglyAnnotationAsyncWithHttpInfo
     *
     * Read document page squiggly annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSquigglyAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationResponse';
        $request = $this->getSquigglyAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSquigglyAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSquigglyAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getSquigglyAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getSquigglyAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/squiggly/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStampAnnotation
     *
     * Read document page stamp annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StampAnnotationResponse
     */
    public function getStampAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getStampAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getStampAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getStampAnnotationWithHttpInfo
     *
     * Read document page stamp annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StampAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStampAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampAnnotationResponse';
        $request = $this->getStampAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StampAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStampAnnotationAsync
     *
     * Read document page stamp annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStampAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getStampAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStampAnnotationAsyncWithHttpInfo
     *
     * Read document page stamp annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStampAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampAnnotationResponse';
        $request = $this->getStampAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStampAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStampAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getStampAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getStampAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/stamp/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStampAnnotationData
     *
     * Read document page stamp annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getStampAnnotationData($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getStampAnnotationDataWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getStampAnnotationDataWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getStampAnnotationDataWithHttpInfo
     *
     * Read document page stamp annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStampAnnotationDataWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getStampAnnotationDataRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStampAnnotationDataAsync
     *
     * Read document page stamp annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStampAnnotationDataAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getStampAnnotationDataAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStampAnnotationDataAsyncWithHttpInfo
     *
     * Read document page stamp annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStampAnnotationDataAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getStampAnnotationDataRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStampAnnotationData'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStampAnnotationDataRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getStampAnnotationData'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getStampAnnotationData'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/stamp/{annotationId}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStrikeOutAnnotation
     *
     * Read document page StrikeOut annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StrikeOutAnnotationResponse
     */
    public function getStrikeOutAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getStrikeOutAnnotationWithHttpInfo
     *
     * Read document page StrikeOut annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StrikeOutAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationResponse';
        $request = $this->getStrikeOutAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StrikeOutAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStrikeOutAnnotationAsync
     *
     * Read document page StrikeOut annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStrikeOutAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getStrikeOutAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStrikeOutAnnotationAsyncWithHttpInfo
     *
     * Read document page StrikeOut annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStrikeOutAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationResponse';
        $request = $this->getStrikeOutAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStrikeOutAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStrikeOutAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getStrikeOutAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getStrikeOutAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/strikeout/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSvgInStorageToPdf
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getSvgInStorageToPdf($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        try
        {
            list($response) = $this->getSvgInStorageToPdfWithHttpInfo($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getSvgInStorageToPdfWithHttpInfo($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getSvgInStorageToPdfWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSvgInStorageToPdfWithHttpInfo($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getSvgInStorageToPdfRequest($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSvgInStorageToPdfAsync
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSvgInStorageToPdfAsync($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        return $this->getSvgInStorageToPdfAsyncWithHttpInfo($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSvgInStorageToPdfAsyncWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSvgInStorageToPdfAsyncWithHttpInfo($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getSvgInStorageToPdfRequest($src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSvgInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSvgInStorageToPdfRequest($src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getSvgInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($adjust_page_size !== null) {
            $queryParams['adjustPageSize'] = ObjectSerializer::toQueryValue($adjust_page_size);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTable
     *
     * Read document page table by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TableRecognizedResponse
     */
    public function getTable($name, $table_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getTableWithHttpInfo($name, $table_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getTableWithHttpInfo($name, $table_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getTableWithHttpInfo
     *
     * Read document page table by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TableRecognizedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTableWithHttpInfo($name, $table_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TableRecognizedResponse';
        $request = $this->getTableRequest($name, $table_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TableRecognizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTableAsync
     *
     * Read document page table by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableAsync($name, $table_id, $storage = null, $folder = null)
    {
        return $this->getTableAsyncWithHttpInfo($name, $table_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTableAsyncWithHttpInfo
     *
     * Read document page table by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableAsyncWithHttpInfo($name, $table_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TableRecognizedResponse';
        $request = $this->getTableRequest($name, $table_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTable'
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTableRequest($name, $table_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getTable'
            );
        }
        // verify the required parameter 'table_id' is set
        if ($table_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table_id when calling getTable'
            );
        }

        $resourcePath = '/pdf/{name}/tables/{tableId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($table_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($table_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getText
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextRectsResponse
     */
    public function getText($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getTextWithHttpInfo($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getTextWithHttpInfo($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getTextWithHttpInfo
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextRectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTextWithHttpInfo($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getTextRequest($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextRectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTextAsync
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAsync($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        return $this->getTextAsyncWithHttpInfo($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTextAsyncWithHttpInfo
     *
     * Read document text.
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAsyncWithHttpInfo($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\TextRectsResponse';
        $request = $this->getTextRequest($name, $llx, $lly, $urx, $ury, $format, $regex, $split_rects, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getText'
     *
     * @param  string $name The document name. (required)
     * @param  double $llx X-coordinate of lower - left corner. (required)
     * @param  double $lly Y - coordinate of lower-left corner. (required)
     * @param  double $urx X - coordinate of upper-right corner. (required)
     * @param  double $ury Y - coordinate of upper-right corner. (required)
     * @param  string[] $format List of formats for search. (optional)
     * @param  string $regex Formats are specified as a regular expression. (optional)
     * @param  bool $split_rects Split result fragments (default is true). (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTextRequest($name, $llx, $lly, $urx, $ury, $format = null, $regex = null, $split_rects = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getText'
            );
        }
        // verify the required parameter 'llx' is set
        if ($llx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $llx when calling getText'
            );
        }
        // verify the required parameter 'lly' is set
        if ($lly === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lly when calling getText'
            );
        }
        // verify the required parameter 'urx' is set
        if ($urx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $urx when calling getText'
            );
        }
        // verify the required parameter 'ury' is set
        if ($ury === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ury when calling getText'
            );
        }

        $resourcePath = '/pdf/{name}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($format)) {
            $format = ObjectSerializer::serializeCollection($format, 'multi', true);
        }
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($regex !== null) {
            $queryParams['regex'] = ObjectSerializer::toQueryValue($regex);
        }
        // query params
        if ($split_rects !== null) {
            $queryParams['splitRects'] = ObjectSerializer::toQueryValue($split_rects);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($llx !== null) {
            $queryParams['LLX'] = ObjectSerializer::toQueryValue($llx);
        }
        // query params
        if ($lly !== null) {
            $queryParams['LLY'] = ObjectSerializer::toQueryValue($lly);
        }
        // query params
        if ($urx !== null) {
            $queryParams['URX'] = ObjectSerializer::toQueryValue($urx);
        }
        // query params
        if ($ury !== null) {
            $queryParams['URY'] = ObjectSerializer::toQueryValue($ury);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTextAnnotation
     *
     * Read document page text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextAnnotationResponse
     */
    public function getTextAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getTextAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getTextAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getTextAnnotationWithHttpInfo
     *
     * Read document page text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTextAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationResponse';
        $request = $this->getTextAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTextAnnotationAsync
     *
     * Read document page text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTextAnnotationAsyncWithHttpInfo
     *
     * Read document page text annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationResponse';
        $request = $this->getTextAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTextAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTextAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getTextAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getTextAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/text/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUnderlineAnnotation
     *
     * Read document page underline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\UnderlineAnnotationResponse
     */
    public function getUnderlineAnnotation($name, $annotation_id, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getUnderlineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getUnderlineAnnotationWithHttpInfo($name, $annotation_id, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getUnderlineAnnotationWithHttpInfo
     *
     * Read document page underline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\UnderlineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUnderlineAnnotationWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationResponse';
        $request = $this->getUnderlineAnnotationRequest($name, $annotation_id, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\UnderlineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUnderlineAnnotationAsync
     *
     * Read document page underline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnderlineAnnotationAsync($name, $annotation_id, $storage = null, $folder = null)
    {
        return $this->getUnderlineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUnderlineAnnotationAsyncWithHttpInfo
     *
     * Read document page underline annotation by ID.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnderlineAnnotationAsyncWithHttpInfo($name, $annotation_id, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationResponse';
        $request = $this->getUnderlineAnnotationRequest($name, $annotation_id, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUnderlineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUnderlineAnnotationRequest($name, $annotation_id, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getUnderlineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling getUnderlineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/underline/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVerifySignature
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SignatureVerifyResponse
     */
    public function getVerifySignature($name, $sign_name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getVerifySignatureWithHttpInfo($name, $sign_name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getVerifySignatureWithHttpInfo($name, $sign_name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getVerifySignatureWithHttpInfo
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SignatureVerifyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVerifySignatureWithHttpInfo($name, $sign_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SignatureVerifyResponse';
        $request = $this->getVerifySignatureRequest($name, $sign_name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SignatureVerifyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVerifySignatureAsync
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVerifySignatureAsync($name, $sign_name, $storage = null, $folder = null)
    {
        return $this->getVerifySignatureAsyncWithHttpInfo($name, $sign_name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVerifySignatureAsyncWithHttpInfo
     *
     * Verify signature document.
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVerifySignatureAsyncWithHttpInfo($name, $sign_name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SignatureVerifyResponse';
        $request = $this->getVerifySignatureRequest($name, $sign_name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVerifySignature'
     *
     * @param  string $name The document name. (required)
     * @param  string $sign_name Sign name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVerifySignatureRequest($name, $sign_name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getVerifySignature'
            );
        }
        // verify the required parameter 'sign_name' is set
        if ($sign_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sign_name when calling getVerifySignature'
            );
        }

        $resourcePath = '/pdf/{name}/verifySignature';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sign_name !== null) {
            $queryParams['signName'] = ObjectSerializer::toQueryValue($sign_name);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebInStorageToPdf
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getWebInStorageToPdf($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        try
        {
            list($response) = $this->getWebInStorageToPdfWithHttpInfo($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getWebInStorageToPdfWithHttpInfo($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getWebInStorageToPdfWithHttpInfo
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebInStorageToPdfWithHttpInfo($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getWebInStorageToPdfRequest($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebInStorageToPdfAsync
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebInStorageToPdfAsync($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        return $this->getWebInStorageToPdfAsyncWithHttpInfo($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebInStorageToPdfAsyncWithHttpInfo
     *
     * Convert web page to PDF format and return resulting file in response.
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebInStorageToPdfAsyncWithHttpInfo($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getWebInStorageToPdfRequest($url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebInStorageToPdf'
     *
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWebInStorageToPdfRequest($url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $storage = null)
    {
        // verify the required parameter 'url' is set
        if ($url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling getWebInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/web';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWordsPerPage
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\WordCountResponse
     */
    public function getWordsPerPage($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->getWordsPerPageWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getWordsPerPageWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getWordsPerPageWithHttpInfo
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\WordCountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWordsPerPageWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\WordCountResponse';
        $request = $this->getWordsPerPageRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\WordCountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWordsPerPageAsync
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWordsPerPageAsync($name, $storage = null, $folder = null)
    {
        return $this->getWordsPerPageAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWordsPerPageAsyncWithHttpInfo
     *
     * Get number of words per document page.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWordsPerPageAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\WordCountResponse';
        $request = $this->getWordsPerPageRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWordsPerPage'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWordsPerPageRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getWordsPerPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/wordCount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXfaPdfInStorageToAcroForm
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXfaPdfInStorageToAcroForm($name, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->getXfaPdfInStorageToAcroFormWithHttpInfo($name, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getXfaPdfInStorageToAcroFormWithHttpInfo($name, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getXfaPdfInStorageToAcroFormWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXfaPdfInStorageToAcroFormWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXfaPdfInStorageToAcroFormRequest($name, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXfaPdfInStorageToAcroFormAsync
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXfaPdfInStorageToAcroFormAsync($name, $folder = null, $storage = null)
    {
        return $this->getXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXfaPdfInStorageToAcroFormAsyncWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and returns resulting file response content
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $folder = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXfaPdfInStorageToAcroFormRequest($name, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXfaPdfInStorageToAcroForm'
     *
     * @param  string $name The document name. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXfaPdfInStorageToAcroFormRequest($name, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getXfaPdfInStorageToAcroForm'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xfatoacroform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXmlInStorageToPdf
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXmlInStorageToPdf($src_path, $xsl_file_path = null, $storage = null)
    {
        try
        {
            list($response) = $this->getXmlInStorageToPdfWithHttpInfo($src_path, $xsl_file_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getXmlInStorageToPdfWithHttpInfo($src_path, $xsl_file_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getXmlInStorageToPdfWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXmlInStorageToPdfWithHttpInfo($src_path, $xsl_file_path = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXmlInStorageToPdfRequest($src_path, $xsl_file_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXmlInStorageToPdfAsync
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXmlInStorageToPdfAsync($src_path, $xsl_file_path = null, $storage = null)
    {
        return $this->getXmlInStorageToPdfAsyncWithHttpInfo($src_path, $xsl_file_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXmlInStorageToPdfAsyncWithHttpInfo($src_path, $xsl_file_path = null, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXmlInStorageToPdfRequest($src_path, $xsl_file_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXmlInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXmlInStorageToPdfRequest($src_path, $xsl_file_path = null, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getXmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($xsl_file_path !== null) {
            $queryParams['xslFilePath'] = ObjectSerializer::toQueryValue($xsl_file_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXpsInStorageToPdf
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXpsInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getXpsInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getXpsInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getXpsInStorageToPdfWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXpsInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXpsInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXpsInStorageToPdfAsync
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXpsInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getXpsInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXpsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXpsInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXpsInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXpsInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXpsInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getXpsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getXslFoInStorageToPdf
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getXslFoInStorageToPdf($src_path, $storage = null)
    {
        try
        {
            list($response) = $this->getXslFoInStorageToPdfWithHttpInfo($src_path, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->getXslFoInStorageToPdfWithHttpInfo($src_path, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation getXslFoInStorageToPdfWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getXslFoInStorageToPdfWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXslFoInStorageToPdfRequest($src_path, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getXslFoInStorageToPdfAsync
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXslFoInStorageToPdfAsync($src_path, $storage = null)
    {
        return $this->getXslFoInStorageToPdfAsyncWithHttpInfo($src_path, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getXslFoInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and return resulting file in response.
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getXslFoInStorageToPdfAsyncWithHttpInfo($src_path, $storage = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->getXslFoInStorageToPdfRequest($src_path, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getXslFoInStorageToPdf'
     *
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xslfo) (required)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getXslFoInStorageToPdfRequest($src_path, $storage = null)
    {
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling getXslFoInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/create/xslfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['multipart/form-data'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAppendDocument
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function postAppendDocument($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postAppendDocumentWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postAppendDocumentWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postAppendDocumentWithHttpInfo
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postAppendDocumentWithHttpInfo($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->postAppendDocumentRequest($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAppendDocumentAsync
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAppendDocumentAsync($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        return $this->postAppendDocumentAsyncWithHttpInfo($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAppendDocumentAsyncWithHttpInfo
     *
     * Append document to existing one.
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAppendDocumentAsyncWithHttpInfo($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->postAppendDocumentRequest($name, $append_document, $append_file, $start_page, $end_page, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAppendDocument'
     *
     * @param  string $name The original document name. (required)
     * @param  \Aspose\PDF\Model\AppendDocument $append_document with the append document data. (optional)
     * @param  string $append_file Append file server path. (optional)
     * @param  int $start_page Appending start page. (optional, default to 0)
     * @param  int $end_page Appending end page. (optional, default to 0)
     * @param  string $storage The documents storage. (optional)
     * @param  string $folder The original document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAppendDocumentRequest($name, $append_document = null, $append_file = null, $start_page = '0', $end_page = '0', $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postAppendDocument'
            );
        }

        $resourcePath = '/pdf/{name}/appendDocument';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($append_file !== null) {
            $queryParams['appendFile'] = ObjectSerializer::toQueryValue($append_file);
        }
        // query params
        if ($start_page !== null) {
            $queryParams['startPage'] = ObjectSerializer::toQueryValue($start_page);
        }
        // query params
        if ($end_page !== null) {
            $queryParams['endPage'] = ObjectSerializer::toQueryValue($end_page);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($append_document)) {
            $_tempBody = $append_document;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postChangePasswordDocumentInStorage
     *
     * Change document password in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postChangePasswordDocumentInStorage($name, $owner_password, $new_user_password, $new_owner_password, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postChangePasswordDocumentInStorageWithHttpInfo($name, $owner_password, $new_user_password, $new_owner_password, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postChangePasswordDocumentInStorageWithHttpInfo($name, $owner_password, $new_user_password, $new_owner_password, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postChangePasswordDocumentInStorageWithHttpInfo
     *
     * Change document password in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postChangePasswordDocumentInStorageWithHttpInfo($name, $owner_password, $new_user_password, $new_owner_password, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postChangePasswordDocumentInStorageRequest($name, $owner_password, $new_user_password, $new_owner_password, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postChangePasswordDocumentInStorageAsync
     *
     * Change document password in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postChangePasswordDocumentInStorageAsync($name, $owner_password, $new_user_password, $new_owner_password, $storage = null, $folder = null)
    {
        return $this->postChangePasswordDocumentInStorageAsyncWithHttpInfo($name, $owner_password, $new_user_password, $new_owner_password, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postChangePasswordDocumentInStorageAsyncWithHttpInfo
     *
     * Change document password in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postChangePasswordDocumentInStorageAsyncWithHttpInfo($name, $owner_password, $new_user_password, $new_owner_password, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postChangePasswordDocumentInStorageRequest($name, $owner_password, $new_user_password, $new_owner_password, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postChangePasswordDocumentInStorage'
     *
     * @param  string $name Document name. (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postChangePasswordDocumentInStorageRequest($name, $owner_password, $new_user_password, $new_owner_password, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postChangePasswordDocumentInStorage'
            );
        }
        // verify the required parameter 'owner_password' is set
        if ($owner_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_password when calling postChangePasswordDocumentInStorage'
            );
        }
        // verify the required parameter 'new_user_password' is set
        if ($new_user_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_user_password when calling postChangePasswordDocumentInStorage'
            );
        }
        // verify the required parameter 'new_owner_password' is set
        if ($new_owner_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_owner_password when calling postChangePasswordDocumentInStorage'
            );
        }

        $resourcePath = '/pdf/{name}/changepassword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($owner_password !== null) {
            $queryParams['ownerPassword'] = ObjectSerializer::toQueryValue($owner_password);
        }
        // query params
        if ($new_user_password !== null) {
            $queryParams['newUserPassword'] = ObjectSerializer::toQueryValue($new_user_password);
        }
        // query params
        if ($new_owner_password !== null) {
            $queryParams['newOwnerPassword'] = ObjectSerializer::toQueryValue($new_owner_password);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCreateField
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postCreateField($name, $page, $field = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postCreateFieldWithHttpInfo($name, $page, $field, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postCreateFieldWithHttpInfo($name, $page, $field, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postCreateFieldWithHttpInfo
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCreateFieldWithHttpInfo($name, $page, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postCreateFieldRequest($name, $page, $field, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCreateFieldAsync
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCreateFieldAsync($name, $page, $field = null, $storage = null, $folder = null)
    {
        return $this->postCreateFieldAsyncWithHttpInfo($name, $page, $field, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCreateFieldAsyncWithHttpInfo
     *
     * Create field.
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCreateFieldAsyncWithHttpInfo($name, $page, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postCreateFieldRequest($name, $page, $field, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCreateField'
     *
     * @param  string $name The document name. (required)
     * @param  int $page Document page number. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postCreateFieldRequest($name, $page, $field = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postCreateField'
            );
        }
        // verify the required parameter 'page' is set
        if ($page === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling postCreateField'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($field)) {
            $_tempBody = $field;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDecryptDocumentInStorage
     *
     * Decrypt document in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postDecryptDocumentInStorage($name, $password, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postDecryptDocumentInStorageWithHttpInfo($name, $password, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postDecryptDocumentInStorageWithHttpInfo($name, $password, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postDecryptDocumentInStorageWithHttpInfo
     *
     * Decrypt document in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDecryptDocumentInStorageWithHttpInfo($name, $password, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDecryptDocumentInStorageRequest($name, $password, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDecryptDocumentInStorageAsync
     *
     * Decrypt document in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDecryptDocumentInStorageAsync($name, $password, $storage = null, $folder = null)
    {
        return $this->postDecryptDocumentInStorageAsyncWithHttpInfo($name, $password, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDecryptDocumentInStorageAsyncWithHttpInfo
     *
     * Decrypt document in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDecryptDocumentInStorageAsyncWithHttpInfo($name, $password, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDecryptDocumentInStorageRequest($name, $password, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDecryptDocumentInStorage'
     *
     * @param  string $name Document name. (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDecryptDocumentInStorageRequest($name, $password, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDecryptDocumentInStorage'
            );
        }
        // verify the required parameter 'password' is set
        if ($password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling postDecryptDocumentInStorage'
            );
        }

        $resourcePath = '/pdf/{name}/decrypt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($password !== null) {
            $queryParams['password'] = ObjectSerializer::toQueryValue($password);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentImageFooter
     *
     * Add document image footer.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageFooter $image_footer The image footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postDocumentImageFooter($name, $image_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postDocumentImageFooterWithHttpInfo($name, $image_footer, $start_page_number, $end_page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postDocumentImageFooterWithHttpInfo($name, $image_footer, $start_page_number, $end_page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postDocumentImageFooterWithHttpInfo
     *
     * Add document image footer.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageFooter $image_footer The image footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentImageFooterWithHttpInfo($name, $image_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentImageFooterRequest($name, $image_footer, $start_page_number, $end_page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentImageFooterAsync
     *
     * Add document image footer.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageFooter $image_footer The image footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentImageFooterAsync($name, $image_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        return $this->postDocumentImageFooterAsyncWithHttpInfo($name, $image_footer, $start_page_number, $end_page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentImageFooterAsyncWithHttpInfo
     *
     * Add document image footer.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageFooter $image_footer The image footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentImageFooterAsyncWithHttpInfo($name, $image_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentImageFooterRequest($name, $image_footer, $start_page_number, $end_page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentImageFooter'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageFooter $image_footer The image footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentImageFooterRequest($name, $image_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentImageFooter'
            );
        }
        // verify the required parameter 'image_footer' is set
        if ($image_footer === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_footer when calling postDocumentImageFooter'
            );
        }

        $resourcePath = '/pdf/{name}/footer/image';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_page_number !== null) {
            $queryParams['startPageNumber'] = ObjectSerializer::toQueryValue($start_page_number);
        }
        // query params
        if ($end_page_number !== null) {
            $queryParams['endPageNumber'] = ObjectSerializer::toQueryValue($end_page_number);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($image_footer)) {
            $_tempBody = $image_footer;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentImageHeader
     *
     * Add document image header.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageHeader $image_header The image header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postDocumentImageHeader($name, $image_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postDocumentImageHeaderWithHttpInfo($name, $image_header, $start_page_number, $end_page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postDocumentImageHeaderWithHttpInfo($name, $image_header, $start_page_number, $end_page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postDocumentImageHeaderWithHttpInfo
     *
     * Add document image header.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageHeader $image_header The image header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentImageHeaderWithHttpInfo($name, $image_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentImageHeaderRequest($name, $image_header, $start_page_number, $end_page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentImageHeaderAsync
     *
     * Add document image header.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageHeader $image_header The image header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentImageHeaderAsync($name, $image_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        return $this->postDocumentImageHeaderAsyncWithHttpInfo($name, $image_header, $start_page_number, $end_page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentImageHeaderAsyncWithHttpInfo
     *
     * Add document image header.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageHeader $image_header The image header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentImageHeaderAsyncWithHttpInfo($name, $image_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentImageHeaderRequest($name, $image_header, $start_page_number, $end_page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentImageHeader'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageHeader $image_header The image header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentImageHeaderRequest($name, $image_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentImageHeader'
            );
        }
        // verify the required parameter 'image_header' is set
        if ($image_header === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_header when calling postDocumentImageHeader'
            );
        }

        $resourcePath = '/pdf/{name}/header/image';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_page_number !== null) {
            $queryParams['startPageNumber'] = ObjectSerializer::toQueryValue($start_page_number);
        }
        // query params
        if ($end_page_number !== null) {
            $queryParams['endPageNumber'] = ObjectSerializer::toQueryValue($end_page_number);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($image_header)) {
            $_tempBody = $image_header;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentPageNumberStamps
     *
     * Add document page number stamps.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\PageNumberStamp $stamp The stamp. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postDocumentPageNumberStamps($name, $stamp, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postDocumentPageNumberStampsWithHttpInfo($name, $stamp, $start_page_number, $end_page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postDocumentPageNumberStampsWithHttpInfo($name, $stamp, $start_page_number, $end_page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postDocumentPageNumberStampsWithHttpInfo
     *
     * Add document page number stamps.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\PageNumberStamp $stamp The stamp. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentPageNumberStampsWithHttpInfo($name, $stamp, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentPageNumberStampsRequest($name, $stamp, $start_page_number, $end_page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentPageNumberStampsAsync
     *
     * Add document page number stamps.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\PageNumberStamp $stamp The stamp. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentPageNumberStampsAsync($name, $stamp, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        return $this->postDocumentPageNumberStampsAsyncWithHttpInfo($name, $stamp, $start_page_number, $end_page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentPageNumberStampsAsyncWithHttpInfo
     *
     * Add document page number stamps.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\PageNumberStamp $stamp The stamp. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentPageNumberStampsAsyncWithHttpInfo($name, $stamp, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentPageNumberStampsRequest($name, $stamp, $start_page_number, $end_page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentPageNumberStamps'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\PageNumberStamp $stamp The stamp. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentPageNumberStampsRequest($name, $stamp, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentPageNumberStamps'
            );
        }
        // verify the required parameter 'stamp' is set
        if ($stamp === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamp when calling postDocumentPageNumberStamps'
            );
        }

        $resourcePath = '/pdf/{name}/stamps/pagenumber';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_page_number !== null) {
            $queryParams['startPageNumber'] = ObjectSerializer::toQueryValue($start_page_number);
        }
        // query params
        if ($end_page_number !== null) {
            $queryParams['endPageNumber'] = ObjectSerializer::toQueryValue($end_page_number);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($stamp)) {
            $_tempBody = $stamp;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentTextFooter
     *
     * Add document text footer.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextFooter $text_footer The text footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postDocumentTextFooter($name, $text_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postDocumentTextFooterWithHttpInfo($name, $text_footer, $start_page_number, $end_page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postDocumentTextFooterWithHttpInfo($name, $text_footer, $start_page_number, $end_page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postDocumentTextFooterWithHttpInfo
     *
     * Add document text footer.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextFooter $text_footer The text footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentTextFooterWithHttpInfo($name, $text_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentTextFooterRequest($name, $text_footer, $start_page_number, $end_page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentTextFooterAsync
     *
     * Add document text footer.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextFooter $text_footer The text footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextFooterAsync($name, $text_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        return $this->postDocumentTextFooterAsyncWithHttpInfo($name, $text_footer, $start_page_number, $end_page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentTextFooterAsyncWithHttpInfo
     *
     * Add document text footer.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextFooter $text_footer The text footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextFooterAsyncWithHttpInfo($name, $text_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentTextFooterRequest($name, $text_footer, $start_page_number, $end_page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentTextFooter'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextFooter $text_footer The text footer. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentTextFooterRequest($name, $text_footer, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentTextFooter'
            );
        }
        // verify the required parameter 'text_footer' is set
        if ($text_footer === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_footer when calling postDocumentTextFooter'
            );
        }

        $resourcePath = '/pdf/{name}/footer/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_page_number !== null) {
            $queryParams['startPageNumber'] = ObjectSerializer::toQueryValue($start_page_number);
        }
        // query params
        if ($end_page_number !== null) {
            $queryParams['endPageNumber'] = ObjectSerializer::toQueryValue($end_page_number);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_footer)) {
            $_tempBody = $text_footer;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentTextHeader
     *
     * Add document text header.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextHeader $text_header The text header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postDocumentTextHeader($name, $text_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postDocumentTextHeaderWithHttpInfo($name, $text_header, $start_page_number, $end_page_number, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postDocumentTextHeaderWithHttpInfo($name, $text_header, $start_page_number, $end_page_number, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postDocumentTextHeaderWithHttpInfo
     *
     * Add document text header.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextHeader $text_header The text header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentTextHeaderWithHttpInfo($name, $text_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentTextHeaderRequest($name, $text_header, $start_page_number, $end_page_number, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentTextHeaderAsync
     *
     * Add document text header.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextHeader $text_header The text header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextHeaderAsync($name, $text_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        return $this->postDocumentTextHeaderAsyncWithHttpInfo($name, $text_header, $start_page_number, $end_page_number, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentTextHeaderAsyncWithHttpInfo
     *
     * Add document text header.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextHeader $text_header The text header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextHeaderAsyncWithHttpInfo($name, $text_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postDocumentTextHeaderRequest($name, $text_header, $start_page_number, $end_page_number, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentTextHeader'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\TextHeader $text_header The text header. (required)
     * @param  int $start_page_number The start page number. (optional)
     * @param  int $end_page_number The end page number. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentTextHeaderRequest($name, $text_header, $start_page_number = null, $end_page_number = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentTextHeader'
            );
        }
        // verify the required parameter 'text_header' is set
        if ($text_header === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_header when calling postDocumentTextHeader'
            );
        }

        $resourcePath = '/pdf/{name}/header/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_page_number !== null) {
            $queryParams['startPageNumber'] = ObjectSerializer::toQueryValue($start_page_number);
        }
        // query params
        if ($end_page_number !== null) {
            $queryParams['endPageNumber'] = ObjectSerializer::toQueryValue($end_page_number);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_header)) {
            $_tempBody = $text_header;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postDocumentTextReplace
     *
     * Document's replace text method.
     *
     * @param  string $name name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace text_replace (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextReplaceResponse
     */
    public function postDocumentTextReplace($name, $text_replace, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postDocumentTextReplaceWithHttpInfo
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postDocumentTextReplaceWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postDocumentTextReplaceRequest($name, $text_replace, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postDocumentTextReplaceAsync
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextReplaceAsync($name, $text_replace, $storage = null, $folder = null)
    {
        return $this->postDocumentTextReplaceAsyncWithHttpInfo($name, $text_replace, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postDocumentTextReplaceAsyncWithHttpInfo
     *
     * Document's replace text method.
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postDocumentTextReplaceAsyncWithHttpInfo($name, $text_replace, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postDocumentTextReplaceRequest($name, $text_replace, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postDocumentTextReplace'
     *
     * @param  string $name (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postDocumentTextReplaceRequest($name, $text_replace, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postDocumentTextReplace'
            );
        }
        // verify the required parameter 'text_replace' is set
        if ($text_replace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace when calling postDocumentTextReplace'
            );
        }

        $resourcePath = '/pdf/{name}/text/replace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace)) {
            $_tempBody = $text_replace;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postEncryptDocumentInStorage
     *
     * Encrypt document in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postEncryptDocumentInStorage($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postEncryptDocumentInStorageWithHttpInfo($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postEncryptDocumentInStorageWithHttpInfo($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postEncryptDocumentInStorageWithHttpInfo
     *
     * Encrypt document in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postEncryptDocumentInStorageWithHttpInfo($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postEncryptDocumentInStorageRequest($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postEncryptDocumentInStorageAsync
     *
     * Encrypt document in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postEncryptDocumentInStorageAsync($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $folder = null)
    {
        return $this->postEncryptDocumentInStorageAsyncWithHttpInfo($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postEncryptDocumentInStorageAsyncWithHttpInfo
     *
     * Encrypt document in storage.
     *
     * @param  string $name Document name. (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postEncryptDocumentInStorageAsyncWithHttpInfo($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postEncryptDocumentInStorageRequest($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postEncryptDocumentInStorage'
     *
     * @param  string $name Document name. (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postEncryptDocumentInStorageRequest($name, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postEncryptDocumentInStorage'
            );
        }
        // verify the required parameter 'user_password' is set
        if ($user_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_password when calling postEncryptDocumentInStorage'
            );
        }
        // verify the required parameter 'owner_password' is set
        if ($owner_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_password when calling postEncryptDocumentInStorage'
            );
        }
        // verify the required parameter 'crypto_algorithm' is set
        if ($crypto_algorithm === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_algorithm when calling postEncryptDocumentInStorage'
            );
        }

        $resourcePath = '/pdf/{name}/encrypt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($user_password !== null) {
            $queryParams['userPassword'] = ObjectSerializer::toQueryValue($user_password);
        }
        // query params
        if ($owner_password !== null) {
            $queryParams['ownerPassword'] = ObjectSerializer::toQueryValue($owner_password);
        }
        // query params
        if ($crypto_algorithm !== null) {
            $queryParams['cryptoAlgorithm'] = ObjectSerializer::toQueryValue($crypto_algorithm);
        }
        // query params
        if (is_array($permissions_flags)) {
            $permissions_flags = ObjectSerializer::serializeCollection($permissions_flags, 'multi', true);
        }
        if ($permissions_flags !== null) {
            $queryParams['permissionsFlags'] = ObjectSerializer::toQueryValue($permissions_flags);
        }
        // query params
        if ($use_pdf20 !== null) {
            $queryParams['usePdf20'] = ObjectSerializer::toQueryValue($use_pdf20);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFlattenDocument
     *
     * Flatten the document.
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postFlattenDocument($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postFlattenDocumentWithHttpInfo($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postFlattenDocumentWithHttpInfo($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postFlattenDocumentWithHttpInfo
     *
     * Flatten the document.
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFlattenDocumentWithHttpInfo($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postFlattenDocumentRequest($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFlattenDocumentAsync
     *
     * Flatten the document.
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFlattenDocumentAsync($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        return $this->postFlattenDocumentAsyncWithHttpInfo($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFlattenDocumentAsyncWithHttpInfo
     *
     * Flatten the document.
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFlattenDocumentAsyncWithHttpInfo($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postFlattenDocumentRequest($name, $update_appearances, $call_events, $hide_buttons, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFlattenDocument'
     *
     * @param  string $name The document name. (required)
     * @param  bool $update_appearances If set, all field appearances will be regenerated before flattening. This option may help if field is incorrectly flattened. This option may decrease performance.. (optional)
     * @param  bool $call_events If set, formatting and other JavaScript events will be called. (optional)
     * @param  bool $hide_buttons If set, buttons will be removed from flattened document. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFlattenDocumentRequest($name, $update_appearances = null, $call_events = null, $hide_buttons = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postFlattenDocument'
            );
        }

        $resourcePath = '/pdf/{name}/flatten';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($update_appearances !== null) {
            $queryParams['updateAppearances'] = ObjectSerializer::toQueryValue($update_appearances);
        }
        // query params
        if ($call_events !== null) {
            $queryParams['callEvents'] = ObjectSerializer::toQueryValue($call_events);
        }
        // query params
        if ($hide_buttons !== null) {
            $queryParams['hideButtons'] = ObjectSerializer::toQueryValue($hide_buttons);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postInsertImage
     *
     * Insert image to document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postInsertImage($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        try
        {
            list($response) = $this->postInsertImageWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postInsertImageWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postInsertImageWithHttpInfo
     *
     * Insert image to document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postInsertImageWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postInsertImageRequest($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postInsertImageAsync
     *
     * Insert image to document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInsertImageAsync($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        return $this->postInsertImageAsyncWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postInsertImageAsyncWithHttpInfo
     *
     * Insert image to document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInsertImageAsyncWithHttpInfo($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postInsertImageRequest($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path, $storage, $folder, $image);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postInsertImage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  double $llx Coordinate lower left X. (required)
     * @param  double $lly Coordinate lower left Y. (required)
     * @param  double $urx Coordinate upper right X. (required)
     * @param  double $ury Coordinate upper right Y. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postInsertImageRequest($name, $page_number, $llx, $lly, $urx, $ury, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postInsertImage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postInsertImage'
            );
        }
        // verify the required parameter 'llx' is set
        if ($llx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $llx when calling postInsertImage'
            );
        }
        // verify the required parameter 'lly' is set
        if ($lly === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lly when calling postInsertImage'
            );
        }
        // verify the required parameter 'urx' is set
        if ($urx === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $urx when calling postInsertImage'
            );
        }
        // verify the required parameter 'ury' is set
        if ($ury === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ury when calling postInsertImage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($llx !== null) {
            $queryParams['llx'] = ObjectSerializer::toQueryValue($llx);
        }
        // query params
        if ($lly !== null) {
            $queryParams['lly'] = ObjectSerializer::toQueryValue($lly);
        }
        // query params
        if ($urx !== null) {
            $queryParams['urx'] = ObjectSerializer::toQueryValue($urx);
        }
        // query params
        if ($ury !== null) {
            $queryParams['ury'] = ObjectSerializer::toQueryValue($ury);
        }
        // query params
        if ($image_file_path !== null) {
            $queryParams['imageFilePath'] = ObjectSerializer::toQueryValue($image_file_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // form params
        if ($image !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($image);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['image'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['image'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postMoveFile
     *
     * Move a specific file
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postMoveFile($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        try
        {
            list($response) = $this->postMoveFileWithHttpInfo($src, $dest, $version_id, $storage, $dest_storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postMoveFileWithHttpInfo($src, $dest, $version_id, $storage, $dest_storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postMoveFileWithHttpInfo
     *
     * Move a specific file
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMoveFileWithHttpInfo($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMoveFileRequest($src, $dest, $version_id, $storage, $dest_storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postMoveFileAsync
     *
     * Move a specific file
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMoveFileAsync($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        return $this->postMoveFileAsyncWithHttpInfo($src, $dest, $version_id, $storage, $dest_storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postMoveFileAsyncWithHttpInfo
     *
     * Move a specific file
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMoveFileAsyncWithHttpInfo($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMoveFileRequest($src, $dest, $version_id, $storage, $dest_storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postMoveFile'
     *
     * @param  string $src Source file path e.g. /fileSource.ext (required)
     * @param  string $dest Destination file path e.g. /fileDestination.ext (required)
     * @param  string $version_id Source file&#39;s version, (optional)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postMoveFileRequest($src, $dest, $version_id = null, $storage = null, $dest_storage = null)
    {
        // verify the required parameter 'src' is set
        if ($src === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src when calling postMoveFile'
            );
        }
        // verify the required parameter 'dest' is set
        if ($dest === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dest when calling postMoveFile'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src !== null) {
            $queryParams['src'] = ObjectSerializer::toQueryValue($src);
        }
        // query params
        if ($dest !== null) {
            $queryParams['dest'] = ObjectSerializer::toQueryValue($dest);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($dest_storage !== null) {
            $queryParams['destStorage'] = ObjectSerializer::toQueryValue($dest_storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postMoveFolder
     *
     * Move a specific folder
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postMoveFolder($src, $dest, $storage = null, $dest_storage = null)
    {
        try
        {
            list($response) = $this->postMoveFolderWithHttpInfo($src, $dest, $storage, $dest_storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postMoveFolderWithHttpInfo($src, $dest, $storage, $dest_storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postMoveFolderWithHttpInfo
     *
     * Move a specific folder
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMoveFolderWithHttpInfo($src, $dest, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMoveFolderRequest($src, $dest, $storage, $dest_storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postMoveFolderAsync
     *
     * Move a specific folder
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMoveFolderAsync($src, $dest, $storage = null, $dest_storage = null)
    {
        return $this->postMoveFolderAsyncWithHttpInfo($src, $dest, $storage, $dest_storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postMoveFolderAsyncWithHttpInfo
     *
     * Move a specific folder
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMoveFolderAsyncWithHttpInfo($src, $dest, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMoveFolderRequest($src, $dest, $storage, $dest_storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postMoveFolder'
     *
     * @param  string $src Source folder path e.g. /Folder1 (required)
     * @param  string $dest Destination folder path e.g. /Folder2 (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postMoveFolderRequest($src, $dest, $storage = null, $dest_storage = null)
    {
        // verify the required parameter 'src' is set
        if ($src === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src when calling postMoveFolder'
            );
        }
        // verify the required parameter 'dest' is set
        if ($dest === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dest when calling postMoveFolder'
            );
        }

        $resourcePath = '/storage/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src !== null) {
            $queryParams['src'] = ObjectSerializer::toQueryValue($src);
        }
        // query params
        if ($dest !== null) {
            $queryParams['dest'] = ObjectSerializer::toQueryValue($dest);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($dest_storage !== null) {
            $queryParams['destStorage'] = ObjectSerializer::toQueryValue($dest_storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postMovePage
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postMovePage($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postMovePageWithHttpInfo($name, $page_number, $new_index, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postMovePageWithHttpInfo($name, $page_number, $new_index, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postMovePageWithHttpInfo
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMovePageWithHttpInfo($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMovePageRequest($name, $page_number, $new_index, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postMovePageAsync
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMovePageAsync($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        return $this->postMovePageAsyncWithHttpInfo($name, $page_number, $new_index, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postMovePageAsyncWithHttpInfo
     *
     * Move page to new position.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMovePageAsyncWithHttpInfo($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postMovePageRequest($name, $page_number, $new_index, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postMovePage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $new_index The new page position/index. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postMovePageRequest($name, $page_number, $new_index, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postMovePage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postMovePage'
            );
        }
        // verify the required parameter 'new_index' is set
        if ($new_index === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_index when calling postMovePage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/movePage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_index !== null) {
            $queryParams['newIndex'] = ObjectSerializer::toQueryValue($new_index);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postOptimizeDocument
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postOptimizeDocument($name, $options = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postOptimizeDocumentWithHttpInfo($name, $options, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postOptimizeDocumentWithHttpInfo($name, $options, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postOptimizeDocumentWithHttpInfo
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postOptimizeDocumentWithHttpInfo($name, $options = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postOptimizeDocumentRequest($name, $options, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postOptimizeDocumentAsync
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOptimizeDocumentAsync($name, $options = null, $storage = null, $folder = null)
    {
        return $this->postOptimizeDocumentAsyncWithHttpInfo($name, $options, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postOptimizeDocumentAsyncWithHttpInfo
     *
     * Optimize document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postOptimizeDocumentAsyncWithHttpInfo($name, $options = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postOptimizeDocumentRequest($name, $options, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postOptimizeDocument'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\OptimizeOptions $options The optimization options. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postOptimizeDocumentRequest($name, $options = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postOptimizeDocument'
            );
        }

        $resourcePath = '/pdf/{name}/optimize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($options)) {
            $_tempBody = $options;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageCaretAnnotations
     *
     * Add document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageCaretAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageCaretAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageCaretAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageCaretAnnotationsWithHttpInfo
     *
     * Add document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageCaretAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageCaretAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageCaretAnnotationsAsync
     *
     * Add document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageCaretAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageCaretAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageCaretAnnotationsAsyncWithHttpInfo
     *
     * Add document page caret annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageCaretAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageCaretAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageCaretAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageCaretAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageCaretAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageCaretAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageCaretAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/caret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageCircleAnnotations
     *
     * Add document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageCircleAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageCircleAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageCircleAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageCircleAnnotationsWithHttpInfo
     *
     * Add document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageCircleAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageCircleAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageCircleAnnotationsAsync
     *
     * Add document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageCircleAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageCircleAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageCircleAnnotationsAsyncWithHttpInfo
     *
     * Add document page circle annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageCircleAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageCircleAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageCircleAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageCircleAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageCircleAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageCircleAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageCircleAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/circle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageFileAttachmentAnnotations
     *
     * Add document page FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation[] $annotations Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageFileAttachmentAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageFileAttachmentAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageFileAttachmentAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageFileAttachmentAnnotationsWithHttpInfo
     *
     * Add document page FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation[] $annotations Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageFileAttachmentAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageFileAttachmentAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageFileAttachmentAnnotationsAsync
     *
     * Add document page FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation[] $annotations Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageFileAttachmentAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageFileAttachmentAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageFileAttachmentAnnotationsAsyncWithHttpInfo
     *
     * Add document page FileAttachment annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation[] $annotations Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageFileAttachmentAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageFileAttachmentAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageFileAttachmentAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation[] $annotations Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageFileAttachmentAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageFileAttachmentAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageFileAttachmentAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageFileAttachmentAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/fileattachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageFreeTextAnnotations
     *
     * Add document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageFreeTextAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageFreeTextAnnotationsWithHttpInfo
     *
     * Add document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageFreeTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageFreeTextAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageFreeTextAnnotationsAsync
     *
     * Add document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageFreeTextAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageFreeTextAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageFreeTextAnnotationsAsyncWithHttpInfo
     *
     * Add document page free text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageFreeTextAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageFreeTextAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageFreeTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageFreeTextAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageFreeTextAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageFreeTextAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageFreeTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/freetext';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageHighlightAnnotations
     *
     * Add document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageHighlightAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageHighlightAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageHighlightAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageHighlightAnnotationsWithHttpInfo
     *
     * Add document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageHighlightAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageHighlightAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageHighlightAnnotationsAsync
     *
     * Add document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageHighlightAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageHighlightAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageHighlightAnnotationsAsyncWithHttpInfo
     *
     * Add document page highlight annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageHighlightAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageHighlightAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageHighlightAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageHighlightAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageHighlightAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageHighlightAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageHighlightAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/highlight';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageImageStamps
     *
     * Add document page image stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ImageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageImageStamps($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageImageStampsWithHttpInfo($name, $page_number, $stamps, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageImageStampsWithHttpInfo($name, $page_number, $stamps, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageImageStampsWithHttpInfo
     *
     * Add document page image stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ImageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageImageStampsWithHttpInfo($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageImageStampsRequest($name, $page_number, $stamps, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageImageStampsAsync
     *
     * Add document page image stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ImageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageImageStampsAsync($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        return $this->postPageImageStampsAsyncWithHttpInfo($name, $page_number, $stamps, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageImageStampsAsyncWithHttpInfo
     *
     * Add document page image stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ImageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageImageStampsAsyncWithHttpInfo($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageImageStampsRequest($name, $page_number, $stamps, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageImageStamps'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ImageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageImageStampsRequest($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageImageStamps'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageImageStamps'
            );
        }
        // verify the required parameter 'stamps' is set
        if ($stamps === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamps when calling postPageImageStamps'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/stamps/image';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($stamps)) {
            $_tempBody = $stamps;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageInkAnnotations
     *
     * Add document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageInkAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageInkAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageInkAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageInkAnnotationsWithHttpInfo
     *
     * Add document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageInkAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageInkAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageInkAnnotationsAsync
     *
     * Add document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageInkAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageInkAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageInkAnnotationsAsyncWithHttpInfo
     *
     * Add document page ink annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageInkAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageInkAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageInkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageInkAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageInkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageInkAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageInkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/ink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageLineAnnotations
     *
     * Add document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageLineAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageLineAnnotationsWithHttpInfo
     *
     * Add document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageLineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageLineAnnotationsAsync
     *
     * Add document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageLineAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageLineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageLineAnnotationsAsyncWithHttpInfo
     *
     * Add document page line annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageLineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageLineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageLineAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageLineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageLineAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/line';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageLinkAnnotations
     *
     * Add document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageLinkAnnotations($name, $page_number, $links, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageLinkAnnotationsWithHttpInfo($name, $page_number, $links, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageLinkAnnotationsWithHttpInfo($name, $page_number, $links, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageLinkAnnotationsWithHttpInfo
     *
     * Add document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageLinkAnnotationsWithHttpInfo($name, $page_number, $links, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageLinkAnnotationsRequest($name, $page_number, $links, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageLinkAnnotationsAsync
     *
     * Add document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageLinkAnnotationsAsync($name, $page_number, $links, $storage = null, $folder = null)
    {
        return $this->postPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $links, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageLinkAnnotationsAsyncWithHttpInfo
     *
     * Add document page link annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageLinkAnnotationsAsyncWithHttpInfo($name, $page_number, $links, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageLinkAnnotationsRequest($name, $page_number, $links, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageLinkAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation[] $links Array of link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageLinkAnnotationsRequest($name, $page_number, $links, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageLinkAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageLinkAnnotations'
            );
        }
        // verify the required parameter 'links' is set
        if ($links === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $links when calling postPageLinkAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($links)) {
            $_tempBody = $links;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageMovieAnnotations
     *
     * Add document page movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageMovieAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageMovieAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageMovieAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageMovieAnnotationsWithHttpInfo
     *
     * Add document page movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageMovieAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageMovieAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageMovieAnnotationsAsync
     *
     * Add document page movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageMovieAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageMovieAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageMovieAnnotationsAsyncWithHttpInfo
     *
     * Add document page movie annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageMovieAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageMovieAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageMovieAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageMovieAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageMovieAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageMovieAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageMovieAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/movie';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagePdfPageStamps
     *
     * Add document pdf page stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PdfPageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPagePdfPageStamps($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPagePdfPageStampsWithHttpInfo($name, $page_number, $stamps, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPagePdfPageStampsWithHttpInfo($name, $page_number, $stamps, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPagePdfPageStampsWithHttpInfo
     *
     * Add document pdf page stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PdfPageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagePdfPageStampsWithHttpInfo($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePdfPageStampsRequest($name, $page_number, $stamps, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagePdfPageStampsAsync
     *
     * Add document pdf page stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PdfPageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePdfPageStampsAsync($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        return $this->postPagePdfPageStampsAsyncWithHttpInfo($name, $page_number, $stamps, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagePdfPageStampsAsyncWithHttpInfo
     *
     * Add document pdf page stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PdfPageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePdfPageStampsAsyncWithHttpInfo($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePdfPageStampsRequest($name, $page_number, $stamps, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagePdfPageStamps'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PdfPageStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPagePdfPageStampsRequest($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPagePdfPageStamps'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPagePdfPageStamps'
            );
        }
        // verify the required parameter 'stamps' is set
        if ($stamps === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamps when calling postPagePdfPageStamps'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/stamps/pdfpage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($stamps)) {
            $_tempBody = $stamps;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagePolyLineAnnotations
     *
     * Add document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPagePolyLineAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPagePolyLineAnnotationsWithHttpInfo
     *
     * Add document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagePolyLineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePolyLineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagePolyLineAnnotationsAsync
     *
     * Add document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePolyLineAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPagePolyLineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagePolyLineAnnotationsAsyncWithHttpInfo
     *
     * Add document page polyline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePolyLineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePolyLineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagePolyLineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPagePolyLineAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPagePolyLineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPagePolyLineAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPagePolyLineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/polyline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagePolygonAnnotations
     *
     * Add document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPagePolygonAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPagePolygonAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPagePolygonAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPagePolygonAnnotationsWithHttpInfo
     *
     * Add document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagePolygonAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePolygonAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagePolygonAnnotationsAsync
     *
     * Add document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePolygonAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPagePolygonAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagePolygonAnnotationsAsyncWithHttpInfo
     *
     * Add document page polygon annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagePolygonAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPagePolygonAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagePolygonAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPagePolygonAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPagePolygonAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPagePolygonAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPagePolygonAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/polygon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageRedactionAnnotations
     *
     * Add document page redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageRedactionAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageRedactionAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageRedactionAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageRedactionAnnotationsWithHttpInfo
     *
     * Add document page redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageRedactionAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageRedactionAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageRedactionAnnotationsAsync
     *
     * Add document page redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageRedactionAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageRedactionAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageRedactionAnnotationsAsyncWithHttpInfo
     *
     * Add document page redaction annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageRedactionAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageRedactionAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageRedactionAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageRedactionAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageRedactionAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageRedactionAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageRedactionAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/redaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageScreenAnnotations
     *
     * Add document page screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageScreenAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageScreenAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageScreenAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageScreenAnnotationsWithHttpInfo
     *
     * Add document page screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageScreenAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageScreenAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageScreenAnnotationsAsync
     *
     * Add document page screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageScreenAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageScreenAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageScreenAnnotationsAsyncWithHttpInfo
     *
     * Add document page screen annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageScreenAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageScreenAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageScreenAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageScreenAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageScreenAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageScreenAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageScreenAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/screen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageSoundAnnotations
     *
     * Add document page sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageSoundAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageSoundAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageSoundAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageSoundAnnotationsWithHttpInfo
     *
     * Add document page sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageSoundAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSoundAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageSoundAnnotationsAsync
     *
     * Add document page sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSoundAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageSoundAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageSoundAnnotationsAsyncWithHttpInfo
     *
     * Add document page sound annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSoundAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSoundAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageSoundAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageSoundAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageSoundAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageSoundAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageSoundAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/sound';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageSquareAnnotations
     *
     * Add document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageSquareAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageSquareAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageSquareAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageSquareAnnotationsWithHttpInfo
     *
     * Add document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageSquareAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSquareAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageSquareAnnotationsAsync
     *
     * Add document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSquareAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageSquareAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageSquareAnnotationsAsyncWithHttpInfo
     *
     * Add document page square annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSquareAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSquareAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageSquareAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageSquareAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageSquareAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageSquareAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageSquareAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/square';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageSquigglyAnnotations
     *
     * Add document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageSquigglyAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageSquigglyAnnotationsWithHttpInfo
     *
     * Add document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageSquigglyAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSquigglyAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageSquigglyAnnotationsAsync
     *
     * Add document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSquigglyAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageSquigglyAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageSquigglyAnnotationsAsyncWithHttpInfo
     *
     * Add document page squiggly annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageSquigglyAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageSquigglyAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageSquigglyAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageSquigglyAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageSquigglyAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageSquigglyAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageSquigglyAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/squiggly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageStampAnnotations
     *
     * Add document page stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageStampAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageStampAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageStampAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageStampAnnotationsWithHttpInfo
     *
     * Add document page stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageStampAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageStampAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageStampAnnotationsAsync
     *
     * Add document page stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageStampAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageStampAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageStampAnnotationsAsyncWithHttpInfo
     *
     * Add document page stamp annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageStampAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageStampAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageStampAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageStampAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageStampAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageStampAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageStampAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/stamp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageStrikeOutAnnotations
     *
     * Add document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageStrikeOutAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageStrikeOutAnnotationsWithHttpInfo
     *
     * Add document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageStrikeOutAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageStrikeOutAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageStrikeOutAnnotationsAsync
     *
     * Add document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageStrikeOutAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageStrikeOutAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageStrikeOutAnnotationsAsyncWithHttpInfo
     *
     * Add document page StrikeOut annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageStrikeOutAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageStrikeOutAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageStrikeOutAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageStrikeOutAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageStrikeOutAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageStrikeOutAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageStrikeOutAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/strikeout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageTables
     *
     * Add document page tables.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Table[] $tables The array of table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageTables($name, $page_number, $tables, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageTablesWithHttpInfo($name, $page_number, $tables, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageTablesWithHttpInfo($name, $page_number, $tables, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageTablesWithHttpInfo
     *
     * Add document page tables.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Table[] $tables The array of table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageTablesWithHttpInfo($name, $page_number, $tables, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageTablesRequest($name, $page_number, $tables, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageTablesAsync
     *
     * Add document page tables.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Table[] $tables The array of table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTablesAsync($name, $page_number, $tables, $storage = null, $folder = null)
    {
        return $this->postPageTablesAsyncWithHttpInfo($name, $page_number, $tables, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageTablesAsyncWithHttpInfo
     *
     * Add document page tables.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Table[] $tables The array of table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTablesAsyncWithHttpInfo($name, $page_number, $tables, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageTablesRequest($name, $page_number, $tables, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageTables'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Table[] $tables The array of table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageTablesRequest($name, $page_number, $tables, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageTables'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageTables'
            );
        }
        // verify the required parameter 'tables' is set
        if ($tables === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tables when calling postPageTables'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/tables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($tables)) {
            $_tempBody = $tables;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageTextAnnotations
     *
     * Add document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageTextAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageTextAnnotationsWithHttpInfo
     *
     * Add document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageTextAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageTextAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageTextAnnotationsAsync
     *
     * Add document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageTextAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageTextAnnotationsAsyncWithHttpInfo
     *
     * Add document page text annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageTextAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageTextAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageTextAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageTextAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageTextAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageTextAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageTextReplace
     *
     * Page's replace text method.
     *
     * @param  string $name name (required)
     * @param  int $page_number page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request text_replace_list_request (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextReplaceResponse
     */
    public function postPageTextReplace($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageTextReplaceWithHttpInfo
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextReplaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageTextReplaceWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextReplaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageTextReplaceAsync
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextReplaceAsync($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        return $this->postPageTextReplaceAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageTextReplaceAsyncWithHttpInfo
     *
     * Page's replace text method.
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextReplaceAsyncWithHttpInfo($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextReplaceResponse';
        $request = $this->postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageTextReplace'
     *
     * @param  string $name (required)
     * @param  int $page_number (required)
     * @param  \Aspose\PDF\Model\TextReplaceListRequest $text_replace_list_request (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageTextReplaceRequest($name, $page_number, $text_replace_list_request, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageTextReplace'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageTextReplace'
            );
        }
        // verify the required parameter 'text_replace_list_request' is set
        if ($text_replace_list_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_replace_list_request when calling postPageTextReplace'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text/replace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($text_replace_list_request)) {
            $_tempBody = $text_replace_list_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageTextStamps
     *
     * Add document page text stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageTextStamps($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageTextStampsWithHttpInfo($name, $page_number, $stamps, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageTextStampsWithHttpInfo($name, $page_number, $stamps, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageTextStampsWithHttpInfo
     *
     * Add document page text stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageTextStampsWithHttpInfo($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageTextStampsRequest($name, $page_number, $stamps, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageTextStampsAsync
     *
     * Add document page text stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextStampsAsync($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        return $this->postPageTextStampsAsyncWithHttpInfo($name, $page_number, $stamps, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageTextStampsAsyncWithHttpInfo
     *
     * Add document page text stamps.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageTextStampsAsyncWithHttpInfo($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageTextStampsRequest($name, $page_number, $stamps, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageTextStamps'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\TextStamp[] $stamps The array of stamp. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageTextStampsRequest($name, $page_number, $stamps, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageTextStamps'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageTextStamps'
            );
        }
        // verify the required parameter 'stamps' is set
        if ($stamps === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamps when calling postPageTextStamps'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/stamps/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($stamps)) {
            $_tempBody = $stamps;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPageUnderlineAnnotations
     *
     * Add document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPageUnderlineAnnotations($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPageUnderlineAnnotationsWithHttpInfo
     *
     * Add document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPageUnderlineAnnotationsWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageUnderlineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPageUnderlineAnnotationsAsync
     *
     * Add document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageUnderlineAnnotationsAsync($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        return $this->postPageUnderlineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPageUnderlineAnnotationsAsyncWithHttpInfo
     *
     * Add document page underline annotations.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPageUnderlineAnnotationsAsyncWithHttpInfo($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPageUnderlineAnnotationsRequest($name, $page_number, $annotations, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPageUnderlineAnnotations'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation[] $annotations The array of annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPageUnderlineAnnotationsRequest($name, $page_number, $annotations, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPageUnderlineAnnotations'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postPageUnderlineAnnotations'
            );
        }
        // verify the required parameter 'annotations' is set
        if ($annotations === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotations when calling postPageUnderlineAnnotations'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/annotations/underline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotations)) {
            $_tempBody = $annotations;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPopupAnnotation
     *
     * Add document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postPopupAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postPopupAnnotationWithHttpInfo
     *
     * Add document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPopupAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPopupAnnotationAsync
     *
     * Add document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPopupAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->postPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPopupAnnotationAsyncWithHttpInfo
     *
     * Add document popup annotations.
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postPopupAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPopupAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The parent annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation The annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPopupAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling postPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling postPopupAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/{annotationId}/popup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSignDocument
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postSignDocument($name, $signature = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postSignDocumentWithHttpInfo($name, $signature, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postSignDocumentWithHttpInfo($name, $signature, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postSignDocumentWithHttpInfo
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSignDocumentWithHttpInfo($name, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postSignDocumentRequest($name, $signature, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSignDocumentAsync
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignDocumentAsync($name, $signature = null, $storage = null, $folder = null)
    {
        return $this->postSignDocumentAsyncWithHttpInfo($name, $signature, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSignDocumentAsyncWithHttpInfo
     *
     * Sign document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignDocumentAsyncWithHttpInfo($name, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postSignDocumentRequest($name, $signature, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSignDocument'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSignDocumentRequest($name, $signature = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSignDocument'
            );
        }

        $resourcePath = '/pdf/{name}/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($signature)) {
            $_tempBody = $signature;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSignPage
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function postSignPage($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postSignPageWithHttpInfo($name, $page_number, $signature, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postSignPageWithHttpInfo($name, $page_number, $signature, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postSignPageWithHttpInfo
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSignPageWithHttpInfo($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postSignPageRequest($name, $page_number, $signature, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSignPageAsync
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignPageAsync($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        return $this->postSignPageAsyncWithHttpInfo($name, $page_number, $signature, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSignPageAsyncWithHttpInfo
     *
     * Sign page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSignPageAsyncWithHttpInfo($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->postSignPageRequest($name, $page_number, $signature, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSignPage'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Signature $signature Signature object containing signature data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSignPageRequest($name, $page_number, $signature = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSignPage'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling postSignPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($signature)) {
            $_tempBody = $signature;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSplitDocument
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SplitResultResponse
     */
    public function postSplitDocument($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->postSplitDocumentWithHttpInfo($name, $format, $from, $to, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->postSplitDocumentWithHttpInfo($name, $format, $from, $to, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation postSplitDocumentWithHttpInfo
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SplitResultResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSplitDocumentWithHttpInfo($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SplitResultResponse';
        $request = $this->postSplitDocumentRequest($name, $format, $from, $to, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SplitResultResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSplitDocumentAsync
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSplitDocumentAsync($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        return $this->postSplitDocumentAsyncWithHttpInfo($name, $format, $from, $to, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSplitDocumentAsyncWithHttpInfo
     *
     * Split document to parts.
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSplitDocumentAsyncWithHttpInfo($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SplitResultResponse';
        $request = $this->postSplitDocumentRequest($name, $format, $from, $to, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSplitDocument'
     *
     * @param  string $name Document name. (required)
     * @param  string $format Resulting documents format. (optional)
     * @param  int $from Start page if defined. (optional)
     * @param  int $to End page if defined. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSplitDocumentRequest($name, $format = null, $from = null, $to = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling postSplitDocument'
            );
        }

        $resourcePath = '/pdf/{name}/split';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddNewPage
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPagesResponse
     */
    public function putAddNewPage($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putAddNewPageWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putAddNewPageWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putAddNewPageWithHttpInfo
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddNewPageWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->putAddNewPageRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddNewPageAsync
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddNewPageAsync($name, $storage = null, $folder = null)
    {
        return $this->putAddNewPageAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddNewPageAsyncWithHttpInfo
     *
     * Add new page to end of the document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddNewPageAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPagesResponse';
        $request = $this->putAddNewPageRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddNewPage'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddNewPageRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddNewPage'
            );
        }

        $resourcePath = '/pdf/{name}/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAddText
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putAddText($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putAddTextWithHttpInfo($name, $page_number, $paragraph, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putAddTextWithHttpInfo($name, $page_number, $paragraph, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putAddTextWithHttpInfo
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAddTextWithHttpInfo($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putAddTextRequest($name, $page_number, $paragraph, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAddTextAsync
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddTextAsync($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        return $this->putAddTextAsyncWithHttpInfo($name, $page_number, $paragraph, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAddTextAsyncWithHttpInfo
     *
     * Add text to PDF document page.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAddTextAsyncWithHttpInfo($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putAddTextRequest($name, $page_number, $paragraph, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAddText'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number Number of page (starting from 1). (required)
     * @param  \Aspose\PDF\Model\Paragraph $paragraph Paragraph data. (optional)
     * @param  string $folder Document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAddTextRequest($name, $page_number, $paragraph = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAddText'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putAddText'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($paragraph)) {
            $_tempBody = $paragraph;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putAnnotationsFlatten
     *
     * Flattens the annotations of the specified types
     *
     * @param  string $name The document name. (required)
     * @param  int $start_page The start page number. (optional)
     * @param  int $end_page The end page number. (optional)
     * @param  \Aspose\PDF\Model\AnnotationType[] $annotation_types Array of annotation types. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putAnnotationsFlatten($name, $start_page = null, $end_page = null, $annotation_types = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putAnnotationsFlattenWithHttpInfo($name, $start_page, $end_page, $annotation_types, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putAnnotationsFlattenWithHttpInfo($name, $start_page, $end_page, $annotation_types, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putAnnotationsFlattenWithHttpInfo
     *
     * Flattens the annotations of the specified types
     *
     * @param  string $name The document name. (required)
     * @param  int $start_page The start page number. (optional)
     * @param  int $end_page The end page number. (optional)
     * @param  \Aspose\PDF\Model\AnnotationType[] $annotation_types Array of annotation types. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putAnnotationsFlattenWithHttpInfo($name, $start_page = null, $end_page = null, $annotation_types = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putAnnotationsFlattenRequest($name, $start_page, $end_page, $annotation_types, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putAnnotationsFlattenAsync
     *
     * Flattens the annotations of the specified types
     *
     * @param  string $name The document name. (required)
     * @param  int $start_page The start page number. (optional)
     * @param  int $end_page The end page number. (optional)
     * @param  \Aspose\PDF\Model\AnnotationType[] $annotation_types Array of annotation types. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAnnotationsFlattenAsync($name, $start_page = null, $end_page = null, $annotation_types = null, $storage = null, $folder = null)
    {
        return $this->putAnnotationsFlattenAsyncWithHttpInfo($name, $start_page, $end_page, $annotation_types, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putAnnotationsFlattenAsyncWithHttpInfo
     *
     * Flattens the annotations of the specified types
     *
     * @param  string $name The document name. (required)
     * @param  int $start_page The start page number. (optional)
     * @param  int $end_page The end page number. (optional)
     * @param  \Aspose\PDF\Model\AnnotationType[] $annotation_types Array of annotation types. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putAnnotationsFlattenAsyncWithHttpInfo($name, $start_page = null, $end_page = null, $annotation_types = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putAnnotationsFlattenRequest($name, $start_page, $end_page, $annotation_types, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putAnnotationsFlatten'
     *
     * @param  string $name The document name. (required)
     * @param  int $start_page The start page number. (optional)
     * @param  int $end_page The end page number. (optional)
     * @param  \Aspose\PDF\Model\AnnotationType[] $annotation_types Array of annotation types. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putAnnotationsFlattenRequest($name, $start_page = null, $end_page = null, $annotation_types = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putAnnotationsFlatten'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/flatten';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_page !== null) {
            $queryParams['startPage'] = ObjectSerializer::toQueryValue($start_page);
        }
        // query params
        if ($end_page !== null) {
            $queryParams['endPage'] = ObjectSerializer::toQueryValue($end_page);
        }
        // query params
        if (is_array($annotation_types)) {
            $annotation_types = ObjectSerializer::serializeCollection($annotation_types, 'multi', true);
        }
        if ($annotation_types !== null) {
            $queryParams['annotationTypes'] = ObjectSerializer::toQueryValue($annotation_types);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCaretAnnotation
     *
     * Replace document caret annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CaretAnnotationResponse
     */
    public function putCaretAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putCaretAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCaretAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCaretAnnotationWithHttpInfo
     *
     * Replace document caret annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CaretAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCaretAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationResponse';
        $request = $this->putCaretAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CaretAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCaretAnnotationAsync
     *
     * Replace document caret annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCaretAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putCaretAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCaretAnnotationAsyncWithHttpInfo
     *
     * Replace document caret annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCaretAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CaretAnnotationResponse';
        $request = $this->putCaretAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCaretAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CaretAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCaretAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCaretAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putCaretAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putCaretAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/caret/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putChangePasswordDocument
     *
     * Change document password from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be changed password. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putChangePasswordDocument($out_path, $owner_password, $new_user_password, $new_owner_password, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putChangePasswordDocumentWithHttpInfo($out_path, $owner_password, $new_user_password, $new_owner_password, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putChangePasswordDocumentWithHttpInfo($out_path, $owner_password, $new_user_password, $new_owner_password, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putChangePasswordDocumentWithHttpInfo
     *
     * Change document password from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be changed password. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putChangePasswordDocumentWithHttpInfo($out_path, $owner_password, $new_user_password, $new_owner_password, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putChangePasswordDocumentRequest($out_path, $owner_password, $new_user_password, $new_owner_password, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putChangePasswordDocumentAsync
     *
     * Change document password from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be changed password. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putChangePasswordDocumentAsync($out_path, $owner_password, $new_user_password, $new_owner_password, $storage = null, $file = null)
    {
        return $this->putChangePasswordDocumentAsyncWithHttpInfo($out_path, $owner_password, $new_user_password, $new_owner_password, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putChangePasswordDocumentAsyncWithHttpInfo
     *
     * Change document password from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be changed password. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putChangePasswordDocumentAsyncWithHttpInfo($out_path, $owner_password, $new_user_password, $new_owner_password, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putChangePasswordDocumentRequest($out_path, $owner_password, $new_user_password, $new_owner_password, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putChangePasswordDocument'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $new_user_password New user password (encrypted Base64). (required)
     * @param  string $new_owner_password New owner password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be changed password. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putChangePasswordDocumentRequest($out_path, $owner_password, $new_user_password, $new_owner_password, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putChangePasswordDocument'
            );
        }
        // verify the required parameter 'owner_password' is set
        if ($owner_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_password when calling putChangePasswordDocument'
            );
        }
        // verify the required parameter 'new_user_password' is set
        if ($new_user_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_user_password when calling putChangePasswordDocument'
            );
        }
        // verify the required parameter 'new_owner_password' is set
        if ($new_owner_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_owner_password when calling putChangePasswordDocument'
            );
        }

        $resourcePath = '/pdf/changepassword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($owner_password !== null) {
            $queryParams['ownerPassword'] = ObjectSerializer::toQueryValue($owner_password);
        }
        // query params
        if ($new_user_password !== null) {
            $queryParams['newUserPassword'] = ObjectSerializer::toQueryValue($new_user_password);
        }
        // query params
        if ($new_owner_password !== null) {
            $queryParams['newOwnerPassword'] = ObjectSerializer::toQueryValue($new_owner_password);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCircleAnnotation
     *
     * Replace document circle annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\CircleAnnotationResponse
     */
    public function putCircleAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putCircleAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCircleAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCircleAnnotationWithHttpInfo
     *
     * Replace document circle annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\CircleAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCircleAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationResponse';
        $request = $this->putCircleAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\CircleAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCircleAnnotationAsync
     *
     * Replace document circle annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCircleAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putCircleAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCircleAnnotationAsyncWithHttpInfo
     *
     * Replace document circle annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCircleAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\CircleAnnotationResponse';
        $request = $this->putCircleAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCircleAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\CircleAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCircleAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCircleAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putCircleAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putCircleAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/circle/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreate
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putCreate($path, $file, $version_id = null, $storage = null)
    {
        try
        {
            list($response) = $this->putCreateWithHttpInfo($path, $file, $version_id, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCreateWithHttpInfo($path, $file, $version_id, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCreateWithHttpInfo
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateWithHttpInfo($path, $file, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putCreateRequest($path, $file, $version_id, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateAsync
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateAsync($path, $file, $version_id = null, $storage = null)
    {
        return $this->putCreateAsyncWithHttpInfo($path, $file, $version_id, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateAsyncWithHttpInfo
     *
     * Upload a specific file
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateAsyncWithHttpInfo($path, $file, $version_id = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putCreateRequest($path, $file, $version_id, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreate'
     *
     * @param  string $path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
     * @param  \SplFileObject $file File to upload (required)
     * @param  string $version_id Source file&#39;s version (optional)
     * @param  string $storage User&#39;s storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateRequest($path, $file, $version_id = null, $storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling putCreate'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling putCreate'
            );
        }

        $resourcePath = '/storage/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($version_id !== null) {
            $queryParams['versionId'] = ObjectSerializer::toQueryValue($version_id);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreateDocument
     *
     * Create empty document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function putCreateDocument($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putCreateDocumentWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCreateDocumentWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCreateDocumentWithHttpInfo
     *
     * Create empty document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateDocumentWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateDocumentAsync
     *
     * Create empty document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentAsync($name, $storage = null, $folder = null)
    {
        return $this->putCreateDocumentAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateDocumentAsyncWithHttpInfo
     *
     * Create empty document.
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateDocumentAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putCreateDocumentRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreateDocument'
     *
     * @param  string $name The new document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The new document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateDocumentRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putCreateDocument'
            );
        }

        $resourcePath = '/pdf/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCreateFolder
     *
     * Create the folder
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putCreateFolder($path, $storage = null, $dest_storage = null)
    {
        try
        {
            list($response) = $this->putCreateFolderWithHttpInfo($path, $storage, $dest_storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putCreateFolderWithHttpInfo($path, $storage, $dest_storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putCreateFolderWithHttpInfo
     *
     * Create the folder
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCreateFolderWithHttpInfo($path, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putCreateFolderRequest($path, $storage, $dest_storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCreateFolderAsync
     *
     * Create the folder
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateFolderAsync($path, $storage = null, $dest_storage = null)
    {
        return $this->putCreateFolderAsyncWithHttpInfo($path, $storage, $dest_storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCreateFolderAsyncWithHttpInfo
     *
     * Create the folder
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCreateFolderAsyncWithHttpInfo($path, $storage = null, $dest_storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putCreateFolderRequest($path, $storage, $dest_storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCreateFolder'
     *
     * @param  string $path Target folder&#39;s path e.g. Folder1/Folder2/. The folders will be created recursively (required)
     * @param  string $storage User&#39;s source storage name (optional)
     * @param  string $dest_storage User&#39;s destination storage name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putCreateFolderRequest($path, $storage = null, $dest_storage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling putCreateFolder'
            );
        }

        $resourcePath = '/storage/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($dest_storage !== null) {
            $queryParams['destStorage'] = ObjectSerializer::toQueryValue($dest_storage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDecryptDocument
     *
     * Decrypt document from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be derypted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putDecryptDocument($out_path, $password, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putDecryptDocumentWithHttpInfo($out_path, $password, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putDecryptDocumentWithHttpInfo($out_path, $password, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putDecryptDocumentWithHttpInfo
     *
     * Decrypt document from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be derypted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDecryptDocumentWithHttpInfo($out_path, $password, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putDecryptDocumentRequest($out_path, $password, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putDecryptDocumentAsync
     *
     * Decrypt document from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be derypted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDecryptDocumentAsync($out_path, $password, $storage = null, $file = null)
    {
        return $this->putDecryptDocumentAsyncWithHttpInfo($out_path, $password, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDecryptDocumentAsyncWithHttpInfo
     *
     * Decrypt document from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be derypted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDecryptDocumentAsyncWithHttpInfo($out_path, $password, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putDecryptDocumentRequest($out_path, $password, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDecryptDocument'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $password The password (encrypted Base64). (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be derypted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDecryptDocumentRequest($out_path, $password, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putDecryptDocument'
            );
        }
        // verify the required parameter 'password' is set
        if ($password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling putDecryptDocument'
            );
        }

        $resourcePath = '/pdf/decrypt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($password !== null) {
            $queryParams['password'] = ObjectSerializer::toQueryValue($password);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putEncryptDocument
     *
     * Encrypt document from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be encrypted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putEncryptDocument($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putEncryptDocumentWithHttpInfo($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putEncryptDocumentWithHttpInfo($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putEncryptDocumentWithHttpInfo
     *
     * Encrypt document from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be encrypted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putEncryptDocumentWithHttpInfo($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putEncryptDocumentRequest($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putEncryptDocumentAsync
     *
     * Encrypt document from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be encrypted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putEncryptDocumentAsync($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $file = null)
    {
        return $this->putEncryptDocumentAsyncWithHttpInfo($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putEncryptDocumentAsyncWithHttpInfo
     *
     * Encrypt document from content.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be encrypted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putEncryptDocumentAsyncWithHttpInfo($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putEncryptDocumentRequest($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags, $use_pdf20, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putEncryptDocument'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  string $user_password User password (encrypted Base64). (required)
     * @param  string $owner_password Owner password (encrypted Base64). (required)
     * @param  string $crypto_algorithm Cryptographic algorithm, see  for details. (required)
     * @param  \Aspose\PDF\Model\PermissionsFlags[] $permissions_flags Array of document permissions, see  for details. (optional)
     * @param  bool $use_pdf20 Support for revision 6 (Extension 8). (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be encrypted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putEncryptDocumentRequest($out_path, $user_password, $owner_password, $crypto_algorithm, $permissions_flags = null, $use_pdf20 = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putEncryptDocument'
            );
        }
        // verify the required parameter 'user_password' is set
        if ($user_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_password when calling putEncryptDocument'
            );
        }
        // verify the required parameter 'owner_password' is set
        if ($owner_password === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_password when calling putEncryptDocument'
            );
        }
        // verify the required parameter 'crypto_algorithm' is set
        if ($crypto_algorithm === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_algorithm when calling putEncryptDocument'
            );
        }

        $resourcePath = '/pdf/encrypt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($user_password !== null) {
            $queryParams['userPassword'] = ObjectSerializer::toQueryValue($user_password);
        }
        // query params
        if ($owner_password !== null) {
            $queryParams['ownerPassword'] = ObjectSerializer::toQueryValue($owner_password);
        }
        // query params
        if ($crypto_algorithm !== null) {
            $queryParams['cryptoAlgorithm'] = ObjectSerializer::toQueryValue($crypto_algorithm);
        }
        // query params
        if (is_array($permissions_flags)) {
            $permissions_flags = ObjectSerializer::serializeCollection($permissions_flags, 'multi', true);
        }
        if ($permissions_flags !== null) {
            $queryParams['permissionsFlags'] = ObjectSerializer::toQueryValue($permissions_flags);
        }
        // query params
        if ($use_pdf20 !== null) {
            $queryParams['usePdf20'] = ObjectSerializer::toQueryValue($use_pdf20);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putEpubInStorageToPdf
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putEpubInStorageToPdf($name, $src_path, $storage = null, $dst_folder = null)
    {
        try
        {
            list($response) = $this->putEpubInStorageToPdfWithHttpInfo($name, $src_path, $storage, $dst_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putEpubInStorageToPdfWithHttpInfo($name, $src_path, $storage, $dst_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putEpubInStorageToPdfWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putEpubInStorageToPdfWithHttpInfo($name, $src_path, $storage = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putEpubInStorageToPdfRequest($name, $src_path, $storage, $dst_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putEpubInStorageToPdfAsync
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putEpubInStorageToPdfAsync($name, $src_path, $storage = null, $dst_folder = null)
    {
        return $this->putEpubInStorageToPdfAsyncWithHttpInfo($name, $src_path, $storage, $dst_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putEpubInStorageToPdfAsyncWithHttpInfo
     *
     * Convert EPUB file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putEpubInStorageToPdfAsyncWithHttpInfo($name, $src_path, $storage = null, $dst_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putEpubInStorageToPdfRequest($name, $src_path, $storage, $dst_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putEpubInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.epub) (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putEpubInStorageToPdfRequest($name, $src_path, $storage = null, $dst_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putEpubInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putEpubInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFieldsFlatten
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putFieldsFlatten($name, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putFieldsFlattenWithHttpInfo($name, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putFieldsFlattenWithHttpInfo($name, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putFieldsFlattenWithHttpInfo
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFieldsFlattenWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putFieldsFlattenRequest($name, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFieldsFlattenAsync
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldsFlattenAsync($name, $storage = null, $folder = null)
    {
        return $this->putFieldsFlattenAsyncWithHttpInfo($name, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFieldsFlattenAsyncWithHttpInfo
     *
     * Flatten form fields in document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldsFlattenAsyncWithHttpInfo($name, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putFieldsFlattenRequest($name, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFieldsFlatten'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFieldsFlattenRequest($name, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putFieldsFlatten'
            );
        }

        $resourcePath = '/pdf/{name}/fields/flatten';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFileAttachmentAnnotation
     *
     * Replace document FileAttachment annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FileAttachmentAnnotationResponse
     */
    public function putFileAttachmentAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putFileAttachmentAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putFileAttachmentAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putFileAttachmentAnnotationWithHttpInfo
     *
     * Replace document FileAttachment annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FileAttachmentAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFileAttachmentAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FileAttachmentAnnotationResponse';
        $request = $this->putFileAttachmentAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FileAttachmentAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFileAttachmentAnnotationAsync
     *
     * Replace document FileAttachment annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFileAttachmentAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putFileAttachmentAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFileAttachmentAnnotationAsyncWithHttpInfo
     *
     * Replace document FileAttachment annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFileAttachmentAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FileAttachmentAnnotationResponse';
        $request = $this->putFileAttachmentAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFileAttachmentAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FileAttachmentAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFileAttachmentAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putFileAttachmentAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putFileAttachmentAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putFileAttachmentAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/fileattachment/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFileAttachmentAnnotationDataExtract
     *
     * Extract document FileAttachment annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_folder The output folder. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putFileAttachmentAnnotationDataExtract($name, $annotation_id, $out_folder = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putFileAttachmentAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_folder, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putFileAttachmentAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_folder, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putFileAttachmentAnnotationDataExtractWithHttpInfo
     *
     * Extract document FileAttachment annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_folder The output folder. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFileAttachmentAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_folder = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putFileAttachmentAnnotationDataExtractRequest($name, $annotation_id, $out_folder, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFileAttachmentAnnotationDataExtractAsync
     *
     * Extract document FileAttachment annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_folder The output folder. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFileAttachmentAnnotationDataExtractAsync($name, $annotation_id, $out_folder = null, $storage = null, $folder = null)
    {
        return $this->putFileAttachmentAnnotationDataExtractAsyncWithHttpInfo($name, $annotation_id, $out_folder, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFileAttachmentAnnotationDataExtractAsyncWithHttpInfo
     *
     * Extract document FileAttachment annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_folder The output folder. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFileAttachmentAnnotationDataExtractAsyncWithHttpInfo($name, $annotation_id, $out_folder = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putFileAttachmentAnnotationDataExtractRequest($name, $annotation_id, $out_folder, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFileAttachmentAnnotationDataExtract'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_folder The output folder. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFileAttachmentAnnotationDataExtractRequest($name, $annotation_id, $out_folder = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putFileAttachmentAnnotationDataExtract'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putFileAttachmentAnnotationDataExtract'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/fileattachment/{annotationId}/data/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_folder !== null) {
            $queryParams['outFolder'] = ObjectSerializer::toQueryValue($out_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFreeTextAnnotation
     *
     * Replace document free text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FreeTextAnnotationResponse
     */
    public function putFreeTextAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putFreeTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putFreeTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putFreeTextAnnotationWithHttpInfo
     *
     * Replace document free text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FreeTextAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFreeTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationResponse';
        $request = $this->putFreeTextAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FreeTextAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFreeTextAnnotationAsync
     *
     * Replace document free text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFreeTextAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putFreeTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFreeTextAnnotationAsyncWithHttpInfo
     *
     * Replace document free text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFreeTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FreeTextAnnotationResponse';
        $request = $this->putFreeTextAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFreeTextAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\FreeTextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFreeTextAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putFreeTextAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putFreeTextAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putFreeTextAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/freetext/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putHighlightAnnotation
     *
     * Replace document highlight annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\HighlightAnnotationResponse
     */
    public function putHighlightAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putHighlightAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putHighlightAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putHighlightAnnotationWithHttpInfo
     *
     * Replace document highlight annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\HighlightAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putHighlightAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationResponse';
        $request = $this->putHighlightAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\HighlightAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putHighlightAnnotationAsync
     *
     * Replace document highlight annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHighlightAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putHighlightAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putHighlightAnnotationAsyncWithHttpInfo
     *
     * Replace document highlight annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHighlightAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\HighlightAnnotationResponse';
        $request = $this->putHighlightAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putHighlightAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\HighlightAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putHighlightAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putHighlightAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putHighlightAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putHighlightAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/highlight/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putHtmlInStorageToPdf
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putHtmlInStorageToPdf($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putHtmlInStorageToPdfWithHttpInfo($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putHtmlInStorageToPdfWithHttpInfo($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putHtmlInStorageToPdfWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putHtmlInStorageToPdfWithHttpInfo($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putHtmlInStorageToPdfRequest($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putHtmlInStorageToPdfAsync
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHtmlInStorageToPdfAsync($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        return $this->putHtmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putHtmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert HTML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHtmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putHtmlInStorageToPdfRequest($name, $src_path, $html_file_name, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putHtmlInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.zip) (required)
     * @param  string $html_file_name Name of HTML file in ZIP. (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putHtmlInStorageToPdfRequest($name, $src_path, $html_file_name = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putHtmlInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putHtmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($html_file_name !== null) {
            $queryParams['htmlFileName'] = ObjectSerializer::toQueryValue($html_file_name);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageExtractAsGif
     *
     * Extract document image in GIF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageExtractAsGif($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImageExtractAsGifWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageExtractAsGifWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageExtractAsGifWithHttpInfo
     *
     * Extract document image in GIF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageExtractAsGifWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsGifRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageExtractAsGifAsync
     *
     * Extract document image in GIF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsGifAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImageExtractAsGifAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageExtractAsGifAsyncWithHttpInfo
     *
     * Extract document image in GIF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsGifAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsGifRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageExtractAsGif'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageExtractAsGifRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageExtractAsGif'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putImageExtractAsGif'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageExtractAsJpeg
     *
     * Extract document image in JPEG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageExtractAsJpeg($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImageExtractAsJpegWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageExtractAsJpegWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageExtractAsJpegWithHttpInfo
     *
     * Extract document image in JPEG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageExtractAsJpegWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsJpegRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageExtractAsJpegAsync
     *
     * Extract document image in JPEG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsJpegAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImageExtractAsJpegAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageExtractAsJpegAsyncWithHttpInfo
     *
     * Extract document image in JPEG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsJpegAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsJpegRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageExtractAsJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageExtractAsJpegRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageExtractAsJpeg'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putImageExtractAsJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageExtractAsPng
     *
     * Extract document image in PNG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageExtractAsPng($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImageExtractAsPngWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageExtractAsPngWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageExtractAsPngWithHttpInfo
     *
     * Extract document image in PNG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageExtractAsPngWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsPngRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageExtractAsPngAsync
     *
     * Extract document image in PNG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsPngAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImageExtractAsPngAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageExtractAsPngAsyncWithHttpInfo
     *
     * Extract document image in PNG format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsPngAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsPngRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageExtractAsPng'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageExtractAsPngRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageExtractAsPng'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putImageExtractAsPng'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageExtractAsTiff
     *
     * Extract document image in TIFF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageExtractAsTiff($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImageExtractAsTiffWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageExtractAsTiffWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageExtractAsTiffWithHttpInfo
     *
     * Extract document image in TIFF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageExtractAsTiffWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsTiffRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageExtractAsTiffAsync
     *
     * Extract document image in TIFF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsTiffAsync($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImageExtractAsTiffAsyncWithHttpInfo($name, $image_id, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageExtractAsTiffAsyncWithHttpInfo
     *
     * Extract document image in TIFF format to folder
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageExtractAsTiffAsyncWithHttpInfo($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageExtractAsTiffRequest($name, $image_id, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageExtractAsTiff'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id Image ID. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageExtractAsTiffRequest($name, $image_id, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageExtractAsTiff'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putImageExtractAsTiff'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}/extract/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImageInStorageToPdf
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImageInStorageToPdf($name, $image_templates, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putImageInStorageToPdfWithHttpInfo($name, $image_templates, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImageInStorageToPdfWithHttpInfo($name, $image_templates, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImageInStorageToPdfWithHttpInfo
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImageInStorageToPdfWithHttpInfo($name, $image_templates, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageInStorageToPdfRequest($name, $image_templates, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImageInStorageToPdfAsync
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageInStorageToPdfAsync($name, $image_templates, $dst_folder = null, $storage = null)
    {
        return $this->putImageInStorageToPdfAsyncWithHttpInfo($name, $image_templates, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImageInStorageToPdfAsyncWithHttpInfo
     *
     * Convert image file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImageInStorageToPdfAsyncWithHttpInfo($name, $image_templates, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImageInStorageToPdfRequest($name, $image_templates, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImageInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\ImageTemplatesRequest $image_templates Image templates (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImageInStorageToPdfRequest($name, $image_templates, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImageInStorageToPdf'
            );
        }
        // verify the required parameter 'image_templates' is set
        if ($image_templates === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_templates when calling putImageInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($image_templates)) {
            $_tempBody = $image_templates;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsGif
     *
     * Extract document images in GIF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImagesExtractAsGif($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImagesExtractAsGifWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImagesExtractAsGifWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImagesExtractAsGifWithHttpInfo
     *
     * Extract document images in GIF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsGifWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsGifRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsGifAsync
     *
     * Extract document images in GIF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsGifAsync($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsGifAsyncWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsGifAsyncWithHttpInfo
     *
     * Extract document images in GIF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsGifAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsGifRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsGif'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsGifRequest($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsGif'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsGif'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsJpeg
     *
     * Extract document images in JPEG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImagesExtractAsJpeg($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImagesExtractAsJpegWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImagesExtractAsJpegWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImagesExtractAsJpegWithHttpInfo
     *
     * Extract document images in JPEG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsJpegWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsJpegRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsJpegAsync
     *
     * Extract document images in JPEG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsJpegAsync($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsJpegAsyncWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsJpegAsyncWithHttpInfo
     *
     * Extract document images in JPEG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsJpegAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsJpegRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsJpegRequest($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsJpeg'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsPng
     *
     * Extract document images in PNG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImagesExtractAsPng($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImagesExtractAsPngWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImagesExtractAsPngWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImagesExtractAsPngWithHttpInfo
     *
     * Extract document images in PNG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsPngWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsPngRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsPngAsync
     *
     * Extract document images in PNG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsPngAsync($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsPngAsyncWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsPngAsyncWithHttpInfo
     *
     * Extract document images in PNG format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsPngAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsPngRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsPng'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsPngRequest($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsPng'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsPng'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putImagesExtractAsTiff
     *
     * Extract document images in TIFF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putImagesExtractAsTiff($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        try
        {
            list($response) = $this->putImagesExtractAsTiffWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putImagesExtractAsTiffWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putImagesExtractAsTiffWithHttpInfo
     *
     * Extract document images in TIFF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putImagesExtractAsTiffWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsTiffRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putImagesExtractAsTiffAsync
     *
     * Extract document images in TIFF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsTiffAsync($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        return $this->putImagesExtractAsTiffAsyncWithHttpInfo($name, $page_number, $width, $height, $storage, $folder, $dest_folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putImagesExtractAsTiffAsyncWithHttpInfo
     *
     * Extract document images in TIFF format to folder.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putImagesExtractAsTiffAsyncWithHttpInfo($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putImagesExtractAsTiffRequest($name, $page_number, $width, $height, $storage, $folder, $dest_folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putImagesExtractAsTiff'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $dest_folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putImagesExtractAsTiffRequest($name, $page_number, $width = null, $height = null, $storage = null, $folder = null, $dest_folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putImagesExtractAsTiff'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putImagesExtractAsTiff'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/images/extract/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($dest_folder !== null) {
            $queryParams['destFolder'] = ObjectSerializer::toQueryValue($dest_folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putInkAnnotation
     *
     * Replace document ink annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\InkAnnotationResponse
     */
    public function putInkAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putInkAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putInkAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putInkAnnotationWithHttpInfo
     *
     * Replace document ink annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\InkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putInkAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationResponse';
        $request = $this->putInkAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\InkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putInkAnnotationAsync
     *
     * Replace document ink annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInkAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putInkAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putInkAnnotationAsyncWithHttpInfo
     *
     * Replace document ink annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInkAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\InkAnnotationResponse';
        $request = $this->putInkAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putInkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\InkAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putInkAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putInkAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putInkAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putInkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/ink/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putLaTeXInStorageToPdf
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putLaTeXInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putLaTeXInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putLaTeXInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putLaTeXInStorageToPdfWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putLaTeXInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putLaTeXInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putLaTeXInStorageToPdfAsync
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLaTeXInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putLaTeXInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putLaTeXInStorageToPdfAsyncWithHttpInfo
     *
     * Convert LaTeX file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLaTeXInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putLaTeXInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putLaTeXInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.tex) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putLaTeXInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putLaTeXInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putLaTeXInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putLineAnnotation
     *
     * Replace document line annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LineAnnotationResponse
     */
    public function putLineAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putLineAnnotationWithHttpInfo
     *
     * Replace document line annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationResponse';
        $request = $this->putLineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putLineAnnotationAsync
     *
     * Replace document line annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLineAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putLineAnnotationAsyncWithHttpInfo
     *
     * Replace document line annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LineAnnotationResponse';
        $request = $this->putLineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putLineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\LineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putLineAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putLineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putLineAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putLineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/line/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putLinkAnnotation
     *
     * Replace document page link annotations
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\LinkAnnotationResponse
     */
    public function putLinkAnnotation($name, $link_id, $link, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putLinkAnnotationWithHttpInfo($name, $link_id, $link, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putLinkAnnotationWithHttpInfo($name, $link_id, $link, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putLinkAnnotationWithHttpInfo
     *
     * Replace document page link annotations
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\LinkAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putLinkAnnotationWithHttpInfo($name, $link_id, $link, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->putLinkAnnotationRequest($name, $link_id, $link, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\LinkAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putLinkAnnotationAsync
     *
     * Replace document page link annotations
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLinkAnnotationAsync($name, $link_id, $link, $storage = null, $folder = null)
    {
        return $this->putLinkAnnotationAsyncWithHttpInfo($name, $link_id, $link, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putLinkAnnotationAsyncWithHttpInfo
     *
     * Replace document page link annotations
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putLinkAnnotationAsyncWithHttpInfo($name, $link_id, $link, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\LinkAnnotationResponse';
        $request = $this->putLinkAnnotationRequest($name, $link_id, $link, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putLinkAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $link_id The link ID. (required)
     * @param  \Aspose\PDF\Model\LinkAnnotation $link Link anotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putLinkAnnotationRequest($name, $link_id, $link, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putLinkAnnotation'
            );
        }
        // verify the required parameter 'link_id' is set
        if ($link_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_id when calling putLinkAnnotation'
            );
        }
        // verify the required parameter 'link' is set
        if ($link === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link when calling putLinkAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/links/{linkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'linkId' . '}',
                ObjectSerializer::toPathValue($link_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($link)) {
            $_tempBody = $link;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMergeDocuments
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentResponse
     */
    public function putMergeDocuments($name, $merge_documents = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putMergeDocumentsWithHttpInfo($name, $merge_documents, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putMergeDocumentsWithHttpInfo($name, $merge_documents, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putMergeDocumentsWithHttpInfo
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMergeDocumentsWithHttpInfo($name, $merge_documents = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putMergeDocumentsRequest($name, $merge_documents, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putMergeDocumentsAsync
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMergeDocumentsAsync($name, $merge_documents = null, $storage = null, $folder = null)
    {
        return $this->putMergeDocumentsAsyncWithHttpInfo($name, $merge_documents, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMergeDocumentsAsyncWithHttpInfo
     *
     * Merge a list of documents.
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMergeDocumentsAsyncWithHttpInfo($name, $merge_documents = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentResponse';
        $request = $this->putMergeDocumentsRequest($name, $merge_documents, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMergeDocuments'
     *
     * @param  string $name Resulting documen name. (required)
     * @param  \Aspose\PDF\Model\MergeDocuments $merge_documents with a list of documents. (optional)
     * @param  string $storage Resulting document storage. (optional)
     * @param  string $folder Resulting document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMergeDocumentsRequest($name, $merge_documents = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putMergeDocuments'
            );
        }

        $resourcePath = '/pdf/{name}/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($merge_documents)) {
            $_tempBody = $merge_documents;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMhtInStorageToPdf
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putMhtInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putMhtInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putMhtInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putMhtInStorageToPdfWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMhtInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putMhtInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putMhtInStorageToPdfAsync
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMhtInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putMhtInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMhtInStorageToPdfAsyncWithHttpInfo
     *
     * Convert MHT file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMhtInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putMhtInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMhtInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.mht) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMhtInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putMhtInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putMhtInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/mht';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMovieAnnotation
     *
     * Replace document movie annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\MovieAnnotationResponse
     */
    public function putMovieAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putMovieAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putMovieAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putMovieAnnotationWithHttpInfo
     *
     * Replace document movie annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\MovieAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMovieAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\MovieAnnotationResponse';
        $request = $this->putMovieAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\MovieAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putMovieAnnotationAsync
     *
     * Replace document movie annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMovieAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putMovieAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMovieAnnotationAsyncWithHttpInfo
     *
     * Replace document movie annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMovieAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\MovieAnnotationResponse';
        $request = $this->putMovieAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMovieAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\MovieAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMovieAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putMovieAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putMovieAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putMovieAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/movie/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageAddStamp
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageAddStamp($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageAddStampWithHttpInfo
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageAddStampWithHttpInfo($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageAddStampRequest($name, $page_number, $stamp, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageAddStampAsync
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageAddStampAsync($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        return $this->putPageAddStampAsyncWithHttpInfo($name, $page_number, $stamp, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageAddStampAsyncWithHttpInfo
     *
     * Add page stamp.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageAddStampAsyncWithHttpInfo($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageAddStampRequest($name, $page_number, $stamp, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageAddStamp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  \Aspose\PDF\Model\Stamp $stamp with data. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageAddStampRequest($name, $page_number, $stamp, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageAddStamp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageAddStamp'
            );
        }
        // verify the required parameter 'stamp' is set
        if ($stamp === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamp when calling putPageAddStamp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/stamp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($stamp)) {
            $_tempBody = $stamp;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToBmp
     *
     * Convert document page to bmp image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToBmp($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToBmpWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToBmpWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToBmpWithHttpInfo
     *
     * Convert document page to bmp image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToBmpWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToBmpRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToBmpAsync
     *
     * Convert document page to bmp image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToBmpAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToBmpAsyncWithHttpInfo
     *
     * Convert document page to bmp image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToBmpAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToBmpRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToBmp'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToBmpRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToBmp'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToBmp'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToBmp'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/bmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToEmf
     *
     * Convert document page to emf image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToEmf($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToEmfWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToEmfWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToEmfWithHttpInfo
     *
     * Convert document page to emf image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToEmfWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToEmfRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToEmfAsync
     *
     * Convert document page to emf image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToEmfAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToEmfAsyncWithHttpInfo
     *
     * Convert document page to emf image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToEmfAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToEmfRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToEmf'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToEmfRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToEmf'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToEmf'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToEmf'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/emf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToGif
     *
     * Convert document page to gif image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToGif($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToGifWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToGifWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToGifWithHttpInfo
     *
     * Convert document page to gif image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToGifWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToGifRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToGifAsync
     *
     * Convert document page to gif image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToGifAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToGifAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToGifAsyncWithHttpInfo
     *
     * Convert document page to gif image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToGifAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToGifRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToGif'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToGifRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToGif'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToGif'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToGif'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToJpeg
     *
     * Convert document page to Jpeg image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToJpeg($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToJpegWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToJpegWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToJpegWithHttpInfo
     *
     * Convert document page to Jpeg image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToJpegWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToJpegRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToJpegAsync
     *
     * Convert document page to Jpeg image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToJpegAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToJpegAsyncWithHttpInfo
     *
     * Convert document page to Jpeg image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToJpegAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToJpegRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToJpeg'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToJpegRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToJpeg'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToJpeg'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToJpeg'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/jpeg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToPng
     *
     * Convert document page to png image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToPng($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToPngWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToPngWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToPngWithHttpInfo
     *
     * Convert document page to png image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToPngWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToPngRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToPngAsync
     *
     * Convert document page to png image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToPngAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToPngAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToPngAsyncWithHttpInfo
     *
     * Convert document page to png image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToPngAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToPngRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToPng'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToPngRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToPng'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToPng'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToPng'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPageConvertToTiff
     *
     * Convert document page to Tiff image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPageConvertToTiff($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPageConvertToTiffWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPageConvertToTiffWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPageConvertToTiffWithHttpInfo
     *
     * Convert document page to Tiff image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPageConvertToTiffWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToTiffRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPageConvertToTiffAsync
     *
     * Convert document page to Tiff image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToTiffAsync($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        return $this->putPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $out_path, $width, $height, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPageConvertToTiffAsyncWithHttpInfo
     *
     * Convert document page to Tiff image and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPageConvertToTiffAsyncWithHttpInfo($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPageConvertToTiffRequest($name, $page_number, $out_path, $width, $height, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPageConvertToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  int $page_number The page number. (required)
     * @param  string $out_path The out path of result image. (required)
     * @param  int $width The converted image width. (optional)
     * @param  int $height The converted image height. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPageConvertToTiffRequest($name, $page_number, $out_path, $width = null, $height = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPageConvertToTiff'
            );
        }
        // verify the required parameter 'page_number' is set
        if ($page_number === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_number when calling putPageConvertToTiff'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPageConvertToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/pages/{pageNumber}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($page_number !== null) {
            $resourcePath = str_replace(
                '{' . 'pageNumber' . '}',
                ObjectSerializer::toPathValue($page_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPclInStorageToPdf
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPclInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPclInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPclInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPclInStorageToPdfWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPclInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPclInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPclInStorageToPdfAsync
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPclInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putPclInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPclInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PCL file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPclInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPclInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPclInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.pcl) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPclInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPclInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putPclInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/pcl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToDoc
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToDoc($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToDocWithHttpInfo
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToDocWithHttpInfo($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToDocRequest($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToDocAsync
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToDocAsync($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToDocAsyncWithHttpInfo($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToDocAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to DOC format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToDocAsyncWithHttpInfo($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToDocRequest($out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToDoc'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToDocRequest($out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToDoc'
            );
        }

        $resourcePath = '/pdf/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToEpub
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToEpub($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToEpubWithHttpInfo($out_path, $content_recognition_mode, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToEpubWithHttpInfo($out_path, $content_recognition_mode, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToEpubWithHttpInfo
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToEpubWithHttpInfo($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToEpubRequest($out_path, $content_recognition_mode, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToEpubAsync
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToEpubAsync($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToEpubAsyncWithHttpInfo($out_path, $content_recognition_mode, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToEpubAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to EPUB format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToEpubAsyncWithHttpInfo($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToEpubRequest($out_path, $content_recognition_mode, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToEpub'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToEpubRequest($out_path, $content_recognition_mode = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToEpub'
            );
        }

        $resourcePath = '/pdf/convert/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($content_recognition_mode !== null) {
            $queryParams['contentRecognitionMode'] = ObjectSerializer::toQueryValue($content_recognition_mode);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToHtml
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToHtml($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToHtmlWithHttpInfo($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToHtmlWithHttpInfo($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToHtmlWithHttpInfo
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToHtmlWithHttpInfo($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToHtmlRequest($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToHtmlAsync
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToHtmlAsync($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToHtmlAsyncWithHttpInfo($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToHtmlAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to Html format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToHtmlAsyncWithHttpInfo($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToHtmlRequest($out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToHtml'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToHtmlRequest($out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToHtml'
            );
        }

        $resourcePath = '/pdf/convert/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($additional_margin_width_in_points !== null) {
            $queryParams['additionalMarginWidthInPoints'] = ObjectSerializer::toQueryValue($additional_margin_width_in_points);
        }
        // query params
        if ($compress_svg_graphics_if_any !== null) {
            $queryParams['compressSvgGraphicsIfAny'] = ObjectSerializer::toQueryValue($compress_svg_graphics_if_any);
        }
        // query params
        if ($convert_marked_content_to_layers !== null) {
            $queryParams['convertMarkedContentToLayers'] = ObjectSerializer::toQueryValue($convert_marked_content_to_layers);
        }
        // query params
        if ($default_font_name !== null) {
            $queryParams['defaultFontName'] = ObjectSerializer::toQueryValue($default_font_name);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($fixed_layout !== null) {
            $queryParams['fixedLayout'] = ObjectSerializer::toQueryValue($fixed_layout);
        }
        // query params
        if ($image_resolution !== null) {
            $queryParams['imageResolution'] = ObjectSerializer::toQueryValue($image_resolution);
        }
        // query params
        if ($minimal_line_width !== null) {
            $queryParams['minimalLineWidth'] = ObjectSerializer::toQueryValue($minimal_line_width);
        }
        // query params
        if ($prevent_glyphs_grouping !== null) {
            $queryParams['preventGlyphsGrouping'] = ObjectSerializer::toQueryValue($prevent_glyphs_grouping);
        }
        // query params
        if ($split_css_into_pages !== null) {
            $queryParams['splitCssIntoPages'] = ObjectSerializer::toQueryValue($split_css_into_pages);
        }
        // query params
        if ($split_into_pages !== null) {
            $queryParams['splitIntoPages'] = ObjectSerializer::toQueryValue($split_into_pages);
        }
        // query params
        if ($use_z_order !== null) {
            $queryParams['useZOrder'] = ObjectSerializer::toQueryValue($use_z_order);
        }
        // query params
        if ($antialiasing_processing !== null) {
            $queryParams['antialiasingProcessing'] = ObjectSerializer::toQueryValue($antialiasing_processing);
        }
        // query params
        if ($css_class_names_prefix !== null) {
            $queryParams['cssClassNamesPrefix'] = ObjectSerializer::toQueryValue($css_class_names_prefix);
        }
        // query params
        if (is_array($explicit_list_of_saved_pages)) {
            $explicit_list_of_saved_pages = ObjectSerializer::serializeCollection($explicit_list_of_saved_pages, 'multi', true);
        }
        if ($explicit_list_of_saved_pages !== null) {
            $queryParams['explicitListOfSavedPages'] = ObjectSerializer::toQueryValue($explicit_list_of_saved_pages);
        }
        // query params
        if ($font_encoding_strategy !== null) {
            $queryParams['fontEncodingStrategy'] = ObjectSerializer::toQueryValue($font_encoding_strategy);
        }
        // query params
        if ($font_saving_mode !== null) {
            $queryParams['fontSavingMode'] = ObjectSerializer::toQueryValue($font_saving_mode);
        }
        // query params
        if ($html_markup_generation_mode !== null) {
            $queryParams['htmlMarkupGenerationMode'] = ObjectSerializer::toQueryValue($html_markup_generation_mode);
        }
        // query params
        if ($letters_positioning_method !== null) {
            $queryParams['lettersPositioningMethod'] = ObjectSerializer::toQueryValue($letters_positioning_method);
        }
        // query params
        if ($pages_flow_type_depends_on_viewers_screen_size !== null) {
            $queryParams['pagesFlowTypeDependsOnViewersScreenSize'] = ObjectSerializer::toQueryValue($pages_flow_type_depends_on_viewers_screen_size);
        }
        // query params
        if ($parts_embedding_mode !== null) {
            $queryParams['partsEmbeddingMode'] = ObjectSerializer::toQueryValue($parts_embedding_mode);
        }
        // query params
        if ($raster_images_saving_mode !== null) {
            $queryParams['rasterImagesSavingMode'] = ObjectSerializer::toQueryValue($raster_images_saving_mode);
        }
        // query params
        if ($remove_empty_areas_on_top_and_bottom !== null) {
            $queryParams['removeEmptyAreasOnTopAndBottom'] = ObjectSerializer::toQueryValue($remove_empty_areas_on_top_and_bottom);
        }
        // query params
        if ($save_shadowed_texts_as_transparent_texts !== null) {
            $queryParams['saveShadowedTextsAsTransparentTexts'] = ObjectSerializer::toQueryValue($save_shadowed_texts_as_transparent_texts);
        }
        // query params
        if ($save_transparent_texts !== null) {
            $queryParams['saveTransparentTexts'] = ObjectSerializer::toQueryValue($save_transparent_texts);
        }
        // query params
        if ($special_folder_for_all_images !== null) {
            $queryParams['specialFolderForAllImages'] = ObjectSerializer::toQueryValue($special_folder_for_all_images);
        }
        // query params
        if ($special_folder_for_svg_images !== null) {
            $queryParams['specialFolderForSvgImages'] = ObjectSerializer::toQueryValue($special_folder_for_svg_images);
        }
        // query params
        if ($try_save_text_underlining_and_strikeouting_in_css !== null) {
            $queryParams['trySaveTextUnderliningAndStrikeoutingInCss'] = ObjectSerializer::toQueryValue($try_save_text_underlining_and_strikeouting_in_css);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToLaTeX
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToLaTeX($out_path, $pages_count = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToLaTeXWithHttpInfo($out_path, $pages_count, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToLaTeXWithHttpInfo($out_path, $pages_count, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToLaTeXWithHttpInfo
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToLaTeXWithHttpInfo($out_path, $pages_count = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToLaTeXRequest($out_path, $pages_count, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToLaTeXAsync
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToLaTeXAsync($out_path, $pages_count = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToLaTeXAsyncWithHttpInfo($out_path, $pages_count, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToLaTeXAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to LaTeX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToLaTeXAsyncWithHttpInfo($out_path, $pages_count = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToLaTeXRequest($out_path, $pages_count, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToLaTeX'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToLaTeXRequest($out_path, $pages_count = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToLaTeX'
            );
        }

        $resourcePath = '/pdf/convert/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($pages_count !== null) {
            $queryParams['pagesCount'] = ObjectSerializer::toQueryValue($pages_count);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToMobiXml
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToMobiXml($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToMobiXmlWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToMobiXmlWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToMobiXmlWithHttpInfo
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToMobiXmlWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToMobiXmlRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToMobiXmlAsync
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToMobiXmlAsync($out_path, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToMobiXmlAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToMobiXmlAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to MOBIXML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToMobiXmlAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToMobiXmlRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToMobiXml'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToMobiXmlRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToMobiXml'
            );
        }

        $resourcePath = '/pdf/convert/mobixml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToPdfA
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToPdfA($out_path, $type, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToPdfAWithHttpInfo
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToPdfAWithHttpInfo($out_path, $type, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToPdfARequest($out_path, $type, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToPdfAAsync
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPdfAAsync($out_path, $type, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToPdfAAsyncWithHttpInfo($out_path, $type, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to PdfA format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPdfAAsyncWithHttpInfo($out_path, $type, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToPdfARequest($out_path, $type, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToPdfA'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToPdfARequest($out_path, $type, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling putPdfInRequestToPdfA'
            );
        }

        $resourcePath = '/pdf/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToPptx
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToPptx($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToPptxWithHttpInfo($out_path, $separate_images, $slides_as_images, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToPptxWithHttpInfo($out_path, $separate_images, $slides_as_images, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToPptxWithHttpInfo
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToPptxWithHttpInfo($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToPptxRequest($out_path, $separate_images, $slides_as_images, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToPptxAsync
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPptxAsync($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToPptxAsyncWithHttpInfo($out_path, $separate_images, $slides_as_images, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToPptxAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to PPTX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToPptxAsyncWithHttpInfo($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToPptxRequest($out_path, $separate_images, $slides_as_images, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToPptx'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToPptxRequest($out_path, $separate_images = null, $slides_as_images = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToPptx'
            );
        }

        $resourcePath = '/pdf/convert/pptx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($separate_images !== null) {
            $queryParams['separateImages'] = ObjectSerializer::toQueryValue($separate_images);
        }
        // query params
        if ($slides_as_images !== null) {
            $queryParams['slidesAsImages'] = ObjectSerializer::toQueryValue($slides_as_images);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToSvg
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToSvg($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToSvgWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToSvgWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToSvgWithHttpInfo
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToSvgWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToSvgRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToSvgAsync
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToSvgAsync($out_path, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToSvgAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to SVG format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToSvgAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToSvgRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToSvg'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToSvgRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToSvg'
            );
        }

        $resourcePath = '/pdf/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToTiff
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToTiff($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToTiffWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToTiffWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToTiffWithHttpInfo
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToTiffWithHttpInfo($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToTiffRequest($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToTiffAsync
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToTiffAsync($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToTiffAsyncWithHttpInfo($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to TIFF format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToTiffAsyncWithHttpInfo($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToTiffRequest($out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToTiff'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToTiffRequest($out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToTiff'
            );
        }

        $resourcePath = '/pdf/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXls
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToXls($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToXlsWithHttpInfo
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXlsWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXlsAsync
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsAsync($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToXlsAsyncWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XLS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsAsyncWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXls'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXlsRequest($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXls'
            );
        }

        $resourcePath = '/pdf/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXlsx
     *
     * Converts PDF document (in request content) to XLSX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToXlsx($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToXlsxWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToXlsxWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToXlsxWithHttpInfo
     *
     * Converts PDF document (in request content) to XLSX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXlsxWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXlsxRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXlsxAsync
     *
     * Converts PDF document (in request content) to XLSX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsxAsync($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToXlsxAsyncWithHttpInfo($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXlsxAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XLSX format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXlsxAsyncWithHttpInfo($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXlsxRequest($out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXlsx'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXlsxRequest($out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXlsx'
            );
        }

        $resourcePath = '/pdf/convert/xlsx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXml
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToXml($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToXmlWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToXmlWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToXmlWithHttpInfo
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXmlWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXmlRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXmlAsync
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXmlAsync($out_path, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToXmlAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXmlAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XML format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXmlAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXmlRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXml'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXmlRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXml'
            );
        }

        $resourcePath = '/pdf/convert/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInRequestToXps
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInRequestToXps($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putPdfInRequestToXpsWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInRequestToXpsWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInRequestToXpsWithHttpInfo
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInRequestToXpsWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXpsRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInRequestToXpsAsync
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXpsAsync($out_path, $storage = null, $file = null)
    {
        return $this->putPdfInRequestToXpsAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInRequestToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (in request content) to XPS format and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInRequestToXpsAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInRequestToXpsRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInRequestToXps'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInRequestToXpsRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInRequestToXps'
            );
        }

        $resourcePath = '/pdf/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToDoc
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToDoc($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToDocWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToDocWithHttpInfo($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToDocAsync
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToDocAsync($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToDocAsyncWithHttpInfo($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToDocAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to DOC format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToDocAsyncWithHttpInfo($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end, $format, $image_resolution_x, $image_resolution_y, $max_distance_between_text_lines, $mode, $recognize_bullets, $relative_horizontal_proximity, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToDoc'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.doc) (required)
     * @param  bool $add_return_to_line_end Add return to line end. (optional)
     * @param  string $format Allows to specify .doc or .docx file format. (optional)
     * @param  int $image_resolution_x Image resolution X. (optional)
     * @param  int $image_resolution_y Image resolution Y. (optional)
     * @param  double $max_distance_between_text_lines Max distance between text lines. (optional)
     * @param  string $mode Allows to control how a PDF document is converted into a word processing document. (optional)
     * @param  bool $recognize_bullets Recognize bullets. (optional)
     * @param  double $relative_horizontal_proximity Relative horizontal proximity. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToDocRequest($name, $out_path, $add_return_to_line_end = null, $format = null, $image_resolution_x = null, $image_resolution_y = null, $max_distance_between_text_lines = null, $mode = null, $recognize_bullets = null, $relative_horizontal_proximity = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToDoc'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToDoc'
            );
        }

        $resourcePath = '/pdf/{name}/convert/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($add_return_to_line_end !== null) {
            $queryParams['addReturnToLineEnd'] = ObjectSerializer::toQueryValue($add_return_to_line_end);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($image_resolution_x !== null) {
            $queryParams['imageResolutionX'] = ObjectSerializer::toQueryValue($image_resolution_x);
        }
        // query params
        if ($image_resolution_y !== null) {
            $queryParams['imageResolutionY'] = ObjectSerializer::toQueryValue($image_resolution_y);
        }
        // query params
        if ($max_distance_between_text_lines !== null) {
            $queryParams['maxDistanceBetweenTextLines'] = ObjectSerializer::toQueryValue($max_distance_between_text_lines);
        }
        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($recognize_bullets !== null) {
            $queryParams['recognizeBullets'] = ObjectSerializer::toQueryValue($recognize_bullets);
        }
        // query params
        if ($relative_horizontal_proximity !== null) {
            $queryParams['relativeHorizontalProximity'] = ObjectSerializer::toQueryValue($relative_horizontal_proximity);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToEpub
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToEpub($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToEpubWithHttpInfo($name, $out_path, $content_recognition_mode, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToEpubWithHttpInfo($name, $out_path, $content_recognition_mode, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToEpubWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToEpubWithHttpInfo($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToEpubRequest($name, $out_path, $content_recognition_mode, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToEpubAsync
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToEpubAsync($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToEpubAsyncWithHttpInfo($name, $out_path, $content_recognition_mode, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToEpubAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to EPUB format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToEpubAsyncWithHttpInfo($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToEpubRequest($name, $out_path, $content_recognition_mode, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToEpub'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.epub) (required)
     * @param  string $content_recognition_mode Property tunes conversion for this or that desirable method of recognition of content. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToEpubRequest($name, $out_path, $content_recognition_mode = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToEpub'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToEpub'
            );
        }

        $resourcePath = '/pdf/{name}/convert/epub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($content_recognition_mode !== null) {
            $queryParams['contentRecognitionMode'] = ObjectSerializer::toQueryValue($content_recognition_mode);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToHtml
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToHtml($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToHtmlWithHttpInfo($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToHtmlWithHttpInfo($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToHtmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToHtmlWithHttpInfo($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToHtmlRequest($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToHtmlAsync
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToHtmlAsync($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToHtmlAsyncWithHttpInfo($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToHtmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to Html format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToHtmlAsyncWithHttpInfo($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToHtmlRequest($name, $out_path, $additional_margin_width_in_points, $compress_svg_graphics_if_any, $convert_marked_content_to_layers, $default_font_name, $document_type, $fixed_layout, $image_resolution, $minimal_line_width, $prevent_glyphs_grouping, $split_css_into_pages, $split_into_pages, $use_z_order, $antialiasing_processing, $css_class_names_prefix, $explicit_list_of_saved_pages, $font_encoding_strategy, $font_saving_mode, $html_markup_generation_mode, $letters_positioning_method, $pages_flow_type_depends_on_viewers_screen_size, $parts_embedding_mode, $raster_images_saving_mode, $remove_empty_areas_on_top_and_bottom, $save_shadowed_texts_as_transparent_texts, $save_transparent_texts, $special_folder_for_all_images, $special_folder_for_svg_images, $try_save_text_underlining_and_strikeouting_in_css, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToHtml'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.html) (required)
     * @param  int $additional_margin_width_in_points Defines width of margin that will be forcibly left around that output HTML-areas. (optional)
     * @param  bool $compress_svg_graphics_if_any The flag that indicates whether found SVG graphics(if any) will be compressed(zipped) into SVGZ format during saving. (optional)
     * @param  bool $convert_marked_content_to_layers If attribute ConvertMarkedContentToLayers set to true then an all elements inside a PDF marked content (layer) will be put into an HTML div with \&quot;data-pdflayer\&quot; attribute specifying a layer name. This layer name will be extracted from optional properties of PDF marked content. If this attribute is false (by default) then no any layers will be created from PDF marked content. (optional)
     * @param  string $default_font_name Specifies the name of an installed font which is used to substitute any document font that is not embedded and not installed in the system. If null then default substitution font is used. (optional)
     * @param  string $document_type Result document type. (optional)
     * @param  bool $fixed_layout The value indicating whether that HTML is created as fixed layout. (optional)
     * @param  int $image_resolution Resolution for image rendering. (optional)
     * @param  int $minimal_line_width This attribute sets minimal width of graphic path line. If thickness of line is less than 1px Adobe Acrobat rounds it to this value. So this attribute can be used to emulate this behavior for HTML browsers. (optional)
     * @param  bool $prevent_glyphs_grouping This attribute switch on the mode when text glyphs will not be grouped into words and strings This mode allows to keep maximum precision during positioning of glyphs on the page and it can be used for conversion documents with music notes or glyphs that should be placed separately each other. This parameter will be applied to document only when the value of FixedLayout attribute is true. (optional)
     * @param  bool $split_css_into_pages When multipage-mode selected(i.e &#39;SplitIntoPages&#39; is &#39;true&#39;), then this attribute defines whether should be created separate CSS-file for each result HTML page. (optional)
     * @param  bool $split_into_pages The flag that indicates whether each page of source document will be converted into it&#39;s own target HTML document, i.e whether result HTML will be splitted into several HTML-pages. (optional)
     * @param  bool $use_z_order If attribute UseZORder set to true, graphics and text are added to resultant HTML document accordingly Z-order in original PDF document. If this attribute is false all graphics is put as single layer which may cause some unnecessary effects for overlapped objects. (optional)
     * @param  string $antialiasing_processing The parameter defines required antialiasing measures during conversion of compound background images from PDF to HTML. (optional)
     * @param  string $css_class_names_prefix When PDFtoHTML converter generates result CSSs, CSS class names (something like \&quot;.stl_01 {}\&quot; ... \&quot;.stl_NN {}) are generated and used in result CSS. This property allows forcibly set class name prefix. (optional)
     * @param  int[] $explicit_list_of_saved_pages With this property You can explicitely define what pages of document should be converted. Pages in this list must have 1-based numbers. I.e. valid numbers of pages must be taken from range (1...[NumberOfPagesInConvertedDocument]) Order of appearing of pages in this list does not affect their order in result HTML page(s) - in result pages allways will go in order in which they are present in source PDF. (optional)
     * @param  string $font_encoding_strategy Defines encoding special rule to tune PDF decoding for current document. (optional)
     * @param  string $font_saving_mode Defines font saving mode that will be used during saving of PDF to desirable format. (optional)
     * @param  string $html_markup_generation_mode Sometimes specific reqirments to generation of HTML markup are present. This parameter defines HTML preparing modes that can be used during conversion of PDF to HTML to match such specific requirments. (optional)
     * @param  string $letters_positioning_method The mode of positioning of letters in words in result HTML. (optional)
     * @param  bool $pages_flow_type_depends_on_viewers_screen_size If attribute &#39;SplitOnPages&#x3D;false&#39;, than whole HTML representing all input PDF pages will be put into one big result HTML file. This flag defines whether result HTML will be generated in such way that flow of areas that represent PDF pages in result HTML will depend on screen resolution of viewer. (optional)
     * @param  string $parts_embedding_mode It defines whether referenced files (HTML, Fonts,Images, CSSes) will be embedded into main HTML file or will be generated as apart binary entities. (optional)
     * @param  string $raster_images_saving_mode Converted PDF can contain raster images This parameter defines how they should be handled during conversion of PDF to HTML. (optional)
     * @param  bool $remove_empty_areas_on_top_and_bottom Defines whether in created HTML will be removed top and bottom empty area without any content (if any). (optional)
     * @param  bool $save_shadowed_texts_as_transparent_texts Pdf can contain texts that are shadowed by another elements (f.e. by images) but can be selected to clipboard in Acrobat Reader (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML to mimic behaviour of Acrobat Reader (othervise such texts are usually saved as hidden, not available for copying to clipboard). (optional)
     * @param  bool $save_transparent_texts Pdf can contain transparent texts that can be selected to clipboard (usually it happen when document contains images and OCRed texts extracted from it). This settings tells to converter whether we need save such texts as transparent selectable texts in result HTML. (optional)
     * @param  string $special_folder_for_all_images The path to directory to which must be saved any images if they are encountered during saving of document as HTML. If parameter is empty or null then image files(if any) wil be saved together with other files linked to HTML It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  string $special_folder_for_svg_images The path to directory to which must be saved only SVG-images if they are encountered during saving of document as HTML. If parameter is empty or null then SVG files(if any) wil be saved together with other image-files (near to output file) or in special folder for images (if it specified in SpecialImagesFolderIfAny option). It does not affect anything if CustomImageSavingStrategy property was successfully used to process relevant image file. (optional)
     * @param  bool $try_save_text_underlining_and_strikeouting_in_css PDF itself does not contain underlining markers for texts. It emulated with line situated under text. This option allows converter try guess that this or that line is a text&#39;s underlining and put this info into CSS instead of drawing of underlining graphically. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToHtmlRequest($name, $out_path, $additional_margin_width_in_points = null, $compress_svg_graphics_if_any = null, $convert_marked_content_to_layers = null, $default_font_name = null, $document_type = null, $fixed_layout = null, $image_resolution = null, $minimal_line_width = null, $prevent_glyphs_grouping = null, $split_css_into_pages = null, $split_into_pages = null, $use_z_order = null, $antialiasing_processing = null, $css_class_names_prefix = null, $explicit_list_of_saved_pages = null, $font_encoding_strategy = null, $font_saving_mode = null, $html_markup_generation_mode = null, $letters_positioning_method = null, $pages_flow_type_depends_on_viewers_screen_size = null, $parts_embedding_mode = null, $raster_images_saving_mode = null, $remove_empty_areas_on_top_and_bottom = null, $save_shadowed_texts_as_transparent_texts = null, $save_transparent_texts = null, $special_folder_for_all_images = null, $special_folder_for_svg_images = null, $try_save_text_underlining_and_strikeouting_in_css = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToHtml'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToHtml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($additional_margin_width_in_points !== null) {
            $queryParams['additionalMarginWidthInPoints'] = ObjectSerializer::toQueryValue($additional_margin_width_in_points);
        }
        // query params
        if ($compress_svg_graphics_if_any !== null) {
            $queryParams['compressSvgGraphicsIfAny'] = ObjectSerializer::toQueryValue($compress_svg_graphics_if_any);
        }
        // query params
        if ($convert_marked_content_to_layers !== null) {
            $queryParams['convertMarkedContentToLayers'] = ObjectSerializer::toQueryValue($convert_marked_content_to_layers);
        }
        // query params
        if ($default_font_name !== null) {
            $queryParams['defaultFontName'] = ObjectSerializer::toQueryValue($default_font_name);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($fixed_layout !== null) {
            $queryParams['fixedLayout'] = ObjectSerializer::toQueryValue($fixed_layout);
        }
        // query params
        if ($image_resolution !== null) {
            $queryParams['imageResolution'] = ObjectSerializer::toQueryValue($image_resolution);
        }
        // query params
        if ($minimal_line_width !== null) {
            $queryParams['minimalLineWidth'] = ObjectSerializer::toQueryValue($minimal_line_width);
        }
        // query params
        if ($prevent_glyphs_grouping !== null) {
            $queryParams['preventGlyphsGrouping'] = ObjectSerializer::toQueryValue($prevent_glyphs_grouping);
        }
        // query params
        if ($split_css_into_pages !== null) {
            $queryParams['splitCssIntoPages'] = ObjectSerializer::toQueryValue($split_css_into_pages);
        }
        // query params
        if ($split_into_pages !== null) {
            $queryParams['splitIntoPages'] = ObjectSerializer::toQueryValue($split_into_pages);
        }
        // query params
        if ($use_z_order !== null) {
            $queryParams['useZOrder'] = ObjectSerializer::toQueryValue($use_z_order);
        }
        // query params
        if ($antialiasing_processing !== null) {
            $queryParams['antialiasingProcessing'] = ObjectSerializer::toQueryValue($antialiasing_processing);
        }
        // query params
        if ($css_class_names_prefix !== null) {
            $queryParams['cssClassNamesPrefix'] = ObjectSerializer::toQueryValue($css_class_names_prefix);
        }
        // query params
        if (is_array($explicit_list_of_saved_pages)) {
            $explicit_list_of_saved_pages = ObjectSerializer::serializeCollection($explicit_list_of_saved_pages, 'multi', true);
        }
        if ($explicit_list_of_saved_pages !== null) {
            $queryParams['explicitListOfSavedPages'] = ObjectSerializer::toQueryValue($explicit_list_of_saved_pages);
        }
        // query params
        if ($font_encoding_strategy !== null) {
            $queryParams['fontEncodingStrategy'] = ObjectSerializer::toQueryValue($font_encoding_strategy);
        }
        // query params
        if ($font_saving_mode !== null) {
            $queryParams['fontSavingMode'] = ObjectSerializer::toQueryValue($font_saving_mode);
        }
        // query params
        if ($html_markup_generation_mode !== null) {
            $queryParams['htmlMarkupGenerationMode'] = ObjectSerializer::toQueryValue($html_markup_generation_mode);
        }
        // query params
        if ($letters_positioning_method !== null) {
            $queryParams['lettersPositioningMethod'] = ObjectSerializer::toQueryValue($letters_positioning_method);
        }
        // query params
        if ($pages_flow_type_depends_on_viewers_screen_size !== null) {
            $queryParams['pagesFlowTypeDependsOnViewersScreenSize'] = ObjectSerializer::toQueryValue($pages_flow_type_depends_on_viewers_screen_size);
        }
        // query params
        if ($parts_embedding_mode !== null) {
            $queryParams['partsEmbeddingMode'] = ObjectSerializer::toQueryValue($parts_embedding_mode);
        }
        // query params
        if ($raster_images_saving_mode !== null) {
            $queryParams['rasterImagesSavingMode'] = ObjectSerializer::toQueryValue($raster_images_saving_mode);
        }
        // query params
        if ($remove_empty_areas_on_top_and_bottom !== null) {
            $queryParams['removeEmptyAreasOnTopAndBottom'] = ObjectSerializer::toQueryValue($remove_empty_areas_on_top_and_bottom);
        }
        // query params
        if ($save_shadowed_texts_as_transparent_texts !== null) {
            $queryParams['saveShadowedTextsAsTransparentTexts'] = ObjectSerializer::toQueryValue($save_shadowed_texts_as_transparent_texts);
        }
        // query params
        if ($save_transparent_texts !== null) {
            $queryParams['saveTransparentTexts'] = ObjectSerializer::toQueryValue($save_transparent_texts);
        }
        // query params
        if ($special_folder_for_all_images !== null) {
            $queryParams['specialFolderForAllImages'] = ObjectSerializer::toQueryValue($special_folder_for_all_images);
        }
        // query params
        if ($special_folder_for_svg_images !== null) {
            $queryParams['specialFolderForSvgImages'] = ObjectSerializer::toQueryValue($special_folder_for_svg_images);
        }
        // query params
        if ($try_save_text_underlining_and_strikeouting_in_css !== null) {
            $queryParams['trySaveTextUnderliningAndStrikeoutingInCss'] = ObjectSerializer::toQueryValue($try_save_text_underlining_and_strikeouting_in_css);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToLaTeX
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToLaTeX($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToLaTeXWithHttpInfo($name, $out_path, $pages_count, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToLaTeXWithHttpInfo($name, $out_path, $pages_count, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToLaTeXWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToLaTeXWithHttpInfo($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToLaTeXRequest($name, $out_path, $pages_count, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToLaTeXAsync
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToLaTeXAsync($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToLaTeXAsyncWithHttpInfo($name, $out_path, $pages_count, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToLaTeXAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to LaTeX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToLaTeXAsyncWithHttpInfo($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToLaTeXRequest($name, $out_path, $pages_count, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToLaTeX'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tex) (required)
     * @param  int $pages_count Pages count. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToLaTeXRequest($name, $out_path, $pages_count = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToLaTeX'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToLaTeX'
            );
        }

        $resourcePath = '/pdf/{name}/convert/latex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($pages_count !== null) {
            $queryParams['pagesCount'] = ObjectSerializer::toQueryValue($pages_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToMobiXml
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToMobiXml($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToMobiXmlWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToMobiXmlWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToMobiXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToMobiXmlWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToMobiXmlRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToMobiXmlAsync
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToMobiXmlAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToMobiXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to MOBIXML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToMobiXmlAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToMobiXmlRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToMobiXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.mobixml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToMobiXmlRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToMobiXml'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToMobiXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/mobixml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToPdfA
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToPdfA($name, $out_path, $type, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToPdfAWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToPdfAWithHttpInfo($name, $out_path, $type, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToPdfARequest($name, $out_path, $type, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToPdfAAsync
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPdfAAsync($name, $out_path, $type, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToPdfAAsyncWithHttpInfo($name, $out_path, $type, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToPdfAAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PdfA format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPdfAAsyncWithHttpInfo($name, $out_path, $type, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToPdfARequest($name, $out_path, $type, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToPdfA'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $type Type of PdfA format. (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToPdfARequest($name, $out_path, $type, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToPdfA'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling putPdfInStorageToPdfA'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pdfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToPptx
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToPptx($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToPptxWithHttpInfo($name, $out_path, $separate_images, $slides_as_images, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToPptxWithHttpInfo($name, $out_path, $separate_images, $slides_as_images, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToPptxWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToPptxWithHttpInfo($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToPptxRequest($name, $out_path, $separate_images, $slides_as_images, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToPptxAsync
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPptxAsync($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToPptxAsyncWithHttpInfo($name, $out_path, $separate_images, $slides_as_images, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToPptxAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to PPTX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToPptxAsyncWithHttpInfo($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToPptxRequest($name, $out_path, $separate_images, $slides_as_images, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToPptx'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pptx) (required)
     * @param  bool $separate_images Separate images. (optional)
     * @param  bool $slides_as_images Slides as images. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToPptxRequest($name, $out_path, $separate_images = null, $slides_as_images = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToPptx'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToPptx'
            );
        }

        $resourcePath = '/pdf/{name}/convert/pptx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($separate_images !== null) {
            $queryParams['separateImages'] = ObjectSerializer::toQueryValue($separate_images);
        }
        // query params
        if ($slides_as_images !== null) {
            $queryParams['slidesAsImages'] = ObjectSerializer::toQueryValue($slides_as_images);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToSvg
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToSvg($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToSvgWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToSvgWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToSvgWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToSvgWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToSvgRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToSvgAsync
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToSvgAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToSvgAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToSvgAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to SVG format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToSvgAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToSvgRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToSvg'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.svg) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToSvgRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToSvg'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToSvg'
            );
        }

        $resourcePath = '/pdf/{name}/convert/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToTiff
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToTiff($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToTiffWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToTiffWithHttpInfo($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToTiffRequest($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToTiffAsync
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToTiffAsync($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToTiffAsyncWithHttpInfo($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToTiffAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to TIFF format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToTiffAsyncWithHttpInfo($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToTiffRequest($name, $out_path, $brightness, $compression, $color_depth, $left_margin, $right_margin, $top_margin, $bottom_margin, $orientation, $skip_blank_pages, $width, $height, $x_resolution, $y_resolution, $page_index, $page_count, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToTiff'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.tiff) (required)
     * @param  double $brightness Image brightness. (optional)
     * @param  string $compression Tiff compression. Possible values are: LZW, CCITT4, CCITT3, RLE, None. (optional)
     * @param  string $color_depth Image color depth. Possible valuse are: Default, Format8bpp, Format4bpp, Format1bpp. (optional)
     * @param  int $left_margin Left image margin. (optional)
     * @param  int $right_margin Right image margin. (optional)
     * @param  int $top_margin Top image margin. (optional)
     * @param  int $bottom_margin Bottom image margin. (optional)
     * @param  string $orientation Image orientation. Possible values are: None, Landscape, Portait. (optional)
     * @param  bool $skip_blank_pages Skip blank pages flag. (optional)
     * @param  int $width Image width. (optional)
     * @param  int $height Image height. (optional)
     * @param  int $x_resolution Horizontal resolution. (optional)
     * @param  int $y_resolution Vertical resolution. (optional)
     * @param  int $page_index Start page to export. (optional)
     * @param  int $page_count Number of pages to export. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToTiffRequest($name, $out_path, $brightness = null, $compression = null, $color_depth = null, $left_margin = null, $right_margin = null, $top_margin = null, $bottom_margin = null, $orientation = null, $skip_blank_pages = null, $width = null, $height = null, $x_resolution = null, $y_resolution = null, $page_index = null, $page_count = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToTiff'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToTiff'
            );
        }

        $resourcePath = '/pdf/{name}/convert/tiff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($brightness !== null) {
            $queryParams['brightness'] = ObjectSerializer::toQueryValue($brightness);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($color_depth !== null) {
            $queryParams['colorDepth'] = ObjectSerializer::toQueryValue($color_depth);
        }
        // query params
        if ($left_margin !== null) {
            $queryParams['leftMargin'] = ObjectSerializer::toQueryValue($left_margin);
        }
        // query params
        if ($right_margin !== null) {
            $queryParams['rightMargin'] = ObjectSerializer::toQueryValue($right_margin);
        }
        // query params
        if ($top_margin !== null) {
            $queryParams['topMargin'] = ObjectSerializer::toQueryValue($top_margin);
        }
        // query params
        if ($bottom_margin !== null) {
            $queryParams['bottomMargin'] = ObjectSerializer::toQueryValue($bottom_margin);
        }
        // query params
        if ($orientation !== null) {
            $queryParams['orientation'] = ObjectSerializer::toQueryValue($orientation);
        }
        // query params
        if ($skip_blank_pages !== null) {
            $queryParams['skipBlankPages'] = ObjectSerializer::toQueryValue($skip_blank_pages);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($x_resolution !== null) {
            $queryParams['xResolution'] = ObjectSerializer::toQueryValue($x_resolution);
        }
        // query params
        if ($y_resolution !== null) {
            $queryParams['yResolution'] = ObjectSerializer::toQueryValue($y_resolution);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index);
        }
        // query params
        if ($page_count !== null) {
            $queryParams['pageCount'] = ObjectSerializer::toQueryValue($page_count);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXls
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToXls($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToXlsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXlsWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXlsAsync
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsAsync($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToXlsAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXlsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXls'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xls) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXlsRequest($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXls'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXls'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXlsx
     *
     * Converts PDF document (located on storage) to XLSX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToXlsx($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToXlsxWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToXlsxWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToXlsxWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLSX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXlsxWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXlsxRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXlsxAsync
     *
     * Converts PDF document (located on storage) to XLSX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsxAsync($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToXlsxAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXlsxAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XLSX format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXlsxAsyncWithHttpInfo($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXlsxRequest($name, $out_path, $insert_blank_column_at_first, $minimize_the_number_of_worksheets, $scale_factor, $uniform_worksheets, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXlsx'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xlsx) (required)
     * @param  bool $insert_blank_column_at_first Insert blank column at first (optional)
     * @param  bool $minimize_the_number_of_worksheets Minimize the number of worksheets (optional)
     * @param  double $scale_factor Scale factor (optional)
     * @param  bool $uniform_worksheets Uniform worksheets (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXlsxRequest($name, $out_path, $insert_blank_column_at_first = null, $minimize_the_number_of_worksheets = null, $scale_factor = null, $uniform_worksheets = null, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXlsx'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXlsx'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xlsx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($insert_blank_column_at_first !== null) {
            $queryParams['insertBlankColumnAtFirst'] = ObjectSerializer::toQueryValue($insert_blank_column_at_first);
        }
        // query params
        if ($minimize_the_number_of_worksheets !== null) {
            $queryParams['minimizeTheNumberOfWorksheets'] = ObjectSerializer::toQueryValue($minimize_the_number_of_worksheets);
        }
        // query params
        if ($scale_factor !== null) {
            $queryParams['scaleFactor'] = ObjectSerializer::toQueryValue($scale_factor);
        }
        // query params
        if ($uniform_worksheets !== null) {
            $queryParams['uniformWorksheets'] = ObjectSerializer::toQueryValue($uniform_worksheets);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXml
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToXml($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToXmlWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToXmlWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToXmlWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXmlWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXmlRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXmlAsync
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXmlAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToXmlAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXmlAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XML format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXmlAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXmlRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXml'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xml) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXmlRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXml'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXml'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPdfInStorageToXps
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPdfInStorageToXps($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPdfInStorageToXpsWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPdfInStorageToXpsWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXpsRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPdfInStorageToXpsAsync
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXpsAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putPdfInStorageToXpsAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPdfInStorageToXpsAsyncWithHttpInfo
     *
     * Converts PDF document (located on storage) to XPS format and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPdfInStorageToXpsAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPdfInStorageToXpsRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPdfInStorageToXps'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.xps) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPdfInStorageToXpsRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPdfInStorageToXps'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putPdfInStorageToXps'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPolyLineAnnotation
     *
     * Replace document polyline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolyLineAnnotationResponse
     */
    public function putPolyLineAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPolyLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPolyLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPolyLineAnnotationWithHttpInfo
     *
     * Replace document polyline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolyLineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPolyLineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationResponse';
        $request = $this->putPolyLineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolyLineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPolyLineAnnotationAsync
     *
     * Replace document polyline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPolyLineAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putPolyLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPolyLineAnnotationAsyncWithHttpInfo
     *
     * Replace document polyline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPolyLineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolyLineAnnotationResponse';
        $request = $this->putPolyLineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPolyLineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolyLineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPolyLineAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPolyLineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putPolyLineAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putPolyLineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polyline/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPolygonAnnotation
     *
     * Replace document polygon annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PolygonAnnotationResponse
     */
    public function putPolygonAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPolygonAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPolygonAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPolygonAnnotationWithHttpInfo
     *
     * Replace document polygon annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PolygonAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPolygonAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationResponse';
        $request = $this->putPolygonAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PolygonAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPolygonAnnotationAsync
     *
     * Replace document polygon annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPolygonAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putPolygonAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPolygonAnnotationAsyncWithHttpInfo
     *
     * Replace document polygon annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPolygonAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PolygonAnnotationResponse';
        $request = $this->putPolygonAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPolygonAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PolygonAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPolygonAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPolygonAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putPolygonAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putPolygonAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/polygon/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPopupAnnotation
     *
     * Replace document popup annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\PopupAnnotationResponse
     */
    public function putPopupAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPopupAnnotationWithHttpInfo
     *
     * Replace document popup annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\PopupAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPopupAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationResponse';
        $request = $this->putPopupAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\PopupAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPopupAnnotationAsync
     *
     * Replace document popup annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPopupAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPopupAnnotationAsyncWithHttpInfo
     *
     * Replace document popup annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPopupAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\PopupAnnotationResponse';
        $request = $this->putPopupAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPopupAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\PopupAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPopupAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putPopupAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putPopupAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/popup/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPrivileges
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPrivileges($name, $privileges = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putPrivilegesWithHttpInfo($name, $privileges, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPrivilegesWithHttpInfo($name, $privileges, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPrivilegesWithHttpInfo
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPrivilegesWithHttpInfo($name, $privileges = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPrivilegesRequest($name, $privileges, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPrivilegesAsync
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPrivilegesAsync($name, $privileges = null, $storage = null, $folder = null)
    {
        return $this->putPrivilegesAsyncWithHttpInfo($name, $privileges, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPrivilegesAsyncWithHttpInfo
     *
     * Update privilege document.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPrivilegesAsyncWithHttpInfo($name, $privileges = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPrivilegesRequest($name, $privileges, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPrivileges'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\DocumentPrivilege $privileges Document privileges. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPrivilegesRequest($name, $privileges = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPrivileges'
            );
        }

        $resourcePath = '/pdf/{name}/privileges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($privileges)) {
            $_tempBody = $privileges;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPsInStorageToPdf
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putPsInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putPsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putPsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putPsInStorageToPdfWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPsInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPsInStorageToPdfAsync
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPsInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putPsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert PS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putPsInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPsInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.ps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPsInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putPsInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putPsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/ps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRedactionAnnotation
     *
     * Replace document redaction annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\RedactionAnnotationResponse
     */
    public function putRedactionAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putRedactionAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putRedactionAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putRedactionAnnotationWithHttpInfo
     *
     * Replace document redaction annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\RedactionAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRedactionAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\RedactionAnnotationResponse';
        $request = $this->putRedactionAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\RedactionAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRedactionAnnotationAsync
     *
     * Replace document redaction annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRedactionAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putRedactionAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRedactionAnnotationAsyncWithHttpInfo
     *
     * Replace document redaction annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRedactionAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\RedactionAnnotationResponse';
        $request = $this->putRedactionAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRedactionAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\RedactionAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putRedactionAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putRedactionAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putRedactionAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putRedactionAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/redaction/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putReplaceImage
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ImageResponse
     */
    public function putReplaceImage($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        try
        {
            list($response) = $this->putReplaceImageWithHttpInfo($name, $image_id, $image_file_path, $storage, $folder, $image);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putReplaceImageWithHttpInfo($name, $image_id, $image_file_path, $storage, $folder, $image);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putReplaceImageWithHttpInfo
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ImageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putReplaceImageWithHttpInfo($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->putReplaceImageRequest($name, $image_id, $image_file_path, $storage, $folder, $image);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ImageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putReplaceImageAsync
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putReplaceImageAsync($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        return $this->putReplaceImageAsyncWithHttpInfo($name, $image_id, $image_file_path, $storage, $folder, $image)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putReplaceImageAsyncWithHttpInfo
     *
     * Replace document image.
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putReplaceImageAsyncWithHttpInfo($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        $returnType = '\Aspose\PDF\Model\ImageResponse';
        $request = $this->putReplaceImageRequest($name, $image_id, $image_file_path, $storage, $folder, $image);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putReplaceImage'
     *
     * @param  string $name The document name. (required)
     * @param  string $image_id The image ID. (required)
     * @param  string $image_file_path Path to image file if specified. Request content is used otherwise. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  \SplFileObject $image Image file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putReplaceImageRequest($name, $image_id, $image_file_path = null, $storage = null, $folder = null, $image = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putReplaceImage'
            );
        }
        // verify the required parameter 'image_id' is set
        if ($image_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_id when calling putReplaceImage'
            );
        }

        $resourcePath = '/pdf/{name}/images/{imageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_file_path !== null) {
            $queryParams['imageFilePath'] = ObjectSerializer::toQueryValue($image_file_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_id !== null) {
            $resourcePath = str_replace(
                '{' . 'imageId' . '}',
                ObjectSerializer::toPathValue($image_id),
                $resourcePath
            );
        }

        // form params
        if ($image !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($image);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['image'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['image'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putScreenAnnotation
     *
     * Replace document screen annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\ScreenAnnotationResponse
     */
    public function putScreenAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putScreenAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putScreenAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putScreenAnnotationWithHttpInfo
     *
     * Replace document screen annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\ScreenAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putScreenAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ScreenAnnotationResponse';
        $request = $this->putScreenAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\ScreenAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putScreenAnnotationAsync
     *
     * Replace document screen annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putScreenAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putScreenAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putScreenAnnotationAsyncWithHttpInfo
     *
     * Replace document screen annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putScreenAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\ScreenAnnotationResponse';
        $request = $this->putScreenAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putScreenAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\ScreenAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putScreenAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putScreenAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putScreenAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putScreenAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/screen/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putScreenAnnotationDataExtract
     *
     * Extract document screen annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putScreenAnnotationDataExtract($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putScreenAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_file_path, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putScreenAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_file_path, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putScreenAnnotationDataExtractWithHttpInfo
     *
     * Extract document screen annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putScreenAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putScreenAnnotationDataExtractRequest($name, $annotation_id, $out_file_path, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putScreenAnnotationDataExtractAsync
     *
     * Extract document screen annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putScreenAnnotationDataExtractAsync($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        return $this->putScreenAnnotationDataExtractAsyncWithHttpInfo($name, $annotation_id, $out_file_path, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putScreenAnnotationDataExtractAsyncWithHttpInfo
     *
     * Extract document screen annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putScreenAnnotationDataExtractAsyncWithHttpInfo($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putScreenAnnotationDataExtractRequest($name, $annotation_id, $out_file_path, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putScreenAnnotationDataExtract'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putScreenAnnotationDataExtractRequest($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putScreenAnnotationDataExtract'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putScreenAnnotationDataExtract'
            );
        }
        // verify the required parameter 'out_file_path' is set
        if ($out_file_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_file_path when calling putScreenAnnotationDataExtract'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/screen/{annotationId}/data/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_file_path !== null) {
            $queryParams['outFilePath'] = ObjectSerializer::toQueryValue($out_file_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSearchableDocument
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putSearchableDocument($name, $storage = null, $folder = null, $lang = null)
    {
        try
        {
            list($response) = $this->putSearchableDocumentWithHttpInfo($name, $storage, $folder, $lang);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSearchableDocumentWithHttpInfo($name, $storage, $folder, $lang);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSearchableDocumentWithHttpInfo
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSearchableDocumentWithHttpInfo($name, $storage = null, $folder = null, $lang = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSearchableDocumentRequest($name, $storage, $folder, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSearchableDocumentAsync
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSearchableDocumentAsync($name, $storage = null, $folder = null, $lang = null)
    {
        return $this->putSearchableDocumentAsyncWithHttpInfo($name, $storage, $folder, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSearchableDocumentAsyncWithHttpInfo
     *
     * Create searchable PDF document. Generate OCR layer for images in input PDF document.
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSearchableDocumentAsyncWithHttpInfo($name, $storage = null, $folder = null, $lang = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSearchableDocumentRequest($name, $storage, $folder, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSearchableDocument'
     *
     * @param  string $name The document name. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     * @param  string $lang language for OCR engine. Possible values: eng, ara, bel, ben, bul, ces, dan, deu, ell, fin, fra, heb, hin, ind, isl, ita, jpn, kor, nld, nor, pol, por, ron, rus, spa, swe, tha, tur, ukr, vie, chi_sim, chi_tra or thier combination e.g. eng,rus (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSearchableDocumentRequest($name, $storage = null, $folder = null, $lang = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSearchableDocument'
            );
        }

        $resourcePath = '/pdf/{name}/ocr';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSetProperty
     *
     * Add/update document property.
     *
     * @param  string $name name (required)
     * @param  string $property_name property_name (required)
     * @param  string $value value (required)
     * @param  string $storage storage (optional)
     * @param  string $folder folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\DocumentPropertyResponse
     */
    public function putSetProperty($name, $property_name, $value, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putSetPropertyWithHttpInfo($name, $property_name, $value, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSetPropertyWithHttpInfo($name, $property_name, $value, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSetPropertyWithHttpInfo
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $value (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSetPropertyWithHttpInfo($name, $property_name, $value, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->putSetPropertyRequest($name, $property_name, $value, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\DocumentPropertyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSetPropertyAsync
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $value (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSetPropertyAsync($name, $property_name, $value, $storage = null, $folder = null)
    {
        return $this->putSetPropertyAsyncWithHttpInfo($name, $property_name, $value, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSetPropertyAsyncWithHttpInfo
     *
     * Add/update document property.
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $value (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSetPropertyAsyncWithHttpInfo($name, $property_name, $value, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\DocumentPropertyResponse';
        $request = $this->putSetPropertyRequest($name, $property_name, $value, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSetProperty'
     *
     * @param  string $name (required)
     * @param  string $property_name (required)
     * @param  string $value (required)
     * @param  string $storage (optional)
     * @param  string $folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSetPropertyRequest($name, $property_name, $value, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSetProperty'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling putSetProperty'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling putSetProperty'
            );
        }

        $resourcePath = '/pdf/{name}/documentproperties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSoundAnnotation
     *
     * Replace document sound annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SoundAnnotationResponse
     */
    public function putSoundAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putSoundAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSoundAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSoundAnnotationWithHttpInfo
     *
     * Replace document sound annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SoundAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSoundAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SoundAnnotationResponse';
        $request = $this->putSoundAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SoundAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSoundAnnotationAsync
     *
     * Replace document sound annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSoundAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putSoundAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSoundAnnotationAsyncWithHttpInfo
     *
     * Replace document sound annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSoundAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SoundAnnotationResponse';
        $request = $this->putSoundAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSoundAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SoundAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSoundAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSoundAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putSoundAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putSoundAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/sound/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSoundAnnotationDataExtract
     *
     * Extract document sound annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putSoundAnnotationDataExtract($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putSoundAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_file_path, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSoundAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_file_path, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSoundAnnotationDataExtractWithHttpInfo
     *
     * Extract document sound annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSoundAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSoundAnnotationDataExtractRequest($name, $annotation_id, $out_file_path, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSoundAnnotationDataExtractAsync
     *
     * Extract document sound annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSoundAnnotationDataExtractAsync($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        return $this->putSoundAnnotationDataExtractAsyncWithHttpInfo($name, $annotation_id, $out_file_path, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSoundAnnotationDataExtractAsyncWithHttpInfo
     *
     * Extract document sound annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSoundAnnotationDataExtractAsyncWithHttpInfo($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSoundAnnotationDataExtractRequest($name, $annotation_id, $out_file_path, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSoundAnnotationDataExtract'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSoundAnnotationDataExtractRequest($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSoundAnnotationDataExtract'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putSoundAnnotationDataExtract'
            );
        }
        // verify the required parameter 'out_file_path' is set
        if ($out_file_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_file_path when calling putSoundAnnotationDataExtract'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/sound/{annotationId}/data/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_file_path !== null) {
            $queryParams['outFilePath'] = ObjectSerializer::toQueryValue($out_file_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSquareAnnotation
     *
     * Replace document square annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquareAnnotationResponse
     */
    public function putSquareAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putSquareAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSquareAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSquareAnnotationWithHttpInfo
     *
     * Replace document square annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquareAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSquareAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationResponse';
        $request = $this->putSquareAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquareAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSquareAnnotationAsync
     *
     * Replace document square annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSquareAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putSquareAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSquareAnnotationAsyncWithHttpInfo
     *
     * Replace document square annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSquareAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquareAnnotationResponse';
        $request = $this->putSquareAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSquareAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquareAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSquareAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSquareAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putSquareAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putSquareAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/square/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSquigglyAnnotation
     *
     * Replace document squiggly annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\SquigglyAnnotationResponse
     */
    public function putSquigglyAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putSquigglyAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSquigglyAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSquigglyAnnotationWithHttpInfo
     *
     * Replace document squiggly annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\SquigglyAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSquigglyAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationResponse';
        $request = $this->putSquigglyAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\SquigglyAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSquigglyAnnotationAsync
     *
     * Replace document squiggly annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSquigglyAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putSquigglyAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSquigglyAnnotationAsyncWithHttpInfo
     *
     * Replace document squiggly annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSquigglyAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\SquigglyAnnotationResponse';
        $request = $this->putSquigglyAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSquigglyAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\SquigglyAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSquigglyAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSquigglyAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putSquigglyAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putSquigglyAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/squiggly/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStampAnnotation
     *
     * Replace document stamp annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StampAnnotationResponse
     */
    public function putStampAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putStampAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putStampAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putStampAnnotationWithHttpInfo
     *
     * Replace document stamp annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StampAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStampAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampAnnotationResponse';
        $request = $this->putStampAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StampAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putStampAnnotationAsync
     *
     * Replace document stamp annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStampAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putStampAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStampAnnotationAsyncWithHttpInfo
     *
     * Replace document stamp annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStampAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StampAnnotationResponse';
        $request = $this->putStampAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStampAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StampAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStampAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putStampAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putStampAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putStampAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/stamp/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStampAnnotationDataExtract
     *
     * Extract document stamp annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putStampAnnotationDataExtract($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putStampAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_file_path, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putStampAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_file_path, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putStampAnnotationDataExtractWithHttpInfo
     *
     * Extract document stamp annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStampAnnotationDataExtractWithHttpInfo($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putStampAnnotationDataExtractRequest($name, $annotation_id, $out_file_path, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putStampAnnotationDataExtractAsync
     *
     * Extract document stamp annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStampAnnotationDataExtractAsync($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        return $this->putStampAnnotationDataExtractAsyncWithHttpInfo($name, $annotation_id, $out_file_path, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStampAnnotationDataExtractAsyncWithHttpInfo
     *
     * Extract document stamp annotation content to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStampAnnotationDataExtractAsyncWithHttpInfo($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putStampAnnotationDataExtractRequest($name, $annotation_id, $out_file_path, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStampAnnotationDataExtract'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  string $out_file_path The output file path. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStampAnnotationDataExtractRequest($name, $annotation_id, $out_file_path, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putStampAnnotationDataExtract'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putStampAnnotationDataExtract'
            );
        }
        // verify the required parameter 'out_file_path' is set
        if ($out_file_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_file_path when calling putStampAnnotationDataExtract'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/stamp/{annotationId}/data/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_file_path !== null) {
            $queryParams['outFilePath'] = ObjectSerializer::toQueryValue($out_file_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStrikeOutAnnotation
     *
     * Replace document StrikeOut annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\StrikeOutAnnotationResponse
     */
    public function putStrikeOutAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putStrikeOutAnnotationWithHttpInfo
     *
     * Replace document StrikeOut annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\StrikeOutAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStrikeOutAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationResponse';
        $request = $this->putStrikeOutAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\StrikeOutAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putStrikeOutAnnotationAsync
     *
     * Replace document StrikeOut annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStrikeOutAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putStrikeOutAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStrikeOutAnnotationAsyncWithHttpInfo
     *
     * Replace document StrikeOut annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStrikeOutAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\StrikeOutAnnotationResponse';
        $request = $this->putStrikeOutAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStrikeOutAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\StrikeOutAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStrikeOutAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putStrikeOutAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putStrikeOutAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putStrikeOutAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/strikeout/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSvgInStorageToPdf
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putSvgInStorageToPdf($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putSvgInStorageToPdfWithHttpInfo($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putSvgInStorageToPdfWithHttpInfo($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putSvgInStorageToPdfWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSvgInStorageToPdfWithHttpInfo($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSvgInStorageToPdfRequest($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSvgInStorageToPdfAsync
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSvgInStorageToPdfAsync($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        return $this->putSvgInStorageToPdfAsyncWithHttpInfo($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSvgInStorageToPdfAsyncWithHttpInfo
     *
     * Convert SVG file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSvgInStorageToPdfAsyncWithHttpInfo($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putSvgInStorageToPdfRequest($name, $src_path, $adjust_page_size, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSvgInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.svg) (required)
     * @param  bool $adjust_page_size Adjust page size (optional)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSvgInStorageToPdfRequest($name, $src_path, $adjust_page_size = null, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putSvgInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putSvgInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/svg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($adjust_page_size !== null) {
            $queryParams['adjustPageSize'] = ObjectSerializer::toQueryValue($adjust_page_size);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTable
     *
     * Replace document page table.
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  \Aspose\PDF\Model\Table $table The table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putTable($name, $table_id, $table, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putTableWithHttpInfo($name, $table_id, $table, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putTableWithHttpInfo($name, $table_id, $table, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putTableWithHttpInfo
     *
     * Replace document page table.
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  \Aspose\PDF\Model\Table $table The table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTableWithHttpInfo($name, $table_id, $table, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putTableRequest($name, $table_id, $table, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putTableAsync
     *
     * Replace document page table.
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  \Aspose\PDF\Model\Table $table The table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTableAsync($name, $table_id, $table, $storage = null, $folder = null)
    {
        return $this->putTableAsyncWithHttpInfo($name, $table_id, $table, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTableAsyncWithHttpInfo
     *
     * Replace document page table.
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  \Aspose\PDF\Model\Table $table The table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTableAsyncWithHttpInfo($name, $table_id, $table, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putTableRequest($name, $table_id, $table, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTable'
     *
     * @param  string $name The document name. (required)
     * @param  string $table_id The table ID. (required)
     * @param  \Aspose\PDF\Model\Table $table The table. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTableRequest($name, $table_id, $table, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putTable'
            );
        }
        // verify the required parameter 'table_id' is set
        if ($table_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table_id when calling putTable'
            );
        }
        // verify the required parameter 'table' is set
        if ($table === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling putTable'
            );
        }

        $resourcePath = '/pdf/{name}/tables/{tableId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($table_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($table_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($table)) {
            $_tempBody = $table;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTextAnnotation
     *
     * Replace document text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\TextAnnotationResponse
     */
    public function putTextAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putTextAnnotationWithHttpInfo
     *
     * Replace document text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\TextAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTextAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationResponse';
        $request = $this->putTextAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\TextAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putTextAnnotationAsync
     *
     * Replace document text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTextAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTextAnnotationAsyncWithHttpInfo
     *
     * Replace document text annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTextAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\TextAnnotationResponse';
        $request = $this->putTextAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTextAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\TextAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTextAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putTextAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putTextAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putTextAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/text/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUnderlineAnnotation
     *
     * Replace document underline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\UnderlineAnnotationResponse
     */
    public function putUnderlineAnnotation($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putUnderlineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putUnderlineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putUnderlineAnnotationWithHttpInfo
     *
     * Replace document underline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\UnderlineAnnotationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUnderlineAnnotationWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationResponse';
        $request = $this->putUnderlineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\UnderlineAnnotationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUnderlineAnnotationAsync
     *
     * Replace document underline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUnderlineAnnotationAsync($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        return $this->putUnderlineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUnderlineAnnotationAsyncWithHttpInfo
     *
     * Replace document underline annotation
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUnderlineAnnotationAsyncWithHttpInfo($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\UnderlineAnnotationResponse';
        $request = $this->putUnderlineAnnotationRequest($name, $annotation_id, $annotation, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUnderlineAnnotation'
     *
     * @param  string $name The document name. (required)
     * @param  string $annotation_id The annotation ID. (required)
     * @param  \Aspose\PDF\Model\UnderlineAnnotation $annotation Annotation. (required)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUnderlineAnnotationRequest($name, $annotation_id, $annotation, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUnderlineAnnotation'
            );
        }
        // verify the required parameter 'annotation_id' is set
        if ($annotation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation_id when calling putUnderlineAnnotation'
            );
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annotation when calling putUnderlineAnnotation'
            );
        }

        $resourcePath = '/pdf/{name}/annotations/underline/{annotationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($annotation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'annotationId' . '}',
                ObjectSerializer::toPathValue($annotation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUpdateField
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldResponse
     */
    public function putUpdateField($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putUpdateFieldWithHttpInfo($name, $field_name, $field, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putUpdateFieldWithHttpInfo($name, $field_name, $field, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putUpdateFieldWithHttpInfo
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUpdateFieldWithHttpInfo($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->putUpdateFieldRequest($name, $field_name, $field, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUpdateFieldAsync
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldAsync($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        return $this->putUpdateFieldAsyncWithHttpInfo($name, $field_name, $field, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUpdateFieldAsyncWithHttpInfo
     *
     * Update field.
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldAsyncWithHttpInfo($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldResponse';
        $request = $this->putUpdateFieldRequest($name, $field_name, $field, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUpdateField'
     *
     * @param  string $name The document name. (required)
     * @param  string $field_name The name of a field to be updated. (required)
     * @param  \Aspose\PDF\Model\Field $field with the field data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUpdateFieldRequest($name, $field_name, $field = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUpdateField'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling putUpdateField'
            );
        }

        $resourcePath = '/pdf/{name}/fields/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($field)) {
            $_tempBody = $field;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putUpdateFields
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\FieldsResponse
     */
    public function putUpdateFields($name, $fields = null, $storage = null, $folder = null)
    {
        try
        {
            list($response) = $this->putUpdateFieldsWithHttpInfo($name, $fields, $storage, $folder);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putUpdateFieldsWithHttpInfo($name, $fields, $storage, $folder);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putUpdateFieldsWithHttpInfo
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putUpdateFieldsWithHttpInfo($name, $fields = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->putUpdateFieldsRequest($name, $fields, $storage, $folder);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\FieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putUpdateFieldsAsync
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldsAsync($name, $fields = null, $storage = null, $folder = null)
    {
        return $this->putUpdateFieldsAsyncWithHttpInfo($name, $fields, $storage, $folder)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putUpdateFieldsAsyncWithHttpInfo
     *
     * Update fields.
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putUpdateFieldsAsyncWithHttpInfo($name, $fields = null, $storage = null, $folder = null)
    {
        $returnType = '\Aspose\PDF\Model\FieldsResponse';
        $request = $this->putUpdateFieldsRequest($name, $fields, $storage, $folder);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putUpdateFields'
     *
     * @param  string $name The document name. (required)
     * @param  \Aspose\PDF\Model\Fields $fields with the fields data. (optional)
     * @param  string $storage The document storage. (optional)
     * @param  string $folder The document folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putUpdateFieldsRequest($name, $fields = null, $storage = null, $folder = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putUpdateFields'
            );
        }

        $resourcePath = '/pdf/{name}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($fields)) {
            $_tempBody = $fields;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putWebInStorageToPdf
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putWebInStorageToPdf($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putWebInStorageToPdfWithHttpInfo($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putWebInStorageToPdfWithHttpInfo($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putWebInStorageToPdfWithHttpInfo
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putWebInStorageToPdfWithHttpInfo($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putWebInStorageToPdfRequest($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putWebInStorageToPdfAsync
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putWebInStorageToPdfAsync($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        return $this->putWebInStorageToPdfAsyncWithHttpInfo($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putWebInStorageToPdfAsyncWithHttpInfo
     *
     * Convert web page to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putWebInStorageToPdfAsyncWithHttpInfo($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putWebInStorageToPdfRequest($name, $url, $height, $width, $is_landscape, $margin_left, $margin_bottom, $margin_right, $margin_top, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putWebInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $url Source url (required)
     * @param  double $height Page height (optional)
     * @param  double $width Page width (optional)
     * @param  bool $is_landscape Is page landscaped (optional)
     * @param  double $margin_left Page margin left (optional)
     * @param  double $margin_bottom Page margin bottom (optional)
     * @param  double $margin_right Page margin right (optional)
     * @param  double $margin_top Page margin top (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putWebInStorageToPdfRequest($name, $url, $height = null, $width = null, $is_landscape = null, $margin_left = null, $margin_bottom = null, $margin_right = null, $margin_top = null, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putWebInStorageToPdf'
            );
        }
        // verify the required parameter 'url' is set
        if ($url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling putWebInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/web';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($is_landscape !== null) {
            $queryParams['isLandscape'] = ObjectSerializer::toQueryValue($is_landscape);
        }
        // query params
        if ($margin_left !== null) {
            $queryParams['marginLeft'] = ObjectSerializer::toQueryValue($margin_left);
        }
        // query params
        if ($margin_bottom !== null) {
            $queryParams['marginBottom'] = ObjectSerializer::toQueryValue($margin_bottom);
        }
        // query params
        if ($margin_right !== null) {
            $queryParams['marginRight'] = ObjectSerializer::toQueryValue($margin_right);
        }
        // query params
        if ($margin_top !== null) {
            $queryParams['marginTop'] = ObjectSerializer::toQueryValue($margin_top);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXfaPdfInRequestToAcroForm
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXfaPdfInRequestToAcroForm($out_path, $storage = null, $file = null)
    {
        try
        {
            list($response) = $this->putXfaPdfInRequestToAcroFormWithHttpInfo($out_path, $storage, $file);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXfaPdfInRequestToAcroFormWithHttpInfo($out_path, $storage, $file);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXfaPdfInRequestToAcroFormWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXfaPdfInRequestToAcroFormWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXfaPdfInRequestToAcroFormRequest($out_path, $storage, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXfaPdfInRequestToAcroFormAsync
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInRequestToAcroFormAsync($out_path, $storage = null, $file = null)
    {
        return $this->putXfaPdfInRequestToAcroFormAsyncWithHttpInfo($out_path, $storage, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXfaPdfInRequestToAcroFormAsyncWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (in request content) to PDF with AcroForm and uploads resulting file to storage.
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInRequestToAcroFormAsyncWithHttpInfo($out_path, $storage = null, $file = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXfaPdfInRequestToAcroFormRequest($out_path, $storage, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXfaPdfInRequestToAcroForm'
     *
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $storage The document storage. (optional)
     * @param  \SplFileObject $file A file to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXfaPdfInRequestToAcroFormRequest($out_path, $storage = null, $file = null)
    {
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putXfaPdfInRequestToAcroForm'
            );
        }

        $resourcePath = '/pdf/convert/xfatoacroform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $filename = ObjectSerializer::toFormValue($file);
            $handle = fopen($filename, "rb");
            $fsize = filesize($filename);
            $contents = fread($handle, $fsize);
            $formParams['file'] = $contents;
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams['file'];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXfaPdfInStorageToAcroForm
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXfaPdfInStorageToAcroForm($name, $out_path, $folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putXfaPdfInStorageToAcroFormWithHttpInfo($name, $out_path, $folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXfaPdfInStorageToAcroFormWithHttpInfo($name, $out_path, $folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXfaPdfInStorageToAcroFormWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXfaPdfInStorageToAcroFormWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXfaPdfInStorageToAcroFormRequest($name, $out_path, $folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXfaPdfInStorageToAcroFormAsync
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInStorageToAcroFormAsync($name, $out_path, $folder = null, $storage = null)
    {
        return $this->putXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $out_path, $folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXfaPdfInStorageToAcroFormAsyncWithHttpInfo
     *
     * Converts PDF document which contatins XFA form (located on storage) to PDF with AcroForm and uploads resulting file to storage
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXfaPdfInStorageToAcroFormAsyncWithHttpInfo($name, $out_path, $folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXfaPdfInStorageToAcroFormRequest($name, $out_path, $folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXfaPdfInStorageToAcroForm'
     *
     * @param  string $name The document name. (required)
     * @param  string $out_path Full resulting filename (ex. /folder1/folder2/result.pdf) (required)
     * @param  string $folder The document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXfaPdfInStorageToAcroFormRequest($name, $out_path, $folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXfaPdfInStorageToAcroForm'
            );
        }
        // verify the required parameter 'out_path' is set
        if ($out_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $out_path when calling putXfaPdfInStorageToAcroForm'
            );
        }

        $resourcePath = '/pdf/{name}/convert/xfatoacroform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($out_path !== null) {
            $queryParams['outPath'] = ObjectSerializer::toQueryValue($out_path);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXmlInStorageToPdf
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXmlInStorageToPdf($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putXmlInStorageToPdfWithHttpInfo($name, $src_path, $xsl_file_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXmlInStorageToPdfWithHttpInfo($name, $src_path, $xsl_file_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXmlInStorageToPdfWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXmlInStorageToPdfWithHttpInfo($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXmlInStorageToPdfRequest($name, $src_path, $xsl_file_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXmlInStorageToPdfAsync
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXmlInStorageToPdfAsync($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        return $this->putXmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $xsl_file_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXmlInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XML file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXmlInStorageToPdfAsyncWithHttpInfo($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXmlInStorageToPdfRequest($name, $src_path, $xsl_file_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXmlInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xml) (required)
     * @param  string $xsl_file_path Full XSL source filename (ex. /folder1/folder2/template.xsl) (optional)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXmlInStorageToPdfRequest($name, $src_path, $xsl_file_path = null, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXmlInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putXmlInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($xsl_file_path !== null) {
            $queryParams['xslFilePath'] = ObjectSerializer::toQueryValue($xsl_file_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXpsInStorageToPdf
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXpsInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putXpsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXpsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXpsInStorageToPdfWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXpsInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXpsInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXpsInStorageToPdfAsync
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXpsInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putXpsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXpsInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XPS file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXpsInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXpsInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXpsInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xps) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXpsInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXpsInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putXpsInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/xps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putXslFoInStorageToPdf
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\PDF\Model\AsposeResponse
     */
    public function putXslFoInStorageToPdf($name, $src_path, $dst_folder = null, $storage = null)
    {
        try
        {
            list($response) = $this->putXslFoInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
            return $response;
        }
        catch (ApiException $ex)
        {
            if ($ex->getCode() == 401)
            {
                $this->_refreshToken();
                list($response) = $this->putXslFoInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder, $storage);
                return $response;
            }
            else
            {
                throw $ex;
            }
        }
    }

    /**
     * Operation putXslFoInStorageToPdfWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \Aspose\PDF\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\PDF\Model\AsposeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putXslFoInStorageToPdfWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXslFoInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aspose\PDF\Model\AsposeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putXslFoInStorageToPdfAsync
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXslFoInStorageToPdfAsync($name, $src_path, $dst_folder = null, $storage = null)
    {
        return $this->putXslFoInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder, $storage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putXslFoInStorageToPdfAsyncWithHttpInfo
     *
     * Convert XslFo file (located on storage) to PDF format and upload resulting file to storage.
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putXslFoInStorageToPdfAsyncWithHttpInfo($name, $src_path, $dst_folder = null, $storage = null)
    {
        $returnType = '\Aspose\PDF\Model\AsposeResponse';
        $request = $this->putXslFoInStorageToPdfRequest($name, $src_path, $dst_folder, $storage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putXslFoInStorageToPdf'
     *
     * @param  string $name The document name. (required)
     * @param  string $src_path Full source filename (ex. /folder1/folder2/template.xpsfo) (required)
     * @param  string $dst_folder The destination document folder. (optional)
     * @param  string $storage The document storage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putXslFoInStorageToPdfRequest($name, $src_path, $dst_folder = null, $storage = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling putXslFoInStorageToPdf'
            );
        }
        // verify the required parameter 'src_path' is set
        if ($src_path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $src_path when calling putXslFoInStorageToPdf'
            );
        }

        $resourcePath = '/pdf/{name}/create/xslfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = ObjectSerializer::toQueryValue($src_path);
        }
        // query params
        if ($dst_folder !== null) {
            $queryParams['dstFolder'] = ObjectSerializer::toQueryValue($dst_folder);
        }
        // query params
        if ($storage !== null) {
            $queryParams['storage'] = ObjectSerializer::toQueryValue($storage);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            // array of objects
            } elseif (is_array($httpBody)) {
                $httpBody = "[" . ObjectSerializer::serializeCollection($httpBody, "") . "]";
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                //$httpBody = new MultipartStream($multipartContents);
                $httpBody = $formParams[''];

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        //ASPOSE_PDF_CLOUD
        if (!$this->config->getAccessToken()) 
        {
            $this->_requestToken();
        }
        if ($this->config->getAccessToken() !== null) 
        {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        //ASPOSE_PDF_CLOUD

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }
        
        //PDFCLOUD-418
        $options['connect_timeout'] = 5 * 60;
        
        return $options;
    }

    //ASPOSE_PDF_CLOUD
    /*
     * Gets a request token from server
     */
    private function _requestToken()
    {
        $requestUrl = $this->config->getHost() . "/oauth2/token";
        $requestUrl = str_replace('/v2.0', '', $requestUrl);
        $postData = "grant_type=client_credentials" . "&client_id=" . $this->config->getAppSid() . "&client_secret=" . $this->config->getAppKey();
        $response = $this->client->send(new Request('POST', $requestUrl, [], $postData));
        $result = json_decode($response->getBody()->getContents(), true);
        $this->config->setAccessToken($result["access_token"]);
        $this->config->setRefreshToken($result["refresh_token"]);
    }
    /*
     * Refresh token
     */
    private function _refreshToken()
    {
        $requestUrl = $this->config->getHost() . "/oauth2/token";
        $requestUrl = str_replace('/v2.0', '', $requestUrl);
        $postData = "grant_type=refresh_token&refresh_token=" . $this->config->getRefreshToken();
        $response = $this->client->send(new Request('POST', $requestUrl, [], $postData));
        $result = json_decode($response->getBody()->getContents(), true);
        $this->config->setAccessToken($result["access_token"]);
        $this->config->setRefreshToken($result["refresh_token"]);
    }
    //ASPOSE_PDF_CLOUD
}
